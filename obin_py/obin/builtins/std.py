from obin.types import api, space, plist, datatype
from obin.runtime import error


class Derived:
    """
    internally used interfaces,types, and traits
    """

    def __init__(self, process):
        from obin.runtime.load import import_module
        prelude = process.modules.prelude
        derive_module = import_module(process, space.newsymbol(process, u"derive"))

        self.TEq = self.find_trait(process, derive_module, u"TEq")
        self.TStr = self.find_trait(process, derive_module, u"TStr")
        self.TRepr = self.find_trait(process, derive_module, u"TRepr")
        self.TCollection = self.find_trait(process, derive_module, u"TCollection")
        self.TSized = self.find_trait(process, derive_module, u"TSized")
        self.TIndexed = self.find_trait(process, derive_module, u"TIndexed")
        self.TDict = self.find_trait(process, derive_module, u"TDict")
        self.TUnionRange = self.find_trait(process, derive_module, u"TUnionRange")

        self.derived_for_singleton = [
            self.TEq, self.TStr, self.TRepr
        ]

        self.derived_for_type = [
            self.TEq, self.TStr, self.TRepr,
            self.TCollection, self.TSized, self.TIndexed, self.TDict
        ]

        self.derived_for_union = [self.TUnionRange]

        self.postderive(process, prelude)
        # TODO REMOVE IT
        # self.TEq = None
        # self.TStr = None
        # self.TRepr = None
        # self.TCollection = None
        # self.TSized = None
        # self.TIndexed = None
        # self.TDict = None
        # self.TUnionRange = None
        #
        # self.derived_for_singleton = None
        # self.derived_for_union = None
        # self.derived_for_type = None

    def _find_in(self, process, prelude, name):
        sym = space.newsymbol(process, name)
        if not api.contains(prelude, sym):
            error.throw_1(error.Errors.KEY_ERROR, space.newstring(u"Missing internal trait %s in prelude" % name))
        return api.at(prelude, sym)

    def find_interface(self, process, module, name):
        _interface = self._find_in(process, module, name)
        error.affirm_type(_interface, space.isinterface)
        return _interface

    def find_trait(self, process, module, name):
        _trait = self._find_in(process, module, name)
        error.affirm_type(_trait, space.istrait)
        return _trait

    def postderive(self, process, module):
        from obin.types import api, datatype
        symbols = module.symbols()
        for sym in symbols:
            obj = api.at(module, sym)
            if space.isextendable(obj):
                derived = self.get_derived(obj)
                datatype.derive(obj, derived)

    def get_derived(self, _type):
        if space.isdatatype(_type):
            if _type.is_singleton:
                return self.derived_for_singleton
            else:
                return self.derived_for_type
        elif space.isunion(_type):
            return self.derived_for_union
        else:
            return error.throw_2(error.Errors.TYPE_ERROR, space.newstring(u"Type or Union Expected"), _type)


class Types:
    def __init__(self, symbols):
        from obin.types.space import newnativedatatype as newtype
        _s = symbols.symbol
        # ---------------AUTOGENERATED---------------------
        self.Bool = newtype(_s(u"Bool"))
        self.Char = newtype(_s(u"Char"))
        self.Int = newtype(_s(u"Int"))
        self.Float = newtype(_s(u"Float"))
        self.Symbol = newtype(_s(u"Symbol"))
        self.String = newtype(_s(u"String"))
        self.List = newtype(_s(u"List"))
        self.Vector = newtype(_s(u"Vector"))
        self.Tuple = newtype(_s(u"Tuple"))
        self.Map = newtype(_s(u"Map"))
        self.Function = newtype(_s(u"Function"))
        self.Partial = newtype(_s(u"Partial"))
        self.Generic = newtype(_s(u"Generic"))
        self.Fiber = newtype(_s(u"Fiber"))
        self.Trait = newtype(_s(u"Trait"))
        self.Interface = newtype(_s(u"Interface"))
        self.Datatype = newtype(_s(u"Datatype"))
        self.Union = newtype(_s(u"Union"))
        self.LazyVal = newtype(_s(u"LazyVal"))
        self.Env = newtype(_s(u"Env"))


class Interfaces:
    def __init__(self, process):
        prelude = process.modules.prelude
        self.Seq = self.find_interface(process, prelude, u"Seq")

    def _find_in(self, process, prelude, name):
        sym = space.newsymbol(process, name)
        if not api.contains(prelude, sym):
            error.throw_1(error.Errors.KEY_ERROR, space.newstring(u"Missing internal trait %s in prelude" % name))
        return api.at(prelude, sym)

    def find_interface(self, process, module, name):
        _interface = self._find_in(process, module, name)
        error.affirm_type(_interface, space.isinterface)
        return _interface


class Std:
    def __init__(self, symbols):
        self.types = Types(symbols)
        self.interfaces = None
        self.derived = None
        self.initialized = False

    def postsetup(self, process):
        self.interfaces = Interfaces(process)
        self.derived = Derived(process)
        self.initialized = True

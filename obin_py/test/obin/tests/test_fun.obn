import affirm

// SYNTAX
fun ++++/ () -> 42 end
fun ++>> x y -> 42 end
fun ++-+ x y -> 42 end
fun ++---^--^ x y
    | x y -> 42 end


// compiler single pass problem example
//    I decided not to optimize it.
//    [fun length(x) -> 1 + length(x - 1) when x > 0 else 0 end]
//    fun Y(y) -> length(y) end
//    Y(3)

fun test () ->
    func_0 = fun func_0_f a b c -> (a, b, c) end
    affirm:is_equal (func_0 1 2 3) (1,2,3)
    //call after declaration
    affirm:is_equal (fun test_tuple tuple
                        | (a,b,c) -> (c, b, a) end (1,2,3)) (3,2,1)

    affirm:is_equal ( ((a,b,c) => (c, b, a)) (1,2,3) ) (3,2,1)

    //////////////////////////////////////////////////////////////////////////

    fun f4 a b c ...rest ->
            [a, b, c, rest] end

    affirm:is_equal (f4 1 2 3 4 5 6)  [1, 2, 3, (4, 5, 6)]
    //////////////////////////////////////////////////////////////////////////

    fun f5 (a1 a2 a3 a4 a5 ...rest)
        | x (y,z) a b {name=name, age=(years, month)} _ ->
            (x, y, z, a, b, name, years, month, rest)

    affirm:is_equal (f5 1 (2,3) 4 5  {name=6, age=(7,8)}  9 10 11 12) (1, 2, 3, 4, 5, 6, 7, 8, (9, 10, 11, 12))

    //////////////////////////////////////////////////////////////////////////

    fun fact n
        | 0 -> 1
        | n -> n * fact (n - 1)

    affirm:is_equal (fact 7) 5040
    affirm:is_equal (fact 0) 1

    fun func1 a1 a2 a3 a4 a5 a6 a7 a8 ...a9
        | 1 2 3 4 5 var0 var1 var2 var4 -> (var0, var1, var2, var4)
        | _ _ _ _ _ _ _ {key1, var1 @ key2, key3=25}  ([var2, #second, var3 @ #third, ...var4],) ->
            (var1, var2, var3, var4)


    affirm:is_equal (func1 1 2 3 4 5 6 7 8 9 10 11) (6, 7, 8, (9, 10, 11))

    (affirm:is_equal (func1 42 42 42 42 42 42 42 {key1=#key1, key2=#key2, key3=25} [#first, #second, #third, 4,5,6,7])
                     (#key2, #first, #third, [4, 5, 6, 7]))


    affirm:is_equal (apply (() => #empty) [()]) #empty

    fun func3 arg
        | 1 -> #first
        | 42 -> #second
        | () -> #third

    (affirm:is_equal_batch func3
                          ([1], #first)
                          ([42], #second)
                          ([()], #third))

    // when possible function compiles
    // into destructive assignment automaton instead of more complicated pattern matching graph
    //destruct func
    fun fn_simple arg1 arg2 ...rest -> (arg1, arg2, rest) end
    //case func
    fun fn_case arg1 arg2 of Int  ...rest -> (arg1, arg2, rest) end

    affirm:is_equal (fn_simple 0 1 4 5 6) (fn_case 0 1 4 5 6)

    ////////////////////////////////////////////////////

    //destruct func
    fun fn_simple1 a1 a2 a3 ...a4
        | arg1 arg2 {key1, key2} rest -> (arg1, arg2, key1, key2, rest) end

    //case func
    fun fn_case1 arg1 arg2 a3 ...rest
        | _  _ { var1 @ key1=2, key2} of Map _ -> (arg1, arg2, var1, key2, rest) end

    //case func 2
    fun fn_case2 arg1 arg2 a3 of Map ...rest ->
        { var1 @ key1=2, key2}  = a3
        (arg1, arg2, var1, key2, rest)
    end

    affirm:is_equal (fn_simple1 0 1 {key1=2, key2=3}  4 5 6) (fn_case1 0 1  {key1=2, key2=3}  4 5 6)
    affirm:is_equal (fn_simple1 0 1 {key1=2, key2=3}  4 5 6) (fn_case2 0 1  {key1=2, key2=3}  4 5 6)

    ////////////////////////////////////////////////////

    //tuple args here
    affirm:is_equal ( ((x,y) => x + y) (2, 3) ) 5

    ////////////////////////////////////////////////////
    fun fn_fail arg
        | 1 -> #one
        | 2 -> #two
        | 3 -> #three
        | 4 -> #four

    (affirm:is_equal_batch  fn_fail
                            ([1], #one)
                            ([2], #two)
                            ([3], #three)
                            ([4], #four))

    affirm:is_throw fn_fail [5]
    affirm:is_throw_expected fn_fail [0] (#FunctionArgumentsMatchError, (0,))
    (affirm:is_equal try
                       fn_fail("I am string")
                     catch exc ->
                       [exc, exc, exc]
                     end
                    [(#FunctionArgumentsMatchError, ("I am string",)),
                     (#FunctionArgumentsMatchError, ("I am string",)),
                     (#FunctionArgumentsMatchError,("I am string",))])

    ////////////////////////////////////////////////
    //Empty args first
    (affirm:is_equal_batch   fun __f1 arg1 arg2
                                | () () -> 42
                                | x y -> x + y
                             end
                             [(1,2), 3]
                             [[(), ()], 42])

    ////////////////////////////////////////////////
    affirm:is_equal (fun f_42 arg | () -> 42 end ()) 42
    affirm:is_equal ( (() => 42) () ) 42
    ////////////////////////////////////////////////
    fun f2 () -> 42 end
    fun add x y -> x + y + (f2 ()) end
    f1 = x y => add x y
    affirm:is_equal (f1 1 2) 45
    ////////////////////////////////////////////////
    f3 = fun f3 x l | _ [a, b] -> x +  a + b end
    f4_1 = (x [a, b] => x + a + b) 
    affirm:is_equal (f3 1 [2, 3]) (f4_1 1 [2, 3])
    affirm:is_equal (f4_1 1 [2, 3]) 6
    (affirm:is_equal ((x [a,b,c,...tl] {N, Z} => (x + a + b + c + N + Z) :: tl)
                          1  [1, 1, 1, 33,33,33] {N=1, Z = 1})
                    [6, 33, 33, 33])
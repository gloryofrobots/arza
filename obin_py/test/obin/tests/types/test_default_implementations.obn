import affirm

type EQ
type GT
type LT

trait Equal for x
    method eq x y -> not (ne x y)
    method ne x y -> not (eq x y)
---

trait Order for x
    method le x y -> (cmp x y) != GT
    method lt x y -> (cmp x y) == LT
    method ge x y -> (cmp x y) != LT
    method gt x y -> (cmp x y) == GT
    method cmp x y ->
        if eq x x -> EQ
        elif le x y -> LT
        else -> GT
        ---

    method max x y ->
        if x `le` y -> y
        else -> y
        ----

    method min x y ->
        if x `le` y -> x
        else -> y
        -------
-----

type Val v
---
derive Dict for Val

type Val2 v
---
derive Dict for Val2

implement Equal for Val
    method eq v1 v2 -> v1.v == v2.v
---

implement Equal for Val2
    method ne v1 v2 -> v1.v != v2.v
---

implement Order for Val
    method cmp self other ->

            if self.v == other.v -> EQ
            elif self.v <= other.v -> LT
            else -> GT
            ---
-------

implement Order for Val2
    method le self other -> self.v <= other.v
-------


fun test () ->
    v1_1 = (Val 1)
    v1_2 = (Val 1)
    v1_3 = Val 2

    v2_1 = Val2 1
    v2_2 = Val2 1
    v2_3 = Val2 2

    affirm:is_true (eq v1_1 v1_2)
    affirm:is_false (ne v1_1 v1_2)
    affirm:is_false (eq v1_3 v1_2)
    affirm:is_false (eq v1_2 v1_3)

    affirm:is_true (eq v2_1 v2_2)
    affirm:is_false (ne v2_1 v2_2)
    affirm:is_false (eq v2_3 v2_2)
    affirm:is_false (eq v2_2 v2_3)

    affirm:is_true (eq v1_1 v2_2)
    affirm:is_false (ne v2_1 v1_2)
    affirm:is_false (eq v1_3 v2_2)
    affirm:is_false (eq v1_2 v2_3)

    affirm:is_false (lt v1_3 v1_3)
    affirm:is_true (le v1_3 v1_3)
    affirm:is_false (gt v1_3 v1_3)
    affirm:is_true (ge v1_3 v1_3)

    affirm:is_false (lt v2_3 v2_3)
    affirm:is_true (le v2_3 v2_3)
    affirm:is_false (gt v2_3 v2_3)
    affirm:is_true (ge v2_3 v2_3)
end

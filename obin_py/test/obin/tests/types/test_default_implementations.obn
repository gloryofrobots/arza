import affirm

type EQ end
type GT end
type LT end

trait Equal for x
    def eq x y -> not (ne x y)
    def ne x y -> not (eq x y)

trait Order for x
    def le x y -> (cmp x y) != GT
    def lt x y -> (cmp x y) == LT
    def ge x y -> (cmp x y) != LT
    def gt x y -> (cmp x y) == GT

    def cmp x y ->
        if eq x x -> EQ
        elif le x y -> LT
        else -> GT

    def max x y ->
        if x `le` y -> y
        else -> y

    def min x y ->
        if x `le` y -> x
        else -> y

type Val v

type Val2 v

implement Equal for Val
    def eq v1 v2 -> v1.v == v2.v

implement Equal for Val2
    def ne v1 v2 -> v1.v != v2.v

implement Order for Val
    def cmp self other ->
        if self.v == other.v -> EQ
        elif self.v <= other.v -> LT
        else -> GT

implement Order for Val2
    def le self other -> self.v <= other.v

fun test () ->
    v1_1 = (Val 1)
    v1_2 = (Val 1)
    v1_3 = Val 2

    v2_1 = Val2 1
    v2_2 = Val2 1
    v2_3 = Val2 2

    affirm:is_true (eq v1_1 v1_2)
    affirm:is_false (ne v1_1 v1_2)
    affirm:is_false (eq v1_3 v1_2)
    affirm:is_false (eq v1_2 v1_3)

    affirm:is_true (eq v2_1 v2_2)
    affirm:is_false (ne v2_1 v2_2)
    affirm:is_false (eq v2_3 v2_2)
    affirm:is_false (eq v2_2 v2_3)

    affirm:is_true (eq v1_1 v2_2)
    affirm:is_false (ne v2_1 v1_2)
    affirm:is_false (eq v1_3 v2_2)
    affirm:is_false (eq v1_2 v2_3)

    affirm:is_false (lt v1_3 v1_3)
    affirm:is_true (le v1_3 v1_3)
    affirm:is_false (gt v1_3 v1_3)
    affirm:is_true (ge v1_3 v1_3)

    affirm:is_false (lt v2_3 v2_3)
    affirm:is_true (le v2_3 v2_3)
    affirm:is_false (gt v2_3 v2_3)
    affirm:is_true (ge v2_3 v2_3)

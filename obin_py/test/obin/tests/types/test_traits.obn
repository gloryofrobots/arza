import affirm

type EQ
type GT
type LT

generic
    eq x y
    ne x y
    le x y
    lt x y
    ge x y
    gt x y
    cmp x y
    max x y
    min x y

trait Equal
    def eq x y -> not (ne x y)
    def ne x y -> not (eq x y)

trait Order
    def le x y -> (cmp x y) != GT
    def lt x y -> (cmp x y) == LT
    def ge x y -> (cmp x y) != LT
    def gt x y -> (cmp x y) == GT

    def cmp x y ->
        if eq x x then EQ
        elif le x y then LT
        else GT

    def max x y ->
        if x `le` y then y
        else  y

    def min x y ->
        if x `le` y then x
        else  y

type Val v

type Val2 v

extend Val with
    trait Equal
    def eq v1 v2 -> v1.v == v2.v

extend Val2 with
    trait Equal
    def ne v1 v2 -> v1.v != v2.v

extend Val with trait
   trait Order

   def cmp self other ->
        if self.v == other.v then EQ
        elif self.v <= other.v then LT
        else GT

extend Val2 with
    trait Order
    def le self other -> self.v <= other.v

fun test () ->
    v1_1 = (Val 1)
    v1_2 = (Val 1)
    v1_3 = Val 2

    v2_1 = Val2 1
    v2_2 = Val2 1
    v2_3 = Val2 2

    affirm:is_true (eq v1_1 v1_2)
    affirm:is_false (ne v1_1 v1_2)
    affirm:is_false (eq v1_3 v1_2)
    affirm:is_false (eq v1_2 v1_3)

    affirm:is_true (eq v2_1 v2_2)
    affirm:is_false (ne v2_1 v2_2)
    affirm:is_false (eq v2_3 v2_2)
    affirm:is_false (eq v2_2 v2_3)

    affirm:is_true (eq v1_1 v2_2)
    affirm:is_false (ne v2_1 v1_2)
    affirm:is_false (eq v1_3 v2_2)
    affirm:is_false (eq v1_2 v2_3)

    affirm:is_false (lt v1_3 v1_3)
    affirm:is_true (le v1_3 v1_3)
    affirm:is_false (gt v1_3 v1_3)
    affirm:is_true (ge v1_3 v1_3)

    affirm:is_false (lt v2_3 v2_3)
    affirm:is_true (le v2_3 v2_3)
    affirm:is_false (gt v2_3 v2_3)
    affirm:is_true (ge v2_3 v2_3)
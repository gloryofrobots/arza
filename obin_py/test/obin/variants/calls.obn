//REDUCERS///////////////////////////////////////////////////////
fun foldl func accumulator coll
    | f acc [] -> acc
    | f acc hd::tl -> foldl f (f hd acc) tl
----------------------------------------

fun foldr func accumulator coll
    | f acc [] -> acc
    | f acc hd::tl -> f hd (foldr f acc tl)
--------------------------------------------------

fun reduce f l
    | f x::xs -> foldl f x xs
    | f [] -> throw EmptySeqError l
--------------------------------------------------

fun scanl func accumulator coll
    | f acc [] -> acc::(empty coll)
    | f acc hd::tl -> acc :: (scanl f (f hd acc) tl)
--------------------------------------------------

//LOOPS ////////////////////////
fun map f coll
    | f [] -> empty coll
    | f hd::tl -> (f hd) :: (map f tl)
----------------------------------------

fun foreach f coll
    | f [] -> empty coll
    | f hd::tl -> f hd; foreach f tl
----------------------------------------

fun intersperse val coll
    | val [] -> empty coll
    | val hd::tl  -> hd :: val :: (intersperse val tl)
--------------------------------------------------

fun reverse coll ->
    fun _reverse l result
        | [] result -> result
        | hd::tl result -> (_reverse tl (hd :: result))
    ---------------

    _reverse coll (empty coll)
----------------------------------------
fun list coll ->
    reverse (foldl cons [] coll)

///ACCESSORS//////////////////////////////////////

fun nth_tail (count of Int) coll
    | 0 l -> l
    | 1 [_, ...t] -> t
    | n [_, ...t] when n >= 0 -> nth_tail (n - 1) t
--------------------------------------------------

fun nth (count of Int) coll
    | 0 l -> l
    | 1 [h, ...t] -> h
    | n [h, ...t] when n >= 0 -> nth (n - 1) t
--------------------------------------------------

//QUERIES///////////////////////////////////////////////////

fun length l of List ->
    foldl lam _ acc -> acc + 1 end 0 l
--------------------------------------------------

fun last coll
    | [x, ...xs] ->
        fun _last hd tl
            | _ [x, ...xs] -> _last x xs
            | x [] -> x
        ------------

        _last x xs
--------------------------------------------------


fun prefix_of coll1 coll2
    | [hd, ...pre_tail] [hd, ...tail] -> prefix_of pre_tail tail
    | [] s -> True
    | [_, ..._] s -> False
--------------------------------------------------

fun suffix_of suf s  ->
   delta = (len s) - (len suf)
   tl = nth_tail delta s
   delta >= 0 and tl == suf
--------------------------------------------------

//SUBLISTS/////////////////////////////////////////////////////////////
fun drop count coll
    | 0 l -> l
    | count hd::tl -> drop (count - 1) tl
--------------------------------------------------

fun take count coll
    | 0 _ -> empty coll
    | _ [] -> empty coll
    | n [x, ...xs] -> x :: (take (n-1)  xs)
--------------------------------------------------

fun split_at (n of Int) l -> ((take n l), (drop n l)) end

fun take_while predicate coll
    | p [] -> empty coll
    | p [x, ...xs] -> x :: (take_while p xs) in_case p x else empty coll
--------------------------------------------------

fun drop_while predicate coll
    | p [] -> empty coll
    | p xs@[x, ...xs1] -> (drop_while p xs1) in_case p x else xs
--------------------------------------------------

fun filter predicate coll
    | p [] -> empty coll
    | p x::xs ->
        if p x ->
            x :: filter p xs
        else ->
            filter p xs
--------------------------------------------------

fun span predicate coll
    | p [] ->
        c = empty coll
        (c, c)
    | p xs@[x, ...xs1] ->
        if not (p x) then
            (empty coll, xs)
        else
            (ys, zs) = (span p xs1)
            (x::ys, zs)

fun span(predicate, coll)
    case(p, []) ->
        c = empty(coll)
        (c, c)

    case(p, xs@[x, ...xs1]) ->
        if not p(x) then
            (empty(coll), xs)
        else
            (ys, zs) = span(p, xs1)
            (x::ys, zs)

fun delete item coll
    | item [item, ...xs] -> xs
    | item [x, ...xs] -> x :: (delete item xs)
    | _ [] -> empty coll
--------------------------------------------------

fun insert index v coll
    | 0 v coll -> v::coll
    | i v [] -> throw IndexError ("Invalid insertion index", index, v)
    | i v x::xs -> x :: (insert (i - 1) v xs)

fun insert(index, v, coll)
    case(0, v, coll) -> v::coll
    case(i, v, []) -> throw IndexError ("Invalid insertion index", index, v)
    case(i, v, x::xs) -> x :: insert(i - 1, v, xs)

fun append v coll ->
    insert (length coll) v coll

////QUERIES//////////////////////////////////////////////////////////////////

fun conjunction l ->
    foldr lam v acc -> v and acc end True l end

fun conjunction(l) ->
    foldr(fun (v, acc) ->
                 v and acc
          end, True, l)

fun disjunction l ->
    foldr lam v acc -> v or acc end False l end

fun any p l ->
    disjunction (map p l) end

fun all p l ->
    conjunction (map p l) end

fun element x l ->
    any lam v -> v == x end l end

fun contains l x ->
    element x l end

fun equal s1 s2
    | x::xs x::ys -> equal xs ys
    | [] [] -> True
    | _ _ -> False
//BUILDERS/////////////////////////////////////////////////////////////

fun concat l1 l2 ->
    foldr `::` l2 l1 end

fun uncons coll | [x, ...xs] -> (x, xs) end

fun init coll
    | [x] -> empty coll
    | [x, ...xs] -> x :: (init xs)
    | [] -> throw (ValueError "empty seq in init")
------------------------------

fun zip seq1 seq2
    | x::xs y::ys -> (x, y) :: zip xs ys
    | _ _ -> []
--------------------------------------------------

fun unzip l ->
    fun _unzip l seq1 seq2
        | (x, y) :: ts xs ys -> _unzip ts (x :: xs) (y :: ys)
        | [] xs ys -> (reverse xs, reverse ys)
    _unzip l [] []
--------------------------------------------------

fun zip3 s1 s2 s3
    | x::xs y::ys z::zs -> (x, y, z) :: zip3 xs ys zs
    | _ _ _ -> []
--------------------------------------------------

fun unzip3 l ->
    fun _unzip3 l acc_x acc_y acc_z
        | [(x, y, z), ...ts] xs ys zs -> _unzip3 ts (x::xs) (y::ys) (z::zs)
        | [] xs ys zs -> (reverse xs, reverse ys, reverse zs)
    _unzip3 l [] [] []

fun zipwith f seq1 seq2
    | f x::xs y::ys -> (f x y) :: zipwith f xs ys
    | _ _ _ -> []

fun zipwith3 f seq1 seq2 seq3
    | f x::xs y::ys z::zs -> (f x y z) :: zipwith3 f xs ys zs
    | _ _ _ _ -> []

fun split s
    | [] -> ([], [])
    | [x] -> (s, [])
    | x::y::xs ->
        (l, r) = split xs
        (x::l, y::r)

fun split(s)
    case([]) -> ([], [])
    case([x]) -> (s, [])
    case(x::y::xs) ->
        (l, r) = split xs
        (x::l, y::r)


fun zipwith3(f, seq1, seq2, seq3)
    case(f, x::xs, y::ys, z::zs) -> f(x, y, z) :: zipwith3(f, xs, ys, zs)
    case (_, _, _, _) -> []

fun zipwith3 f seq1 seq2 seq3
    | f x::xs y::ys z::zs -> (f x y z) :: zipwith3 f xs ys zs
    | _ _ _ _ -> []

fun sort(f, s) ->
    fun _merge(s1, s2)
        case([], ys) -> ys
        case(xs, []) -> xs
        case(x::xs, y::ys) ->
            if f(x, y) then x :: _merge(xs, y::ys)
            else y :: _merge(x::xs, ys)

    fun _sort(s)
        case([]) -> []
        case([x]) -> s
        case(xs) ->
            (ys, zs) = split(xs)
            _merge(_sort(ys), _sort(zs))

    _sort(s)

fun sort f s ->
    fun _merge s1 s2
        | [] ys -> ys
        | xs [] -> xs
        | x::xs y::ys ->
            if f x y then x :: _merge xs (y::ys)
            else y :: _merge (x::xs) ys

    fun _sort s
        | [] -> []
        | [x] -> s
        | xs ->
            (ys, zs) = split xs
            _merge (_sort ys) (_sort zs)
    ---------

    _sort s

fun sort_asc s -> sort(`<=`, s)
fun sort_desc s -> sort(`>=`, s)

fun test_pipe() ->
    l = list:range(0, 10)

    affirm:is_equal(
        l.filter(even)
     ) [0, 2, 4, 6, 8]

    affirm:is_equal (
        l |> &(seq:filter, even)
          |> &(seq:map, `+`, 1)
     ) [1, 3, 5, 7, 9]


    affirm:is_equal.(
        (l |> seq:filter even
           |> seq:map `+` 1),
        [1, 3, 5, 7, 9])

    print.(1,3,2-3*5,6)

    affirm:is_equal(
        l.filter(even)
         .map(_ + 1)
     ) [1, 3, 5, 7, 9]

    affirm:is_equal (
        l |> &(seq:filter, even)
          |> &(seq:map, `+`, 1)
          |> &(seq:map, flip, `-`, 2)
     ) [-1, 1, 3, 5, 7]

    square = lam x -> x * x
    triple = `*` 3

-----------------------------------
    affirm:is_equal (
        l |> seq:filter even
          |> seq:map (`+` 1)
          |> seq:map (flip `-` 2)
          |> seq:map (triple >> square)
     )  [9, 9, 81, 225, 441]

    affirm:is_equal(
        l |> seq:filter(even)
          |> seq:map(`+`(_, 1))
          |> seq:map(flip(`-`, 2))
          |> seq:map(triple >> square),
        [9, 9, 81, 225, 441])

-----------------------------------

    affirm:is_equal (
         (seq:filter even
          >> seq:map (`+` 1)
          >> seq:map (flip `-` 2)
          >> seq:map (triple >> square)) l
     )  [9, 9, 81, 225, 441]

    affirm:is_equal (
        l |> seq:filter even
          >> seq:map (`+` 1)
          >> seq:map (flip `-` 2)
          >> seq:map (triple >> square)
     )  [9, 9, 81, 225, 441]

type TypeDerived
extend TypeDerived
    with Eq
        def ==.(self, other) -> _api:equal.(other, self)
    with Str
        def str.(self) -> _api:to_string.(self)
    with Repr
        def repr.(self) -> _api:to_repr.(self)
    with Collection
        def put.(key, value, self) -> _api:put.(key, value, self)
        def at.(key, self) -> _api:at.(key, self)
        def del.(key, self) -> _api:del.(key, self)
        def elem.(key, self) -> _api:elem.(key, self)
    with Sized
        def len.(self) -> _api:length.(self)
        def is_empty.(self) -> _api:is_empty.(self)
    with Indexed
        def index_of.(self) -> _datatype:record_index_of.(self)
    with Dict
        def keys.(self) -> _datatype:record_keys.(self)
        def values.(self) -> _datatype:record_values.(self)

type TypeDerived
extend TypeDerived
    with Eq
        def == (self, other) -> _api:equal(other, self)
    with Str
        def str(self) -> _api:to_string(self)
    with Repr
        def repr(self) -> _api:to_repr(self)
    with Collection
        def put(key, value, self) -> _api:put(key, value, self)
        def at(key, self) -> _api:at(key, self)
        def del(key, self) -> _api:del(key, self)
        def elem(key, self) -> _api:elem(key, self)
    with Sized
        def len(self) -> _api:length(self)
        def is_empty(self) -> _api:is_empty(self)
    with Indexed
        def index_of(self) -> _datatype:record_index_of(self)
    with Dict
        def keys(self) -> _datatype:record_keys(self)
        def values(self) -> _datatype:record_values(self)

type TypeDerived
extend TypeDerived
    with Eq
        def == self other -> _api:equal other self
    with Str
        def str self -> _api:to_string self
    with Repr
        def repr self -> _api:to_repr self
    with Collection
        def put key value self -> _api:put key value self
        def at key self -> _api:at key self
        def del key self -> _api:del key self
        def elem key self -> _api:elem key self
    with Sized
        def len self -> _api:length self
        def is_empty self -> _api:is_empty self
    with Indexed
        def index_of self -> _datatype:record_index_of self
    with Dict
        def keys self -> _datatype:record_keys self
        def values self -> _datatype:record_values self


type UnionDerived
extend UnionDerived
    with Range
        def range _from  _to  ->
            union = _datatype:get_union _from
            if not (kindof _to union) then
                throw ValueError("Invalid type for second argument", _to)
            else
                s1 = seq:drop_while (`!=` _from) (to_seq union)
                seq:take_while (`!=` _to) s1
        def range_from _from ->
            union = _datatype:get_union _from
            s1 = seq:drop_while (`!=` _from) (to_seq union)
        def range_from_by _from _by ->
            throw NotImplementedError ("Only range from Rangeable is supported")
        def range_by _from _to _by ->
            throw NotImplementedError ("Only range from Rangeable is supported")

type UnionDerived
extend UnionDerived
    with Range
        def range _from  _to  ->
            union = _datatype:get_union _from
            if not (kindof _to union) then
                throw ValueError("Invalid type for second argument", _to)
            else
                s1 = seq:drop_while (`!=` _from) (to_seq union)
                seq:take_while (`!=` _to) s1
        def range_from _from ->
            union = _datatype:get_union _from
            s1 = seq:drop_while (`!=` _from) (to_seq union)
        def range_from_by _from _by ->
            throw NotImplementedError ("Only range from Rangeable is supported")
        def range_by _from _to _by ->
            throw NotImplementedError ("Only range from Rangeable is supported")

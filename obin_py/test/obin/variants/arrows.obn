fun is_throw fn args
    | fn () -> is_throw fn [()]
    | fn args ->
        match
            try
                apply fn args
                Success True
            catch e ->
                print e
                e
            -----------
        | _ of Success ->
            print Success;
            fail ["exception expected", fn]
        | err ->
            print err;
            err
        ---------

    | fn of Callable list of List -> list
------------------------

fun range_by  first of Int . last of Int . step of Int ->
    fun _range_by N X D L
        | N X D L when N >= 4 ->
            Y = X - D
            Z = Y - D
            W = Z - D
            _range_by (N - 4)  (W - D)  D  (W :: Z :: Y :: X :: L)

        | N X D L when N >= 2 ->
            Y = X - D
            _range_by (N - 2) (Y - D) D (Y :: X :: L)

        | 1 X _ L -> X :: L

        | 0 _ _ L -> L
    --------------------------------------------------

    cond
    | step > 0 and first - step <= last or
      step < 0 and first - step >= last ->
        n = ((last - first + step) / step) - 1
        _range_by n (step * (n - 1) + first) step []

    | step == 0 and first == last ->
        _range_by 1  first step []
    | else ->
        throw (#InvalidRange, first, last, step)
    ------------------------------
--------------------------------------------------

fun range_by  first of Int . last of Int . step of Int ->
    fun _range_by N X D L
        | N X D L when N >= 4 ->
            Y = X - D
            Z = Y - D
            W = Z - D
            _range_by (N - 4)  (W - D)  D  (W :: Z :: Y :: X :: L)

        | N X D L when N >= 2 ->
            Y = X - D
            _range_by (N - 2) (Y - D) D (Y :: X :: L)

        | 1 X _ L -> X :: L

        | 0 _ _ L -> L
    --------------------------------------------------

    if step > 0 and first - step <= last or
                            step < 0 and first - step >= last ->
        n = ((last - first + step) / step) - 1
        _range_by n (step * (n - 1) + first) step []

    elif step == 0 and first == last ->
        _range_by 1  first step []
    else ->
        throw (#InvalidRange, first, last, step)
    ----------------------
--------------------------------------------------



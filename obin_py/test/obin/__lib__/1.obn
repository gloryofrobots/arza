from obin:lang:_types import (Bool, Char, Int,
                              Float, Symbol, String, List, Vector,
                              Tuple, Map, Function, Method, Fiber, Trait,
                              Datatype, Union, LazyVal, Env)
"""
Precedence    Operator
    100           : . .{ .( .[
    95           (
    60           :: :::
    50           *  /
    40           +  - ++
    35           ==  !=  <  <=  >  >=
    30           and
    25           or << >>
    20           |>
    15           " ." @ as of <|
    10           = :=
"""

prefix - negate
prefix ! !
prefix & &
infixr := := 10
infixl <| <| 15
infixl |> |> 20
infixl << << 25
infixl >> >> 25
infixl < < 35
infixl > > 35
infixl >= >= 35
infixl <= <= 35
infixl == == 35
infixl != != 35
infixl ++ ++ 40
infixl + + 40
infixl - - 40
infixl * * 50
infixl / / 50

type Ordering
    | LT | GT | EQ

generic
    == x y
    != x y
    <= x y
    < x y
    >= x y
    > x y

    cmp first second

    max first second
    min first second

    - x y
    + x y
    * x y
    / x y
    mod x y
    // unary -
    negate x

    str self
    repr self

    len self
    is_empty self

    put key value self
    at key self
    del obj self
    elem key self

    first self
    rest self

    empty self
    cons value self
    prepend value self
    ++ self other
    append value self
    keys self
    values self
    index_of obj self
    to_seq self

    slice first last self
    drop count self
    take count self
    lower_bound self
    upper_bound self

    range self last
    range_by self last step
    range_from self
    range_from_by self step
    ! self
    := self value

interface
    PartialEq (==)
    Eq (!=, ==)
    Ord(<, <=, >, >=, cmp, max, min)
    Num (-, +, *, /, mod, negate)
    Str (str)
    Displayed (str, repr)
    Sized (len, is_empty)
    Collection(put, at, del, elem)
    ReadOnlyCollection(at, elem)
    Seq(first, rest)
    Emtiable(empty)
    Consable(cons)
    Prependable(prepend)
    Appendable(append)
    Concatable(++)
    Dict(keys, values, put, at, del, elem)
    Indexed(index_of)
    Seqable(to_seq)
    Sliceable(slice, drop, take)
    Bounded(lower_bound, upper_bound)
    Ranged(range, range_by, range_from, range_from_by)
    Ref(!)
    MutRef(!, :=)


type Option
    | Some val
    | None


type ImportError args
type RuntimeError args
type TypeError args
type NotImplementedError args
type ZeroDivisionError args
type ReferenceError args
type ConstructorError args
type KeyError args
type ValueError args
type SliceError args
type IndexError args
type InvokeError args
type InvalidArgCount args
type MethodInvokeError args
type MethodNotImplementedError args
type MethodSpecializeError args
type CompileError args
type ParseError args
type UnpackSequenceError args
type FiberFlowError args
type MatchError args
type FunctionArgumentsMatchError args
type ExceptionMatchError args
type ExportError args
type TraitAlreadyImplementedError args
type TraitImplementationError args
type TraitConstraintError args
type EmptySeqError args
//Signal used to interrupt recursive processes
type Interrupt result

trait TNotEq
    def != x y -> not (x == y)

trait TOrd of PartialEq
    def < x y -> cmp x y == LT
    def >= x y -> cmp x y != LT
    def > x y -> cmp x y == GT

    def cmp x y ->
                if x == y then EQ
                elif x <= y then LT
                else GT

    def max x y -> if x <= y then y else x
    def min x y -> if x <= y then x else y

trait TIsEmpty
    def is_empty self -> (len self) == 0

trait TRepr of Str
    def repr self -> str self
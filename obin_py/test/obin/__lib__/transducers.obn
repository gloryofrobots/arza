
trait Transformer for self
    def init self
    def result self res
    def step self res input

type Wrap fn

implement Transformer for Wrap
    def init self -> throw NotImplementedError #init
    def result self acc -> acc
    def step self input acc -> self.fn input acc

fun wrap f
    | f of Transformer -> f
    | f -> Wrap f

type Reduced value

fun reduced x -> Reduced x
fun is_reduced val
    | val of Reduced -> True
    | _ -> False

fun ensure_reduced x
    | val of Reduced -> val
    | val -> Reduced val

fun deref r of Reduced -> r.value

fun unreduced x
    | r of Reduced -> deref r
    | r -> r

fun reduce xf acc coll ->
    fun _reduce xf acc coll
        | xf acc [] ->
            acc
        | xf acc hd::tl ->
            acc1 = step xf hd acc
            if is_reduced acc1 ->
                deref acc1
            else ->
                _reduce xf acc1 tl
    res = _reduce xf acc coll
    result xf res



///**
// * Given a transducer, a builder function, an initial value
// * and a iterable collection - returns the reduction.
// * collection - returns the reduction.
// * @method transducers.transduce
// * @param {com.cognitect.transducers.ITransformer} xf a transducer
// * @param {com.cognitect.transducers.ITransformer|Function} f a transducer or two-arity function
// * @param {Object=} init any JavaScript value
// * @param {String|Array|Object} coll any iterable JavaScript value
// * @return {Object} a JavaScript value.
// * @example
// *     var t = transducers;
// *     var inc = function(n) { return n+1; };
// *     var isEven = function(n) { return n % 2 == 0; };
// *     var apush = function(arr,x) { arr.push(x); return arr; };
// *     var xf = t.comp(t.map(inc),t.filter(isEven));
// *     t.transduce(xf, apush, [], [1,2,3,4]); // [2,4]
// */

fun transduce xf f init_val coll ->
    fn = wrap f
    xf1 = xf fn
    reduce xf1 init_val coll

///**
// * Convert a transducer transformer object into a function so
// * that it can be used with existing reduce implementation i.e. native,
// * Underscore, lodash
// * @method transducers.toFn
// * @param {com.cognitect.transducers.ITransformer} xf a transducer
// * @param {Function} builder a function which take the accumulator and the
// *   the next input and return a new accumulator value.
// * @return {Function} a two-arity function compatible with existing reduce
// *   implementations
// * @example
// *     var t = transducers;
// *     var arr = [0,1,2,3,4,5],
// *     var apush = function(arr, x) { arr.push(x); return arr; },
// *     var xf = t.comp(t.map(inc),t.filter(isEven));
// *     arr.reduce(t.toFn(xf, apush), []); // [2,4,6]
// */
fun to_fun xf builder
   | xf builder of Function -> to_fun xf (wrap builder)
   | xf builder of Transformer ->
      rxf = xf(builder)
      lam val acc -> step rxf val acc

fun first () ->
    wrap lam val acc -> reduced val end

type MapTransformer f xf

implement Transformer for MapTransformer
    def init self -> init self.xf
    def result self acc -> result self.xf acc
    def step self val acc ->
//        print "MAP STEP"
        step self.xf (self.f val) acc

///**
// * Mapping transducer constructor
// * @method transducers.map
// * @param {Function} f the mapping operation
// * @return {com.cognitect.transducers.Map} returns a mapping transducer
// * @example
// *     var t = transducers;
// *     var inc = function(n) { return n+1; };
// *     var xf = t.map(inc);
// *     t.into([], xf, [1,2,3]); // [2,3,4]
// */
fun map f xf -> MapTransformer f xf

-------------------------------------------

type FilterTransformer predicate xf

implement Transformer for FilterTransformer
    def init self -> init self.xf
    def result self acc -> result self.xf acc
    def step self val acc ->
//        print "FILTER STEP"
        if self.predicate val ->
            step self.xf val acc
        else ->
            acc

derive Dict for (MapTransformer, FilterTransformer, Wrap)

///**
// * Filtering transducer constructor
// * @method transducers.filter
// * @param {Function} pred a predicate function
// * @return {com.cognitect.transducers.Filter} returns a filtering transducer
// * @example
// *     var t = transducers;
// *     var isEven = function(n) { return n % 2 == 0; };
// *     var xf = t.filter(isEven);
// *     t.into([], xf, [0,1,2,3,4]); // [0,2,4];
// */
fun filter predicate xf -> FilterTransformer predicate xf

///**
// * Similar to filter except the predicate is used to
// * eliminate values.
// * @method transducers.remove
// * @param {Function} pred a predicate function
// * @return {com.cognitect.transducers.Filter} returns a removing transducer
// * @example
// *     var t = transducers;
// *     var isEven = function(n) { return n % 2 == 0; };
// *     var xf = t.remove(isEven);
// *     t.into([], xf, [0,1,2,3,4]); // [1,3];
// */
//transducers.remove = function(pred) {
//    if(TRANSDUCERS_DEV && (typeof pred != "function")) {
//        throw new Error("remove must be given a function");
//    } else {
//        return transducers.filter(transducers.complement(pred));
//    }
//};
//
///**
// * @constructor
// * @implements {com.cognitect.transducers.ITransformer}
// */
//transducers.Completing = function(cf, xf) {
//    this.cf = cf;
//    this.xf = xf;
//};
//transducers.Completing.prototype["@@transducer/init"] = function() {
//    return this.xf["@@transducer/init"]();
//};
//transducers.Completing.prototype["@@transducer/result"] = function(result) {
//    return this.cf(result);
//};
//transducers.Completing.prototype["@@transducer/step"] = function(result, step) {
//    return this.xf["@@transducer/step"](result, step);
//};
//
///**
// * A completing transducer constructor. Useful to provide cleanup
// * logic at the end of a reduction/transduction.
// * @method transducers.completing
// * @param {com.cognitect.transducers.ITransformer} xf a transducer
// * @param {Function} cf a function to apply at the end of the reduction/transduction
// * @return {com.cognitect.transducers.ITransformer} a transducer
// */
//transducers.completing = function(xf, cf) {
//    xf = typeof xf == "function" ? transducers.wrap(xf) : xf;
//    cf = cf || transducers.identity;
//    if(TRANSDUCERS_DEV && (xf != null) && !transducers.isObject(xf)) {
//        throw new Error("completing must be given a transducer as first argument");
//    } else {
//        return new transducers.Completing(cf, xf);
//    }
//};
//
///**
// * @constructor
// * @implements {com.cognitect.transducers.ITransformer}
// */
//transducers.Take = function(n, xf) {
//    this.n = n;
//    this.xf = xf;
//};
//transducers.Take.prototype["@@transducer/init"] = function() {
//    return this.xf["@@transducer/init"]();
//};
//transducers.Take.prototype["@@transducer/result"] = function(result) {
//    return this.xf["@@transducer/result"](result);
//};
//transducers.Take.prototype["@@transducer/step"] = function(result, input) {
//    if(this.n > 0) {
//        result = this.xf["@@transducer/step"](result, input);
//    } else {
//        result = transducers.ensureReduced(result);
//    }
//    this.n--;
//    return result;
//};
//
///**
// * A take transducer constructor. Will take n values before
// * returning a reduced result.
// * @method transducers.take
// * @param {Number} n the number of inputs to receive.
// * @return {com.cognitect.transducers.Take} a take transducer
// * @example
// *     var t = transducers;
// *     var xf = t.take(3);
// *     t.into([], xf, [0,1,2,3,4,5]); // [0,1,2];
// */
//transducers.take = function(n) {
//    if(TRANSDUCERS_DEV && (typeof n != "number")) {
//        throw new Error("take must be given an integer");
//    } else {
//        return function(xf) {
//            return new transducers.Take(n, xf);
//        };
//    }
//};
//
///**
// * @constructor
// * @implements {com.cognitect.transducers.ITransformer}
// */
//transducers.TakeWhile = function(pred, xf) {
//    this.pred = pred;
//    this.xf = xf;
//};
//transducers.TakeWhile.prototype["@@transducer/init"] = function() {
//    return this.xf["@@transducer/init"]();
//};
//transducers.TakeWhile.prototype["@@transducer/result"] = function(result) {
//    return this.xf["@@transducer/result"](result);
//};
//transducers.TakeWhile.prototype["@@transducer/step"] = function(result, input) {
//    if(this.pred(input)) {
//        return this.xf["@@transducer/step"](result, input);
//    } else {
//        return transducers.reduced(result);
//    }
//};
//
///**
// * Like the take transducer except takes as long as the pred
// * return true for inputs.
// * @method transducers.takeWhile
// * @param {Function} pred a predicate function
// * @return {com.cognitect.transducers.TakeWhile} a takeWhile transducer
// * @example
// *     var t = transducers;
// *     var xf = t.takeWhile(function(n) { return n < 3; });
// *     t.into([], xf, [0,1,2,3,4,5]); // [0,1,2];
// */
//transducers.takeWhile = function(pred) {
//    if(TRANSDUCERS_DEV && (typeof pred != "function")) {
//        throw new Error("takeWhile must given a function");
//    } else {
//        return function(xf) {
//            return new transducers.TakeWhile(pred, xf);
//        };
//    }
//};
//
///**
// * @constructor
// * @implements {com.cognitect.transducers.ITransformer}
// */
//transducers.TakeNth = function(n, xf) {
//    this.i = -1;
//    this.n = n;
//    this.xf = xf;
//};
//transducers.TakeNth.prototype["@@transducer/init"] = function() {
//    return this.xf["@@transducer/init"]();
//};
//transducers.TakeNth.prototype["@@transducer/result"] = function(result) {
//    return this.xf["@@transducer/result"](result);
//};
//transducers.TakeNth.prototype["@@transducer/step"] = function(result, input) {
//    this.i++;
//    if((this.i % this.n) == 0) {
//        return this.xf["@@transducer/step"](result, input);
//    } else {
//        return result;
//    }
//};
//
///**
// * A transducer that takes every Nth input
// * @method transducers.takeNth
// * @param {Number} n an integer
// * @return {com.cognitect.transducers.TakeNth} a takeNth transducer
// * @example
// *     var t = transducers;
// *     var xf = t.takeNth(3);
// *     t.into([], xf, [0,1,2,3,4,5]); // [2,5];
// */
//transducers.takeNth = function(n) {
//    if(TRANSDUCERS_DEV && (typeof n != "number")) {
//        throw new Error("takeNth must be given a number");
//    } else {
//        return function(xf) {
//            return new transducers.TakeNth(n, xf);
//        };
//    }
//};
//
///**
// * @constructor
// * @implements {com.cognitect.transducers.ITransformer}
// */
//transducers.Drop = function(n, xf) {
//    this.n = n;
//    this.xf = xf;
//};
//transducers.Drop.prototype["@@transducer/init"] = function() {
//    return this.xf["@@transducer/init"]();
//};
//transducers.Drop.prototype["@@transducer/result"] = function(result) {
//    return this.xf["@@transducer/result"](result);
//};
//transducers.Drop.prototype["@@transducer/step"] = function(result, input) {
//    if(this.n > 0) {
//        this.n--;
//        return result;
//    } else {
//        return this.xf["@@transducer/step"](result, input);
//    }
//};
//
///**
// * A dropping transducer constructor
// * @method transducers.drop
// * @param {Number} n an integer, the number of inputs to drop.
// * @return {com.cognitect.transducers.Drop} a dropping transducer
// * @example
// *     var t = transducers;
// *     var xf = t.drop(3);
// *     t.into([], xf, [0,1,2,3,4,5]); // [3,4,5];
// */
//transducers.drop = function(n) {
//    if(TRANSDUCERS_DEV && (typeof n !== "number")) {
//        throw new Error("drop must be given an integer");
//    } else {
//        return function(xf) {
//            return new transducers.Drop(n, xf);
//        };
//    }
//};
//
///**
// * @constructor
// * @implements {com.cognitect.transducers.ITransformer}
// */
//transducers.DropWhile = function(pred, xf) {
//    this.drop = true;
//    this.pred = pred;
//    this.xf = xf;
//};
//transducers.DropWhile.prototype["@@transducer/init"] = function() {
//    return this.xf["@@transducer/init"]();
//};
//transducers.DropWhile.prototype["@@transducer/result"] = function(result) {
//    return this.xf["@@transducer/result"](result);
//};
//transducers.DropWhile.prototype["@@transducer/step"] = function(result, input) {
//    if(this.drop && this.pred(input)) {
//        return result;
//    } else {
//        if(this.drop) this.drop = false;
//        return this.xf["@@transducer/step"](result, input);
//    }
//};
//
///**
// * A dropping transducer that drop inputs as long as
// * pred is true.
// * @method transducers.dropWhile
// * @param {Function} pred a predicate function
// * @return {com.cognitect.transducers.DropWhile} a dropWhile transducer
// * @example
// *     var t = transducers;
// *     var xf = t.dropWhile(function(n) { return n < 3; });
// *     t.into([], xf, [0,1,2,3,4,5]); // [3,4,5];
// */
//transducers.dropWhile = function(pred) {
//    if(TRANSDUCERS_DEV && (typeof pred != "function")) {
//        throw new Error("dropWhile must be given a function");
//    } else {
//        return function(xf) {
//            return new transducers.DropWhile(pred, xf);
//        };
//    }
//};
//
//transducers.NONE = {};
//
///**
// * @constructor
// * @implements {com.cognitect.transducers.ITransformer}
// */
//transducers.PartitionBy = function(f, xf) {
//    this.f = f;
//    this.xf = xf;
//    this.a = [];
//    this.pval = transducers.NONE;
//};
//transducers.PartitionBy.prototype["@@transducer/init"] = function() {
//    return this.xf["@@transducer/init"]()
//};
//transducers.PartitionBy.prototype["@@transducer/result"] = function(result) {
//    if(this.a.length > 0) {
//        result = transducers.unreduced(this.xf["@@transducer/step"](result, this.a));
//        this.a = [];
//    }
//    return this.xf["@@transducer/result"](result);
//};
//transducers.PartitionBy.prototype["@@transducer/step"] = function(result, input) {
//    var pval = this.pval,
//        val  = this.f(input);
//
//    this.pval = val;
//
//    // NOTE: we should probably allow someone to define
//    // equality? - David
//    if((pval == transducers.NONE) ||
//        (pval == val)) {
//        this.a.push(input);
//        return result;
//    } else {
//        var ret = this.xf["@@transducer/step"](result, this.a);
//        this.a = [];
//        if(!transducers.isReduced(ret)) {
//            this.a.push(input);
//        }
//        return ret;
//    }
//};
//
///**
// * A partitioning transducer. Collects inputs into
// * arrays as long as predicate remains true for contiguous
// * inputs.
// * @method transducers.partitionBy
// * @param {Function} f a partition function. When the result
// *   for an input changes from the previous result will create
// *   a partition.
// * @return {com.cognitect.transducers.PartitionBy} a partitionBy transducer
// * @example
// *     var t = transducers;
// *     var xf = t.partitionBy(function(x) { return typeof x == "string"; });
// *     t.into([], xf, [0,1,"foo","bar",2,3,"bar","baz"]); // [[0,1],["foo","bar"],[2,3],["bar","baz"]];
// */
//transducers.partitionBy = function(f) {
//    if(TRANSDUCERS_DEV && (typeof f != "function")) {
//        throw new Error("partitionBy must be given an function");
//    } else {
//        return function(xf) {
//            return new transducers.PartitionBy(f, xf);
//        };
//    }
//};
//
///**
// * @constructor
// * @implements {com.cognitect.transducers.ITransformer}
// */
//transducers.PartitionAll = function(n, xf) {
//    this.n = n;
//    this.xf = xf;
//    this.a = [];
//};
//transducers.PartitionAll.prototype["@@transducer/init"] = function() {
//    return this.xf["@@transducer/init"]();
//};
//transducers.PartitionAll.prototype["@@transducer/result"] = function(result) {
//    if(this.a.length > 0) {
//        result = transducers.unreduced(this.xf["@@transducer/step"](result, this.a));
//        this.a = [];
//    }
//    return this.xf["@@transducer/result"](result);
//};
//transducers.PartitionAll.prototype["@@transducer/step"] = function(result, input) {
//    this.a.push(input);
//    if(this.n == this.a.length) {
//        var a = this.a;
//        this.a = [];
//        return this.xf["@@transducer/step"](result, a);
//    } else {
//        return result;
//    }
//};
//
///**
// * A partitioning transducer. Collects inputs into
// * arrays of size N.
// * @method transducers.partitionAll
// * @param {Number} n an integer
// * @return {com.cognitect.transducers.PartitionAll} a partitionAll transducer
// * @example
// *     var t = transducers;
// *     var xf = t.partitionAll(3);
// *     t.into([], xf, [0,1,2,3,4,5]); // [[0,1,2],[3,4,5]]
// */
//transducers.partitionAll = function(n) {
//    if(TRANSDUCERS_DEV && (typeof n != "number")) {
//        throw new Error("partitionAll must be given a number");
//    } else {
//        return function(xf) {
//            return new transducers.PartitionAll(n, xf);
//        };
//    }
//};
//
///**
// * @constructor
// * @implements {com.cognitect.transducers.ITransformer}
// */
//transducers.Keep = function(f, xf) {
//    this.f = f;
//    this.xf = xf;
//};
//transducers.Keep.prototype["@@transducer/init"] = function() {
//    return this.xf["@@transducer/init"]();
//};
//transducers.Keep.prototype["@@transducer/result"] = function(result) {
//    return this.xf["@@transducer/result"](result);
//};
//transducers.Keep.prototype["@@transducer/step"] = function(result, input) {
//    var v = this.f(input);
//    if(v == null) {
//        return result;
//    } else {
//        return this.xf["@@transducer/step"](result, input);
//    }
//};
//
///**
// * A keeping transducer. Keep inputs as long as the provided
// * function does not return null or undefined.
// * @method transducers.keep
// * @param {Function} f a function
// * @return {com.cognitect.transducers.Keep} a keep transducer
// * @example
// *     var t = transducers;
// *     var xf = t.keep(function(x) { if(typeof x == "string") return "cool"; });
// *     t.into([], xf, [0,1,"foo",3,4,"bar"]); // ["foo","bar"]
// */
//transducers.keep = function(f) {
//    if(TRANSDUCERS_DEV && (typeof f != "function")) {
//        throw new Error("keep must be given a function");
//    } else {
//        return function(xf) {
//            return new transducers.Keep(f, xf);
//        };
//    }
//};
//
///**
// * @constructor
// * @implements {com.cognitect.transducers.ITransformer}
// */
//transducers.KeepIndexed = function(f, xf) {
//    this.i = -1;
//    this.f = f;
//    this.xf = xf;
//};
//transducers.KeepIndexed.prototype["@@transducer/init"] = function() {
//    return this.xf["@@transducer/init"]();
//};
//transducers.KeepIndexed.prototype["@@transducer/result"] = function(result) {
//    return this.xf["@@transducer/result"](result);
//};
//transducers.KeepIndexed.prototype["@@transducer/step"] = function(result, input) {
//    this.i++;
//    var v = this.f(this.i, input);
//    if(v == null) {
//        return result;
//    } else {
//        return this.xf["@@transducer/step"](result, input);
//    }
//};
//
///**
// * Like keep but the provided function will be passed the
// * index as the first argument and the value second.
// * @method transducers.keepIndexed
// * @param {Function} f a function
// * @return {com.cognitect.transducers.KeepIndexed} a keepIndexed transducer
// * @example
// *     var t = transducers;
// *     var xf = t.keepIndexed(function(i, x) { if(typeof x == "string") return "cool"; });
// *     t.into([], xf, [0,1,"foo",3,4,"bar"]); // ["foo","bar"]
// */
//transducers.keepIndexed = function(f) {
//    if(TRANSDUCERS_DEV && (typeof f != "function")) {
//        throw new Error("keepIndexed must be given a function");
//    } else {
//        return function(xf) {
//            return new transducers.KeepIndexed(f, xf);
//        };
//    }
//};
//
///**
// * Given a transformer returns a transformer which preserves
// * reduced by wrapping one more time. See cat.
// * @method transducers.preservingReduced
// * @param {com.cognitect.transducers.ITransformer} xf a transformer
// * @return {com.cognitect.transducers.ITransformer} a transformer which preserves reduced
// */
//transducers.preservingReduced = function(xf) {
//    return {
//        "@@transducer/init": function() {
//            return xf["@@transducer/init"]();
//        },
//        "@@transducer/result": function(result) {
//            return result;
//        },
//        "@@transducer/step": function(result, input) {
//            var ret = xf["@@transducer/step"](result, input);
//            if(transducers.isReduced(ret)) {
//                return transducers.reduced(ret);
//            } else {
//                return ret;
//            }
//        }
//    };
//};
//
///**
// * Given a transformer return a concatenating transformer
// * @method transducers.cat
// * @param {com.cognitect.transducers.ITransformer} xf a transformer
// * @return {com.cognitect.transducers.ITransformer} a concatenating transformer
// */
//transducers.cat = function(xf) {
//    var rxf = transducers.preservingReduced(xf);
//    return {
//        "@@transducer/init": function() {
//            return xf["@@transducer/init"]();
//        },
//        "@@transducer/result": function(result) {
//            return xf["@@transducer/result"](result);
//        },
//        "@@transducer/step": function(result, input) {
//            return transducers.reduce(rxf, result, input);
//        }
//    };
//};
//
///**
// * A mapping concatenating transformer
// * @method transducers.mapcat
// * @param {Function} f the mapping function
// * @return {com.cognitect.transducers.ITransformer} a mapping concatenating transducer
// * @example
// *     var t = transducers;
// *     var reverse = function(arr) { var arr = Array.prototype.slice.call(arr, 0); arr.reverse(); return arr; }
// *     var xf = t.mapcat(reverse);
// *     t.into([], xf, [[3,2,1],[6,5,4]]); // [1,2,3,4,5,6]
// */
//transducers.mapcat = function(f) {
//    return transducers.comp(transducers.map(f), transducers.cat);
//};


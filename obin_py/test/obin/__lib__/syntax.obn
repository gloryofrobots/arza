infixl + + 50
infixl == == 10
import affirm
import lib_az:abc:module_ab as ab
import lib_az:efg:module_e as e
//
////unqualified names f_ab,f_ab_2,const
from lib_az:abc:module_ab  import (f_ab, f_ab_2, CONST as const)
//
////ab2:f_ab
import lib_az:abc:module_ab as ab2 (f_ab, f_ab_2)
//
////module_ab:f_ab, module_ab:f_ab_2
import lib_az:abc:module_ab (f_ab, f_ab_2)
//
////all exported names imported
from lib_az:efg:module_e import _

//ab_3_f_ab
from lib_az:abc:module_ab import (f_ab as ab_3_f_ab)
//importing same names dont cause errors because names are equal
from lib_az:abc:module_ab hide (CONST)
//ab5:f_ab_2 only
import lib_az:abc:module_ab as ab5 hiding (f_ab, CONST)

fun f a
    | a -> 1
    | z -> 2
    | x -> 3

fun f a  | a -> 1
         | z -> 2
         | x -> 3
fun f a b c
    | a b c -> 42
    | z e f -> 24
    | x [x:xs] l -> 31

fun f a b c | a b c -> 13

fun f3 (()) -> 43
fun f a b c -> [42,43,44]
               (42,43,44)
fun f a b c ->
    a :: b :: c
    tail (c :: f)
    lam a b c -> 42

fun f ((x of Int) y z) ->
    lam x y z -> 42
    lam x y z -> 123 end
    lam x y z | [hd::tl] (1,2,3) {x=2, y=3} -> 24
              | _ y z -> 23
    lam x y z
        | [hd::tl] (1,2,3) {x=2, y=3} -> 24
        | _ y z -> 23

    lam x y z -> 25 end 34
    f 23 lam x y z -> 42 end 34

    f lam x
        | x -> 34
        | x -> 4 end

    f lam x
        | x -> 34
        | x -> 4 end (1,2,3) (4,5,6)
    24

    ( lam x
        | x -> 1
        | y -> 2
      end
                1
                    2

                     3)
    (1,2, lam x | x -> 25
                | y -> 13 end, 25)

    (1,
     lam x | x -> 25
           | y -> 45 end,
     lam x
        | x -> 25
        | y -> 45 end,
     lam x -> 25 end,
     25)

    (1
     ,2,
        3)

    (1
    , lam x | x -> 25
            | y -> 45
    , lam x
        | x -> 25
        | y -> 45
    , lam x -> 25
    25)

    (1,
  2,
3)
    56

    {
        x = {
            y = 1
        },
        z = 2
    }
    append impl .
        (_t [self.methods.str,
            _f (_s ""),
            derived.str_,
            1])

    f (2;, 3)
    f (
        lam x ->
            1
        end
        , 3
        , 1
        , 4
        , 5
    )
    f (
        lam x ->
            1
        end .
            3
      , 1
      , 4
      , 5
    )
    (lam x
        | x -> 25
        | y -> 45 end,
                        lam x -> 25 end,
     25)

    {x=1,
  x=2,

 l=lam x y
    | x y -> 1
    | a v -> 2 end,
    n = 1
    }
    if x ->
        2
    else ->
        4

    5
    if x :: 2 ->
                          42
    elif (1,2,3) ->
        24
    elif {x=1, y=2} -> 35
    else -> 15

    match (1,2,3) with | (x,y,z) -> 2
                       | _ -> 1

    match (1,2,3)
    with | (x,y,z) -> 2
         | _ -> 1

    match lam x ->
              1
          end
    with
        | x ->
           lam () -> () end .
               (1 + 1)
        | y -> 2

    match if x == 1 ->
             2
          else ->
            3
          end
    with
        | x -> 3
        | y -> 2

    match 1 with
        | x -> 3
        | y -> 2

    match 1 with 3 -> 4
    match 1 with
        3 -> 4

    match
        if 1 ->
            1
        else ->
            3
        end 3 .
            4
    with
        | x -> 3
        | y -> 2
    try 1; catch 1 -> 1; end
    if 1 -> 1; else -> 2; end
    try 1; catch 1 ->
        1

    try 42
    catch 3 ->#first

    try 42
    catch 3 ->#first

    try 42
    catch 3 ->#first
    finally -> 12

    try 1
    catch 2 ->
        11
        try
            3
        catch 4 ->12
        finally ->
            if 6 -> 7
            elif 7 ->
                if 9 -> 14
                else -> 15
            else ->
                try
                    9
                catch
                    | 10 -> 11
                    | 13 -> 14
                finally ->
                    24
                8
    finally ->
        5
    try
        throw (1,2,"ERROR")
    catch
        | err @ (1, y, 3) -> #first
        | (1,2, "ERROR@") -> #second
        | err @ (1, 2, x) -> #third
    finally ->
        (#fourth, err, x)

    f try 1 catch | x -> 1; | y -> 2; finally -> 4 end 42

    try 1; catch
        | x -> 1
        | y -> 2
    finally -> 4

    try 1; catch
        | x -> 1; | y -> 2; finally -> 4

    try 1 catch | x -> 1 | y -> 2 finally -> 4


    f try 1; catch | x -> 1; | y -> 2
                   | y -> 2
      finally -> 4 end .
      42

    try 1; catch
        | x -> 1
        | y -> 2; finally -> 4

    co =
        coroutine lam yield x ->
                       _co1 =
                            coroutine lam yield2 y ->
                                           fun send () ->
                                                yield2 (42 + y)

                                           send ()
    foo 2 .
            3 .
         4

fun f x ->
    f lam x ->
        1
      end .
        3
    2
end
fun x () ->
    24
end

trait Eq for x
    def == x y -> throw (#NotImplemented, x, y)
    def != x y -> not x

trait Ord  for x of Eq
    def <= x y -> throw (#NotImplemented, x, y)
    def < x y -> (cmp x y) `is` LT
    def >= x y -> (cmp x y) `ne` LT
    def > x y -> (cmp x y) `eq` GT

    def cmp x y ->
                if x `eq` y -> EQ
                elif x `le` y -> LT
                else -> GT


    def max x y ->  y in_case x `le` y else x
    def min x y -> x in_case x `le` y else y

implement types:TestTrait for X
    def f a of X b c -> 42
    def f a of X b c -> 42


implement types:TestTrait for X
    def test_method_1 a1 of X a2 of X self -> a1.x a2.x self.x
    def test_method_2 a1 self a2 -> a1.x a2.x self.x
    def test_method_3 self a1 a2 -> a1.x a2.x self.x
    def test_method_4 self
        | x -> self.x
        | y -> 42
    def test_method_3 self a1 a2 -> a1.x a2.x self.x

implement X:x for T:t

extend Tuple with Eq

extend Tuple
    with Seq
        def first self -> _list:head self
        def rest self -> _list:tail self


extend List
    with Eq
    with Seq
        def first self ->
            match x with
                | 1 -> 2
                | 3 -> 4
            _list:head self
        def rest self -> _list:tail self
    with Constructable
        def cons value self -> _list:cons value self
    with Seqable
        def to_seq self ->
            match x with
                | 1 -> 2
                | 3 -> 4
    with Sized
        def len self -> _list:length
        def is_empty self -> _list:is_empty self
    with Emptiable
        def empty self -> []
    with Collection
        def put key value self -> _list:put key value self
        def at key self -> _list:at key self
        def del key self -> _list:del key self
        def elem key self -> _list:elem key self
    with Sliceable
        def slice first last self -> _list:slice first last self
        def drop count self -> _list:drop count self
        def take count self -> _list:take count self

type Maybe | Nothing
           | Just v

type Maybe
    | Nothing
    | Just v


type None

type Vec2 p1 p2

type P4 x y z c

type Shape
    | X x
    | Y y
    | Point x y
    | Square width height
    | Rect left top right bottom
    | Line point1 point2
    | Empty



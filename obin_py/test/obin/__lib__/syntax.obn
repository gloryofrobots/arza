fun f a 
    | a -> 1
    | z -> 2
    | x -> 3
    
fun f a  | a -> 1
         | z -> 2
         | x -> 3
fun f a b c 
    | a b c -> 42
    | z e f -> 24
    | x [x:xs] l -> 31

fun f a b c | a b c -> 13

fun f3 (()) -> 43
fun f a b c -> [42,43,44]
               (42,43,44)
fun f a b c ->
    a :: b :: c
    tail (c :: f)
    lam a b c -> 42
    
fun f ((x of Int) y z) ->
    lam x y z -> 42
    lam x y z -> 123 end
    lam x y z | [hd::tl] (1,2,3) {x=2, y=3} -> 24
              | _ y z -> 23
    lam x y z 
        | [hd::tl] (1,2,3) {x=2, y=3} -> 24
        | _ y z -> 23
    
    lam x y z -> 25 end 34
    f 23 lam x y z -> 42 end 34
    
    f lam x 
        | x -> 34  
        | x -> 4 end 
        
    f lam x 
        | x -> 34  
        | x -> 4 end (1,2,3) (4,5,6)
    24
    
    (1,2, lam x | x -> 25
                | y -> 13 end, 25)
                
    (1,
     lam x | x -> 25
           | y -> 45 end,
     lam x
        | x -> 25
        | y -> 45 end,
     lam x -> 25 end,
     25)
                
    (1
     ,2,
        3)
        
    (1
     , lam x | x -> 25
             | y -> 45
     ,lam x
        | x -> 25
        | y -> 45
     , lam x -> 25
     25)

    (1,
  2,
3)
    56 
    
    (1,
 lam x
    | x -> 25
    | y -> 45 end,
                        lam x -> 25 end,
     25)
     
    {x=1,
  x=2,
  
 l=lam x y
    | x y -> 1
    | a v -> 2 end,
    n = 1
    }
    if x ->
        2
    else ->
        4
    
    5
    if x :: 2 ->
                          42
    elif (1,2,3) -> 
        24
    elif {x=1, y=2} -> 35
    else -> 15
    
    match (1,2,3) | (x,y,z) -> 2
                  | _ -> 1
                  
    match (1,2,3) 
        | (x,y,z) -> 2
        | _ -> 1
        
trait Eq for x
    def == x y -> throw (#NotImplemented, x, y)
    def != x y -> not x 
    
trait Ord  for x of Eq
    def <= x y -> throw (#NotImplemented, x, y)
    def < x y -> (cmp x y) `is` LT
    def >= x y -> (cmp x y) `ne` LT
    def > x y -> (cmp x y) `eq` GT

    def cmp x y ->
                if x `eq` y -> EQ
                elif x `le` y -> LT
                else -> GT
                

    def max x y ->  y in_case x `le` y else x
    def min x y -> x in_case x `le` y else y
    
implement types:TestTrait for X
    def f a of X b c -> 42
    def f a of X b c -> 42


implement types:TestTrait for X
    def test_method_1 a1 of X a2 of X self -> a1.x a2.x self.x
    def test_method_2 a1 self a2 -> a1.x a2.x self.x
    def test_method_3 self a1 a2 -> a1.x a2.x self.x
    def test_method_4 self 
        | x -> self.x
        | y -> 42
    def test_method_3 self a1 a2 -> a1.x a2.x self.x
    
implement X:x for T:t


derive Dict for Val
//
derive (Eq, Str) for (TypeError, RuntimeError, ImportError, NotImplementedError,
                     ZeroDivisionError, ReferenceError, ConstructorError, KeyError, ValueError,
                     SliceError, IndexError, InvokeError, InvalidArgCount, MethodInvokeError,
                     MethodNotImplementedError, MethodSpecializeError, CompileError, ParseError,
                     UnpackSequenceError, FiberFlowError, MatchError, FunctionArgumentsMatchError,
                     ExceptionMatchError, ExportError, TraitAlreadyImplementedError, TraitImplementationError,
                     TraitConstraintError)
type Maybe | Nothing
           | Just v
    
type Maybe
    | Nothing
    | Just v
    

type None
type Vec2 p1 p2

type P4 x y z c
type None


//
//
type Shape
    | X x
    | Y y
    | Point x y
    | Square width height
    | Rect left top right bottom
    | Line point1 point2
    | Empty

import affirm
import lib_az:abc:module_ab as ab
import lib_az:efg:module_e as e
//
////unqualified names f_ab,f_ab_2,const
import from lib_az:abc:module_ab (f_ab, f_ab_2, CONST as const)
//
////ab2:f_ab
import lib_az:abc:module_ab as ab2 (f_ab, f_ab_2)
//
////module_ab:f_ab, module_ab:f_ab_2
import lib_az:abc:module_ab (f_ab, f_ab_2)
//
////all exported names imported
import from lib_az:efg:module_e

//ab_3_f_ab
import from lib_az:abc:module_ab  (f_ab as ab_3_f_ab)
//importing same names dont cause errors because names are equal
import from lib_az:abc:module_ab  hiding (CONST)
//ab5:f_ab_2 only
import lib_az:abc:module_ab as ab5 hiding (f_ab, CONST)

fun f a 
    | a -> 1
    | z -> 2
    | x -> 3
    
fun f a  | a -> 1
         | z -> 2
         | x -> 3
fun f a b c 
    | a b c -> 42
    | z e f -> 24
    | x [x:xs] l -> 31

fun f a b c | a b c -> 13

fun f3 (()) -> 43
fun f a b c -> [42,43,44]
               (42,43,44)
fun f a b c ->
    a :: b :: c
    tail (c :: f)
    lam a b c -> 42
    
fun f ((x of Int) y z) ->
    lam x y z -> 42
    lam x y z -> 123 end
    lam x y z | [hd::tl] (1,2,3) {x=2, y=3} -> 24
              | _ y z -> 23
    lam x y z 
        | [hd::tl] (1,2,3) {x=2, y=3} -> 24
        | _ y z -> 23
    
    lam x y z -> 25 end 34
    f 23 lam x y z -> 42 end 34
    
    f lam x 
        | x -> 34  
        | x -> 4 end 
        
    f lam x 
        | x -> 34  
        | x -> 4 end (1,2,3) (4,5,6)
    24
    
    (1,2, lam x | x -> 25
                | y -> 13 end, 25)
                
    (1,
     lam x | x -> 25
           | y -> 45 end,
     lam x
        | x -> 25
        | y -> 45 end,
     lam x -> 25 end,
     25)
                
    (1
     ,2,
        3)
        
    (1
     , lam x | x -> 25
             | y -> 45
     ,lam x
        | x -> 25
        | y -> 45
     , lam x -> 25
     25)

    (1,
  2,
3)
    56 
    
    (1,
 lam x
    | x -> 25
    | y -> 45 end,
                        lam x -> 25 end,
     25)
     
    {x=1,
  x=2,
  
 l=lam x y
    | x y -> 1
    | a v -> 2 end,
    n = 1
    }
    if x ->
        2
    else ->
        4
    
    5
    if x :: 2 ->
                          42
    elif (1,2,3) -> 
        24
    elif {x=1, y=2} -> 35
    else -> 15
    
    match (1,2,3) | (x,y,z) -> 2
                  | _ -> 1
                  
    match (1,2,3) 
        | (x,y,z) -> 2
        | _ -> 1
        
    try 42
    catch 3 ->#first

    try 42
    catch 3 ->#first
    
    try 42
    catch 3 ->#first
    finally -> 12
    
    try
        throw (1,2,"ERROR")
    catch
        | err @ (1, y, 3) -> #first
        | (1,2, "ERROR@") -> #second
        | err @ (1, 2, x) -> #third
    finally ->
        (#fourth, err, x)
     
    co =
        coroutine lam yield x ->
                       _co1 =
                            coroutine lam yield2 y ->
                                           fun send () ->
                                                yield2 (42 + y)
                                                
                                           send () 
    foo 2 .
            3 .
        4
        
trait Eq for x
    def == x y -> throw (#NotImplemented, x, y)
    def != x y -> not x 
    
trait Ord  for x of Eq
    def <= x y -> throw (#NotImplemented, x, y)
    def < x y -> (cmp x y) `is` LT
    def >= x y -> (cmp x y) `ne` LT
    def > x y -> (cmp x y) `eq` GT

    def cmp x y ->
                if x `eq` y -> EQ
                elif x `le` y -> LT
                else -> GT
                

    def max x y ->  y in_case x `le` y else x
    def min x y -> x in_case x `le` y else y
    
implement types:TestTrait for X
    def f a of X b c -> 42
    def f a of X b c -> 42


implement types:TestTrait for X
    def test_method_1 a1 of X a2 of X self -> a1.x a2.x self.x
    def test_method_2 a1 self a2 -> a1.x a2.x self.x
    def test_method_3 self a1 a2 -> a1.x a2.x self.x
    def test_method_4 self 
        | x -> self.x
        | y -> 42
    def test_method_3 self a1 a2 -> a1.x a2.x self.x
    
implement X:x for T:t


derive Dict for Val
//
derive (Eq, Str) for (TypeError, RuntimeError, ImportError, NotImplementedError,
                     ZeroDivisionError, ReferenceError, ConstructorError, KeyError, ValueError,
                     SliceError, IndexError, InvokeError, InvalidArgCount, MethodInvokeError,
                     MethodNotImplementedError, MethodSpecializeError, CompileError, ParseError,
                     UnpackSequenceError, FiberFlowError, MatchError, FunctionArgumentsMatchError,
                     ExceptionMatchError, ExportError, TraitAlreadyImplementedError, TraitImplementationError,
                     TraitConstraintError)
type Maybe | Nothing
           | Just v
    
type Maybe
    | Nothing
    | Just v
    

type None

type Vec2 p1 p2

type P4 x y z c

type Shape
    | X x
    | Y y
    | Point x y
    | Square width height
    | Rect left top right bottom
    | Line point1 point2
    | Empty
    
    
    
    
    
    
    
    
   //    affirm:is_equal if 13 -> 1
//                    elif 14 ->
//                       2 
//                    else -> 4 
//                    8
//    lam arg1 arg2 ->
//        try
//            1/0
//        catch e ->
//            throw (arg1, arg2)
//        finally ->
//            throw e
//    end (33, 22) (33, 22)
//    
//    affirm:is_equal (
//        try
//            try
//                1/0
//            catch e1 ->
//                //result
//                e1
//        catch e2 ->
//            try
//                error(#LifeSucks)
//            catch e3 ->
//                e3
//        ) (ZeroDivisionError (1, 0))
//    try 42
//    catch 3 ->#first
//    
//    try 42
//    catch 3 ->#first
//    finally -> 12
//    
//    try
//        throw (1,2,"ERROR")
//    catch
//        | err @ (1, y, 3) -> #first
//        | (1,2, "ERROR@") -> #second
//        | err @ (1, 2, x) -> #third
//    finally ->
//        (#fourth, err, x)
 
//    if 1 -> 1
//    elif 2 -> 2
//    elif 3 -> 3
//    else -> 4
        
//    lam x -> 
//        x 
//    lam x 
//        | x ->
//            x
//        | y ->
//            y
//        
//    42
     

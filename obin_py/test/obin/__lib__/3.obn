while: aCondition do: aBlock [

]

for: val to: limit do: block [

]

for: val to: limit by:step do: block [

]

X = {
  _name = 1
  _surname = 2

  name [
       _name
  ]

  newName: aName surname: aSurname [
       return instance: self
  ]

} with: {
  surname [
     _surname
  ]
}
extend: X with: {
        fullname [
                 _name + " " + _surname
        ]
}


object X [
       name = 0
       surname = 1
]

eval [
     x = 1
     while: [1 + 4 - x > 0] do: [
            x += 1
     ]

     for:1 to:10 do: [ (i)
           print: i
     ]
]

simplifyExtend:node [
    typename_1_arg = node first.

    mixins = node second.
    methods = node third.
    print: "SIMPLIFY".
    print: typename_1_arg.
    mixins_list = Vector empty.
    methods_list = Vector empty.

    mixins each: [mixin_data |
           source = mixin_data at: 0.
           names = mixin_data at: 1.
           (names is_empty) ifTrue: [
                mixins_list append: source
           ] ifFalse: [
                names each: [name|
                      methods_list append:
                          nodes create_tuple_node: name
                                els: Vector with: name
                                            with: nodes create_lookup_node: source
                                                        left:source
                                                        right:name
                ]
           ].
    ].
    methods each: [method_data|
            generic_name = method_data at:0.
            impl = method_data at: 0.
            io print: "METHOD"; print: generic_name; cr.
            methods_list append:
                         nodes create_tuple_node: generic_name
                               elements: Vector with: generic_name
                                                with: nodes create_fun_node: generic_name
                                                            name: nodes empty_node
                                                            variants: impl.
    ].
    mixins_2_arg = nodes create_list_node: node list: mixins_list.
    methods_3_arg = nodes create_list_node: node list: methods_list.

    ^ nodes create_call_node_s: node
            name: lang_names.EXTEND
            args: (typename_1_arg, mixins_2_arg, methods_3_arg)
]



simplifyExtend:node [
    typename_1_arg = node first.

    mixins = node second.
    methods = node third.
    print: "SIMPLIFY".
    print: typename_1_arg.
    mixins_list = Vector empty.
    methods_list = Vector empty.

    foreach: mixins do: [mixin_data |
           source = mixin_data at: 0.
           names = mixin_data at: 1.
           if: [names is_empty] do: [
                mixins_list append: source
           ] else: [
                foreach: names do: [name|
                      methods_list append:
                          nodes create_tuple_node: name
                                els: @(name, nodes create_lookup_node: source
                                                   left:source
                                                   right:name)
                ]
           ].
    ].
    methods each: [method_data|
            generic_name = method_data at:0.
            impl = method_data at: 0.
            io print: "METHOD"; print: generic_name; cr.
            methods_list append:
                         nodes create_tuple_node: generic_name
                               elements: Vector with: generic_name
                                                with: nodes create_fun_node: generic_name
                                                            name: nodes empty_node
                                                            variants: impl.
    ].
    mixins_2_arg = nodes create_list_node: node list: mixins_list.
    methods_3_arg = nodes create_list_node: node list: methods_list.

    ^ nodes create_call_node_s: node
            name: lang_names.EXTEND
            args: (typename_1_arg, mixins_2_arg, methods_3_arg)
]


getExtensionMethods: _type mixins: _mixins methods: _methods (
    total = List empty.
    constraints = List empty.
    error affirm_type: _methods with: space isList.
    _mixins each: [trait|
        error affirm_type: trait with: space isTrait.
        constraints concat: trait constraints.
        trait_methods = trait methods.
        total = trait_methods + total.
    ]

    total = _methods + total.
    constraints each: [iface|
        iface generics each:[generic|
              (total containsWith:[pair| pair at:0 == generic])
                     ifFalse: [
                        raise:
                            (error throw: error Errors CONSTRAINT_ERROR
                                   with: _type
                                   with: _iface
                                   with: generic
                                   with: space String new: "")

                     ]
        ]
    ].
    result = List empty.
    total each: [pair|
          generic = pait at: 0.
          (result containsWith:[p| p at:0 == generic])
                  ifTrue:[ result push: pair].
    ]
    ^ result reverse
)


def _get_extension_methods(_type, _mixins, _methods):
    # BETTER WAY IS TO MAKE DATATYPE IMMUTABLE
    # AND CHECK CONSTRAINTS AFTER SETTING ALL METHO
    total = plist.empty()
    constraints = plist.empty()
    error.affirm_type(_methods, space.islist)
    for trait in _mixins:
        error.affirm_type(trait, space.istrait)
        constraints = plist.concat(constraints, trait.constraints)
        trait_methods = trait.to_list()
        total = plist.concat(trait_methods, total)

    total = plist.concat(_methods, total)

    for iface in constraints:
        for generic in iface.generics:

            if not plist.contains_with(total, generic,
                                       _find_constraint_generic):
                return error.throw_4(error.Errors.CONSTRAINT_ERROR,
                                    _type, iface, generic,
                                    space.newstring(
                                        u"Dissatisfied trait constraint"))

    result = plist.empty()
    for pair in total:
        generic = pair[0]
        if plist.contains_with(result, generic, _find_constraint_generic):
            continue

        result = plist.cons(pair, result)

    return plist.reverse(result)

fun split_seq_test () ->
    ints = list:range(0, 20)
    input = seq:map(fun (x) ->
                        (x, list:range(0, x))
                    end,
                    ints)

    (evens,ods) = seq:partition(fun (x)
                                    | (x, data) -> even x
                                end,
                                input)

    fun _transform (s) ->
        seq:foldl(fun (item acc)
                            | ((x, []), acc) -> (x, 0) :: acc
                            | ((x, data), acc) ->
                              (x, seq:reduce &`+` data) :: acc
                  end,
                  [],
                  s)

    ods_r = _transform(ods)
    evens_r = _transform(evens)

    result_unsorted = ods_r ++ evens_r
    affirm:is_equal(
                   result_unsorted,
                   [(19, 171), (17, 136), (15, 105), (13, 78), (11, 55), (9, 36), (7, 21), (5, 10), (3, 3), (1, 0),
                   (18, 153), (16, 120), (14, 91), (12, 66), (10, 45), (8, 28), (6, 15), (4, 6), (2, 1), (0, 0)]
    )

fun split_seq_test() ->
    ints = list:range 0 20
    input = seq:map ((x => (x, list:range 0 x))) ints

    (evens,ods) = (seq:partition fun _ x
                                    | (x, data) ->
                                         even x
                                 end
                                 input)

    fun _transform s ->
        (seq:foldl fun _ item acc
                            | (x, []) acc -> (x, 0) :: acc
                            | (x, data) acc ->
                                (x, seq:reduce &`+` data) :: acc
                   end
                   []
                   s)

    ods_r = _transform ods
    evens_r = _transform evens

    result_unsorted = ods_r ++ evens_r
    (affirm:is_equal result_unsorted
                     [(19, 171), (17, 136), (15, 105), (13, 78), (11, 55), (9, 36), (7, 21), (5, 10), (3, 3), (1, 0), (18, 153), (16, 120), (14, 91), (12, 66), (10, 45), (8, 28), (6, 15), (4, 6), (2, 1), (0, 0)])



fun split_seq_test () ->
    ints = list:range(0, 20)
    input = seq:map((x) => (x, list:range(0, x)), ints)

    (evens,ods) = seq:partition(fun (x, data) -> even x, input)

    fun _transform (s) ->
        seq:foldl(fun ((x, []), acc) -> (x, 0) :: acc
                    | ((x, data), acc) ->
                              (x, seq:reduce &`+` data) :: acc
                  end
                  [],
                  s)

    ods_r = _transform(ods)
    evens_r = _transform(evens)

    result_unsorted = ods_r ++ evens_r
    affirm:is_equal(
                   result_unsorted,
                   [(19, 171), (17, 136), (15, 105), (13, 78), (11, 55), (9, 36), (7, 21), (5, 10), (3, 3), (1, 0),
                   (18, 153), (16, 120), (14, 91), (12, 66), (10, 45), (8, 28), (6, 15), (4, 6), (2, 1), (0, 0)]
    )


(*
    union = (* types = [] repr = "UNION" *)

    dispatch:method in_process:process = (|
         impl = space newvoid.
         self union ifNil: (| impl = self union get_method: method ).

         if: (impl isNil && self is_singleton) do: (|
             impl = self get_method: method.
         ).

         impl ifNil:(|
              _type = api get_type:self in_process:process.
              impl = _type get_method: method
         ).
         ^ impl
    )
*)

{
    union = { types = #[] repr = "UNION" }
    ints = [* 1, 2 pow: 4, math pow:2 to:4, *]
    dispatch:method in_process:process = [
         impl = space newvoid.
         self union ifNil: [ impl = self union get_method: method ].

         if: (impl isNil && self is_singleton) do: [
             impl = self get_method: method.
         ].

         impl ifNil:[
              _type = api get_type:self in_process:process.
              impl = _type get_method: method
         ].
         ^ impl
    ]
}

{
    union = { types = #[] repr = "UNION" }

    dispatch:method in_process:process = (|
         impl = space newvoid.
         self union ifNil: (| impl = self union get_method: method ).

         if: (impl isNil && self is_singleton) do: (|
             impl = self get_method: method.
         ).

         impl ifNil:(|
              _type = api get_type:self in_process:process.
              impl = _type get_method: method
         ).
         ^ impl
    )
}
//LOOP HELPS///////////////////////////////////////////////////////////
fun iter1 f arg1  ->
    try
        f arg1
    catch
        | e of Interrupt -> e.result
        | e -> throw e

fun iter2 f arg1 arg2 ->
    try
        f arg1 arg2
    catch
        | e of Interrupt -> e.result
        | e -> throw e

fun iter3 f arg1 arg2 arg3 ->
    try
        f arg1 arg2 arg3
    catch
        | e of Interrupt -> e.result
        | e -> throw e

fun iter4 f arg1 arg2 arg3 arg4 ->
    try
        f arg1 arg2 arg3 arg4
    catch
        | e of Interrupt -> e.result
        | e -> throw e

//REDUCERS///////////////////////////////////////////////////////

fun foldl func accumulator coll ->
    fun _foldl f acc coll
        | f acc [] -> acc
        | f acc hd::tl -> _foldl f (f hd acc) tl

    iter3 _foldl func accumulator coll
----------------------------------------

fun foldr func accumulator coll ->
    fun _foldr f acc coll
        | f acc [] -> acc
        | f acc hd::tl -> f hd (_foldr f acc tl)

    iter3 _foldr func accumulator coll
--------------------------------------------------

fun scanl func accumulator coll ->
    fun _scanl f acc coll
        | f acc [] -> acc::(empty coll)
        | f acc hd::tl -> acc :: (_scanl f (f hd acc) tl)

    iter3 _scanl func accumulator coll
--------------------------------------------------

//LOOPS ////////////////////////

fun map f coll ->
    fun _map f coll
        | f [] -> empty coll
        | f hd::tl -> (f hd) :: (_map f tl)

    iter2 _map f coll
----------------------------------------

fun foreach f coll ->
    fun _foreach f coll
        | f [] -> empty coll
        | f hd::tl -> f hd; _foreach f tl

    iter2 _foreach f coll
----------------------------------------

fun intersperse val coll
    | val [] -> empty coll
    | val hd::tl  -> hd :: val :: (intersperse val tl)
--------------------------------------------------

fun reverse coll ->
    fun _reverse l result
        | [] result -> result
        | hd::tl result -> (_reverse tl (hd :: result))
    ---------------

    _reverse coll (empty coll)
----------------------------------------


fun list coll ->
    reverse (foldl cons [] coll)

//Usable in case of lazy seq
fun doall coll ->
    fun walk _coll
        | [] -> coll
        | hd::tl -> walk tl

    walk coll
----------------------------------------


///ACCESSORS//////////////////////////////////////

fun nth_tail (count of Int) coll
    | 0 l -> l
    | 1 [_, ...t] -> t
    | n [_, ...t] when n >= 0 -> nth_tail (n - 1) t
--------------------------------------------------

fun nth (count of Int) coll
    | 0 l -> l
    | 1 [h, ...t] -> h
    | n [h, ...t] when n >= 0 -> nth (n - 1) t
--------------------------------------------------

//QUERIES///////////////////////////////////////////////////

fun length l of List ->
    foldl lam _ acc -> acc + 1 end 0 l
--------------------------------------------------

fun last coll
    | [x, ...xs] ->
        fun _last hd tl
            | _ [x, ...xs] -> _last x xs
            | x [] -> x
        ------------

        _last x xs
--------------------------------------------------


fun prefix_of coll1 coll2
    | [hd, ...pre_tail] [hd, ...tail] -> prefix_of pre_tail tail
    | [] s -> True
    | [_, ..._] s -> False
--------------------------------------------------

fun suffix_of suf s  ->
   delta = (len s) - (len suf)
   tl = nth_tail delta s
   delta >= 0 and tl == suf
--------------------------------------------------

//SUBLISTS/////////////////////////////////////////////////////////////
fun drop count coll
    | 0 l -> l
    | count hd::tl -> drop (count - 1) tl
--------------------------------------------------

fun take count coll
    | 0 _ -> empty coll
    | _ [] -> empty coll
    | n [x, ...xs] -> x :: (take (n-1)  xs)
--------------------------------------------------

fun split_at (n of Int) l -> ((take n l), (drop n l)) end

fun take_while predicate coll
    | p [] -> empty coll
    | p [x, ...xs] -> x :: (take_while p xs) in_case p x else empty coll
--------------------------------------------------

fun drop_while predicate coll
    | p [] -> empty coll
    | p xs@[x, ...xs1] -> (drop_while p xs1) in_case p x else xs
--------------------------------------------------

fun filter predicate coll
    | p [] -> empty coll
    | p x::xs ->
        if p x ->
            x :: filter p xs
        else ->
            filter p xs
--------------------------------------------------

fun span predicate coll
    | p [] ->
        c = empty coll
        (c, c)
    | p xs@[x, ...xs1] ->
        if not (p x) ->
            (empty coll, xs)
        else ->
            (ys, zs) = (span p xs1)
            (x::ys, zs)
        ------------------------------
--------------------------------------------------

fun delete item coll
    | item [item, ...xs] -> xs
    | item [x, ...xs] -> x :: (delete item xs)
    | _ [] -> empty coll
--------------------------------------------------

fun insert index v coll
    | 0 v coll -> v::coll
    | i v [] -> throw IndexError ("Invalid insertion index", index, v)
    | i v x::xs -> x :: (insert (i - 1) v xs)

fun append v coll ->
    insert (length coll) v coll

////QUERIES//////////////////////////////////////////////////////////////////

fun conjunction l ->
    foldr lam v acc -> v and acc end True l end

fun disjunction l ->
    foldr lam v acc -> v or acc end False l end

fun any p l ->
    disjunction (map p l) end

fun all p l ->
    conjunction (map p l) end

fun element x l ->
    any lam v -> v == x end l end

fun contains l x ->
    element x l end

//BUILDERS/////////////////////////////////////////////////////////////

fun concat l1 l2 ->
    foldr `::` l2 l1 end

fun uncons coll | [x, ...xs] -> (x, xs) end

fun init coll
    | [x] -> empty coll
    | [x, ...xs] -> x :: (init xs)
    | [] -> throw (ValueError "empty seq in init")
------------------------------


//REDUCERS///////////////////////////////////////////////////////
fun foldl func accumulator coll
    | f acc [] -> acc
    | f acc hd::tl -> foldl f (f hd acc) tl
----------------------------------------

fun foldr func accumulator coll
    | f acc [] -> acc
    | f acc hd::tl -> f hd (foldr f acc tl)
--------------------------------------------------

fun reduce f l
    | f x::xs -> foldl f x xs
    | f [] -> throw EmptySeqError l
--------------------------------------------------

fun scanl func accumulator coll
    | f acc [] -> acc::(empty coll)
    | f acc hd::tl -> acc :: (scanl f (f hd acc) tl)
--------------------------------------------------

//LOOPS ////////////////////////
fun map f coll
    | f [] -> empty coll
    | f hd::tl -> (f hd) :: (map f tl)
----------------------------------------

fun foreach f coll
    | f [] -> empty coll
    | f hd::tl -> f hd; foreach f tl
----------------------------------------

fun intersperse val coll
    | val [] -> empty coll
    | val hd::tl  -> hd :: val :: (intersperse val tl)
--------------------------------------------------

fun reverse coll ->
    fun _reverse l result
        | [] result -> result
        | hd::tl result -> (_reverse tl (hd :: result))
    ---------------

    _reverse coll (empty coll)
----------------------------------------
fun list coll ->
    reverse (foldl cons [] coll)

///ACCESSORS//////////////////////////////////////

fun nth_tail (count of Int) coll
    | 0 l -> l
    | 1 [_, ...t] -> t
    | n [_, ...t] when n >= 0 -> nth_tail (n - 1) t
--------------------------------------------------

fun nth (count of Int) coll
    | 0 l -> l
    | 1 [h, ...t] -> h
    | n [h, ...t] when n >= 0 -> nth (n - 1) t
--------------------------------------------------

//QUERIES///////////////////////////////////////////////////

fun length l of List ->
    foldl lam _ acc -> acc + 1 end 0 l
--------------------------------------------------

fun last coll
    | [x, ...xs] ->
        fun _last hd tl
            | _ [x, ...xs] -> _last x xs
            | x [] -> x
        ------------

        _last x xs
--------------------------------------------------


fun prefix_of coll1 coll2
    | [hd, ...pre_tail] [hd, ...tail] -> prefix_of pre_tail tail
    | [] s -> True
    | [_, ..._] s -> False
--------------------------------------------------

fun suffix_of suf s  ->
   delta = (len s) - (len suf)
   tl = nth_tail delta s
   delta >= 0 and tl == suf
--------------------------------------------------

//SUBLISTS/////////////////////////////////////////////////////////////
fun drop count coll
    | 0 l -> l
    | count hd::tl -> drop (count - 1) tl
--------------------------------------------------

fun take count coll
    | 0 _ -> empty coll
    | _ [] -> empty coll
    | n [x, ...xs] -> x :: (take (n-1)  xs)
--------------------------------------------------

fun split_at (n of Int) l -> ((take n l), (drop n l)) end

fun take_while predicate coll
    | p [] -> empty coll
    | p [x, ...xs] -> x :: (take_while p xs) in_case p x else empty coll
--------------------------------------------------

fun drop_while predicate coll
    | p [] -> empty coll
    | p xs@[x, ...xs1] -> (drop_while p xs1) in_case p x else xs
--------------------------------------------------

fun filter predicate coll
    | p [] -> empty coll
    | p x::xs ->
        if p x ->
            x :: filter p xs
        else ->
            filter p xs
--------------------------------------------------

fun span predicate coll
    | p [] ->
        c = empty coll
        (c, c)
    | p xs@[x, ...xs1] ->
        if not (p x) ->
            (empty coll, xs)
        else ->
            (ys, zs) = (span p xs1)
            (x::ys, zs)
        ------------------------------
--------------------------------------------------

fun delete item coll
    | item [item, ...xs] -> xs
    | item [x, ...xs] -> x :: (delete item xs)
    | _ [] -> empty coll
--------------------------------------------------

fun insert index v coll
    | 0 v coll -> v::coll
    | i v [] -> throw IndexError ("Invalid insertion index", index, v)
    | i v x::xs -> x :: (insert (i - 1) v xs)

fun append v coll ->
    insert (length coll) v coll

////QUERIES//////////////////////////////////////////////////////////////////

fun conjunction l ->
    foldr lam v acc -> v and acc end True l end

fun disjunction l ->
    foldr lam v acc -> v or acc end False l end

fun any p l ->
    disjunction (map p l) end

fun all p l ->
    conjunction (map p l) end

fun element x l ->
    any lam v -> v == x end l end

fun contains l x ->
    element x l end

fun equal s1 s2
    | x::xs x::ys -> equal xs ys
    | [] [] -> True
    | _ _ -> False
//BUILDERS/////////////////////////////////////////////////////////////

fun concat l1 l2 ->
    foldr `::` l2 l1 end

fun uncons coll | [x, ...xs] -> (x, xs) end

fun init coll
    | [x] -> empty coll
    | [x, ...xs] -> x :: (init xs)
    | [] -> throw (ValueError "empty seq in init")
------------------------------

fun zip seq1 seq2
    | x::xs y::ys -> (x, y) :: zip xs ys
    | _ _ -> []
--------------------------------------------------

fun unzip l ->
    fun _unzip l seq1 seq2
        | (x, y) :: ts xs ys -> _unzip ts (x :: xs) (y :: ys)
        | [] xs ys -> (reverse xs, reverse ys)
    _unzip l [] []
--------------------------------------------------

fun zip3 s1 s2 s3
    | x::xs y::ys z::zs -> (x, y, z) :: zip3 xs ys zs
    | _ _ _ -> []
--------------------------------------------------

fun unzip3 l ->
    fun _unzip3 l acc_x acc_y acc_z
        | [(x, y, z), ...ts] xs ys zs -> _unzip3 ts (x::xs) (y::ys) (z::zs)
        | [] xs ys zs -> (reverse xs, reverse ys, reverse zs)
    _unzip3 l [] [] []

//unzip3(Ts) -> unzip3(Ts, [], [], []).
//
//unzip3([{X, Y, Z} | Ts], Xs, Ys, Zs) ->
//    unzip3(Ts, [X | Xs], [Y | Ys], [Z | Zs]);
//unzip3([], Xs, Ys, Zs) ->
//    {reverse(Xs), reverse(Ys), reverse(Zs)}.
//
//%% Return [F(X0, Y0), F(X1, Y1), ..., F(Xn, Yn)] for lists [X0, X1, ...,
//%% Xn] and [Y0, Y1, ..., Yn].
//
//-spec zipwith(Combine, List1, List2) -> List3 when
//      Combine :: fun((X, Y) -> T),
//      List1 :: [X],
//      List2 :: [Y],
//      List3 :: [T],
//      X :: term(),
//      Y :: term(),
//      T :: term().
//
//zipwith(F, [X | Xs], [Y | Ys]) -> [F(X, Y) | zipwith(F, Xs, Ys)];
//zipwith(F, [], []) when is_function(F, 2) -> [].
//
//%% Return [F(X0, Y0, Z0), F(X1, Y1, Z1), ..., F(Xn, Yn, Zn)] for lists
//%% [X0, X1, ..., Xn], [Y0, Y1, ..., Yn] and [Z0, Z1, ..., Zn].
//
//-spec zipwith3(Combine, List1, List2, List3) -> List4 when
//      Combine :: fun((X, Y, Z) -> T),
//      List1 :: [X],
//      List2 :: [Y],
//      List3 :: [Z],
//      List4 :: [T],
//      X :: term(),
//      Y :: term(),
//      Z :: term(),
//      T :: term().
//
//zipwith3(F, [X | Xs], [Y | Ys], [Z | Zs]) ->
//    [F(X, Y, Z) | zipwith3(F, Xs, Ys, Zs)];
//zipwith3(F, [], [], []) when is_function(F, 3) -> [].

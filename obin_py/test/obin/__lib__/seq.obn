//REDUCERS///////////////////////////////////////////////////////
fun foldl func accumulator coll
    | f acc [] -> acc
    | f acc hd::tl -> foldl f (f hd acc) tl
----------------------------------------

fun foldr func accumulator coll
    | f acc [] -> acc
    | f acc hd::tl -> f hd (foldr f acc tl)
--------------------------------------------------

fun reduce f l
    | f x::xs -> foldl f x xs
    | f [] -> throw EmptySeqError l
--------------------------------------------------

fun scanl func accumulator coll
    | f acc [] -> acc::(empty coll)
    | f acc hd::tl -> acc :: (scanl f (f hd acc) tl)
--------------------------------------------------

//LOOPS ////////////////////////
fun map f coll
    | f [] -> empty coll
    | f hd::tl -> (f hd) :: (map f tl)
----------------------------------------

fun foreach f coll
    | f [] -> empty coll
    | f hd::tl -> f hd; foreach f tl
----------------------------------------

fun intersperse val coll
    | val [] -> empty coll
    | val hd::tl  -> hd :: val :: (intersperse val tl)
--------------------------------------------------

fun reverse coll ->
    fun _reverse l result
        | [] result -> result
        | hd::tl result -> (_reverse tl (hd :: result))
    ---------------

    _reverse coll (empty coll)
----------------------------------------
fun list coll ->
    reverse (foldl cons [] coll)

///ACCESSORS//////////////////////////////////////

fun nth_tail (count of Int) coll
    | 0 l -> l
    | 1 [_, ...t] -> t
    | n [_, ...t] when n >= 0 -> nth_tail (n - 1) t
--------------------------------------------------

fun nth (count of Int) coll
    | 0 l -> l
    | 1 [h, ...t] -> h
    | n [h, ...t] when n >= 0 -> nth (n - 1) t
--------------------------------------------------

//QUERIES///////////////////////////////////////////////////

fun length l of List ->
    foldl lam _ acc -> acc + 1 end 0 l
--------------------------------------------------

fun last coll
    | [x, ...xs] ->
        fun _last hd tl
            | _ [x, ...xs] -> _last x xs
            | x [] -> x
        ------------

        _last x xs
--------------------------------------------------


fun prefix_of coll1 coll2
    | [hd, ...pre_tail] [hd, ...tail] -> prefix_of pre_tail tail
    | [] s -> True
    | [_, ..._] s -> False
--------------------------------------------------

fun suffix_of suf s  ->
   delta = (len s) - (len suf)
   tl = nth_tail delta s
   delta >= 0 and tl == suf
--------------------------------------------------

//SUBLISTS/////////////////////////////////////////////////////////////
fun drop count coll
    | 0 l -> l
    | count hd::tl -> drop (count - 1) tl
--------------------------------------------------

fun take count coll
    | 0 _ -> empty coll
    | _ [] -> empty coll
    | n [x, ...xs] -> x :: (take (n-1)  xs)
--------------------------------------------------

fun split_at (n of Int) l -> ((take n l), (drop n l)) end

fun take_while predicate coll
    | p [] -> empty coll
    | p [x, ...xs] -> x :: (take_while p xs) in_case p x else empty coll
--------------------------------------------------

fun drop_while predicate coll
    | p [] -> empty coll
    | p xs@[x, ...xs1] -> (drop_while p xs1) in_case p x else xs
--------------------------------------------------

fun filter predicate coll
    | p [] -> empty coll
    | p x::xs ->
        if p x ->
            x :: filter p xs
        else ->
            filter p xs
--------------------------------------------------

fun span predicate coll
    | p [] ->
        c = empty coll
        (c, c)
    | p xs@[x, ...xs1] ->
        if not (p x) ->
            (empty coll, xs)
        else ->
            (ys, zs) = (span p xs1)
            (x::ys, zs)
        ------------------------------
--------------------------------------------------

fun delete item coll
    | item [item, ...xs] -> xs
    | item [x, ...xs] -> x :: (delete item xs)
    | _ [] -> empty coll
--------------------------------------------------

fun insert index v coll
    | 0 v coll -> v::coll
    | i v [] -> throw IndexError ("Invalid insertion index", index, v)
    | i v x::xs -> x :: (insert (i - 1) v xs)

fun append v coll ->
    insert (length coll) v coll

////QUERIES//////////////////////////////////////////////////////////////////

fun conjunction l ->
    foldr lam v acc -> v and acc end True l end

fun disjunction l ->
    foldr lam v acc -> v or acc end False l end

fun any p l ->
    disjunction (map p l) end

fun all p l ->
    conjunction (map p l) end

fun element x l ->
    any lam v -> v == x end l end

fun contains l x ->
    element x l end

fun equal s1 s2
    | x::xs x::ys -> equal xs ys
    | [] [] -> True
    | _ _ -> False
//BUILDERS/////////////////////////////////////////////////////////////

fun concat l1 l2 ->
    foldr `::` l2 l1 end

fun uncons coll | [x, ...xs] -> (x, xs) end

fun init coll
    | [x] -> empty coll
    | [x, ...xs] -> x :: (init xs)
    | [] -> throw (ValueError "empty seq in init")
------------------------------

fun zip seq1 seq2
    | x::xs y::ys -> (x, y) :: zip xs ys
    | _ _ -> []
--------------------------------------------------

fun unzip l ->
    fun _unzip l seq1 seq2
        | (x, y) :: ts xs ys -> _unzip ts (x :: xs) (y :: ys)
        | [] xs ys -> (reverse xs, reverse ys)
    _unzip l [] []
--------------------------------------------------

fun zip3 s1 s2 s3
    | x::xs y::ys z::zs -> (x, y, z) :: zip3 xs ys zs
    | _ _ _ -> []
--------------------------------------------------

fun unzip3 l ->
    fun _unzip3 l acc_x acc_y acc_z
        | [(x, y, z), ...ts] xs ys zs -> _unzip3 ts (x::xs) (y::ys) (z::zs)
        | [] xs ys zs -> (reverse xs, reverse ys, reverse zs)
    _unzip3 l [] [] []

fun zipwith f seq1 seq2
    | f x::xs y::ys -> (f x y) :: zipwith f xs ys
    | _ _ _ -> []

fun zipwith3 f seq1 seq2 seq3
    | f x::xs y::ys z::zs -> (f x y z) :: zipwith3 f xs ys zs
    | _ _ _ _ -> []

fun split s
    | [] -> ([], [])
    | [x] -> (s, [])
    | x::y::xs ->
        (l, r) = split xs
        (x::l, y::r)

fun sort f s ->
    fun _merge s1 s2
        | [] ys -> ys
        | xs [] -> xs
        | x::xs y::ys ->
            if f x y -> x :: _merge xs (y::ys)
            else -> y :: _merge (x::xs) ys

    fun _sort s
        | [] -> []
        | [x] -> s
        | xs ->
            (ys, zs) = split xs
            _merge (_sort ys) (_sort zs)
    ---------

    _sort s

fun sort_asc s -> sort `<=` s
fun sort_desc s -> sort `>=` s

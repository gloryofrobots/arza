import from obin:lang:list (tail, head, cons as _cons, is_empty as _is_empty, empty as _empty, slice as _slice)
implement Eq for List end



//TRANSFORMERS///////////////////////////////////////////////////////

fun map f l
    | f [] -> []
    | f hd::tl -> (f hd) :: (map f tl)
----------------------------------------

fun foreach f l
    | f [] -> []
    | f hd::tl -> f hd; foreach f tl
----------------------------------------

fun intersperse f l
    | val [] -> []
    | val hd::tl  -> hd :: val :: (intersperse val tl)
--------------------------------------------------

fun reverse l ->
    fun _reverse l result
        | [] result -> result
        | hd::tl result -> (_reverse tl (hd :: result))
    ---------------

    _reverse l []
----------------------------------------

//REDUCERS///////////////////////////////////////////////////////

fun foldl func accumulator list
    | f acc [] -> acc
    | f acc hd::tl -> foldl f (f hd acc) tl
----------------------------------------

fun foldr func accumulator list
    | f acc [] -> acc
    | f acc hd::tl -> f hd (foldr f acc tl)
--------------------------------------------------

fun scanl func accumulator list
    | f acc [] -> acc::[]
    | f acc hd::tl -> acc :: (scanl f (f hd acc) tl)
--------------------------------------------------


///ACCESSORS//////////////////////////////////////

fun nth_tail count list
    | 0 l -> l
    | 1 [_, ...t] -> t
    | n [_, ...t] when n >= 0 -> nth_tail (n - 1) t
--------------------------------------------------

fun nth count list
    | 0 l -> l
    | 1 [h, ...t] -> h
    | n [h, ...t] when n >= 0 -> nth (n - 1) t
--------------------------------------------------

fun length l of List ->
    foldl lam _ acc -> acc + 1 end 0 l
--------------------------------------------------

//QUERIES///////////////////////////////////////////////////

fun prefix_of list1 list2
    | [hd, ...pre_tail] [hd, ...tail] -> prefix_of pre_tail tail
    | [] l -> True
    | [_, ..._] l -> False
--------------------------------------------------

fun suffix_of suf l  ->
   delta = (length l) - (length suf)
   tl = nth_tail delta l
   delta >= 0 and tl == suf
--------------------------------------------------

//SUBLISTS/////////////////////////////////////////////////////////////
fun drop count list
    | 0 l -> l
    | count hd::tl -> drop (count - 1) tl
--------------------------------------------------

fun take count list
    | 0 _ -> []
    | _ [] -> []
    | n [x, ...xs] -> x :: (take (n-1)  xs)
--------------------------------------------------

fun split_at (n of Int) (l of List) -> ((take n l), (drop n  l)) end

fun take_while predicate list
    | p [] -> []
    | p [x, ...xs] -> x :: (take_while p xs) in_case p x else []
--------------------------------------------------

fun drop_while predicate list
    | p [] -> []
    | p xs@[x, ...xs1] -> (drop_while p xs1) in_case p x else xs
--------------------------------------------------

fun filter predicate list
    | p [] -> []
    | p x::xs ->
        if p x ->
            x :: filter p xs
        else ->
            filter p xs
--------------------------------------------------

fun span predicate list
    | p [] -> ([], [])
    | p xs@[x, ...xs1] ->
        if not (p x) ->
            ([], xs)
        else ->
            (ys, zs) = (span p xs1)
            (x::ys, zs)
        ------------------------------
--------------------------------------------------

fun delete item list
    | item [item, ...xs] -> xs
    | item [x, ...xs] -> x :: (delete item xs)
    | _ [] -> []
--------------------------------------------------

////QUERIES//////////////////////////////////////////////////////////////////

fun conjunction l ->
    foldr lam v acc -> v and acc end True l end

fun disjunction l ->
    foldr lam v acc -> v or acc end False l end

fun any p l ->
    disjunction (map p l) end

fun all p l ->
    conjunction (map p l) end

fun element x l ->
    any lam v -> v == x end l end

fun contains l x ->
    element x l end

//BUILDERS/////////////////////////////////////////////////////////////

fun concat l1 l2 ->
    foldr (lam x y -> x :: y end) l2 l1 end

fun range (first of Int) (last of Int) ->
    step = -1 in_case last < 0 else 1
    range_by first last step
--------------------------------------------------

fun range_by (first of Int) (last of Int) (step of Int) ->
    fun _range_by N X D L
        | N X D L when N >= 4 ->
//            print "first"
            Y = X - D
            Z = Y - D
            W = Z - D
            _range_by (N - 4)  (W - D)  D  (W :: Z :: Y :: X :: L)

        | N X D L when N >= 2 ->
//            print "second"
            Y = X - D
            _range_by (N - 2) (Y - D) D (Y :: X :: L)

        | 1 X _ L ->
//            print "third"
            X :: L

        | 0 _ _ L ->
//            print "fourth"
            L
    --------------------------------------------------

    if step > 0 and first - step <= last or
            step < 0 and first - step >= last ->

        n = ((last - first + step) / step) - 1
//        print n
//        print "RANGE BY" first last step n
//        print n (step * (n - 1) + first) step []
//        print n (1 + 2 / 3 - 1) 2 3
        _range_by n (step * (n - 1) + first) step []

    elif step == 0 and first == last ->
        _range_by 1  first step []
    else ->
        throw (#InvalidRange, first, last, step)
--------------------------------------------------

fun last list
    | [x, ...xs] ->
        fun _last hd tl
            | _ [x, ...xs] -> _last x xs
            | x [] -> x
        ------------

        _last x xs
--------------------------------------------------

fun uncons list | [x, ...xs] -> (x, xs) end

fun init list
    | [x] -> []
    | [x, ...xs] -> x :: (init xs)
    | [] -> throw (ValueError "empty list in init")
------------------------------

fun replicate count element ->
    if count >= 0 ->
        fun _replicate n x result
            | 0 _ l -> l
            | n x l -> _replicate (n - 1) x (x :: l)
        -------------

        _replicate count element []
    else ->
        throw ValueError count
    --------------------------------
---------------------------------------------------

//TRAITS

implement Seq for List
    def first self -> head self
    def rest self -> tail self
    def cons value self -> _cons value self
    def empty self -> []
--------------------------------------------------

implement Seqable for List
    def seq self -> self
--------------------------------------------------


implement Collection for List
    def len self -> length
    def is_empty self -> _is_empty self
    def put key value self -> False
    def at key self -> False
    def del obj self -> False
    def elem key self -> False
---------------------------------

implement Sliceable for List
    def slice first last self -> _slice first last self
    def drop count self -> drop count self
    def take count self -> take count self
---------------------------------

from obin:lang:_lazy import (is_forced)
import derive
import io
import seq

type LazyList
    | LazyCons head tail
    | LazyNil

extend LazyList
    use derive:TCollection

    def first self -> self.head
    def rest self -> !self.tail

    def str
        | [] -> "[]"
        | self ->
            fun folder l
                | [] -> ""
                | l ->
                    //can't do pattern matching because rest method force lazy value to evaluate
                    x = l.head
                    xs = l.tail

                    if kindof xs LazyVal then
                        if  not (is_forced xs) then
                            ", ..."
                        else
                            ", " ++ str x ++ folder (!xs)
                    else
                        ", " ++ str x ++ folder (xs)
            end

            "[" ++ (str self.head) ++ folder !self.tail ++ "]"

    def to_seq self -> self

    def len self -> throw NotImplementedError ("len not defined for LazyList",)

    def is_empty
        | self of LazyNil -> True
        | _ -> False

    def empty self -> LazyNil

    def cons value self -> LazyCons value self

    def ! self -> self

    def == self other -> seq:equal self other


extend LazyVal
    def ! self -> self ()

    def cons value self ->
            LazyCons value self

    def str self -> "<delayed>"


type Empty
type ListGenerator val fn

extend ListGenerator
    def to_seq self -> self

    def first self -> self.val

    def rest self ->
            try
                ListGenerator (self.fn ()) self.fn
            catch e of Interrupt ->
                ListGenerator (Empty) self.fn

    def len self -> NotImplementedError len

    def is_empty self -> self.val == Empty

    def empty self -> []

fun list_generator fn ->
    val = fn ()
    ListGenerator val fn

////////////////////////////////////////////////////////////////////////////////////////////
//SEQ FUNCS                                         ///////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////////////////
//REDUCERS///////////////////////////////////////////////////////
fun foldl f acc coll
    | f acc [] -> acc
    | f acc hd::tl -> foldl f (f hd acc) tl
--------------------------------------------------


fun foldr func accumulator coll
    | f acc [] -> acc
    | f acc hd::tl -> f hd (foldr f acc tl)
--------------------------------------------------

fun scanl func accumulator coll
    | f acc [] -> acc ::: (empty coll)
    | f acc hd::tl -> acc ::: (scanl f (f hd acc) tl)
--------------------------------------------------

//LOOPS ////////////////////////

fun map f coll
    | f [] -> empty coll
    | f hd::tl -> (f hd) ::: (map f tl)
----------------------------------------

fun intersperse val coll
    | val [] -> empty coll
    | val hd::tl  -> hd :: val ::: (intersperse val tl)
--------------------------------------------------

fun doall coll ->
    fun walk _coll
        | [] -> coll
        | hd::tl -> walk tl

    walk coll
----------------------------------------


///ACCESSORS//////////////////////////////////////

fun nth_tail (count of Int) coll
    | 0 l -> l
    | 1 [_, ...t] -> t
    | n [_, ...t] when n >= 0 -> nth_tail (n - 1) t
--------------------------------------------------

fun nth (count of Int) coll
    | 0 l -> l
    | 1 [h, ...t] -> h
    | n [h, ...t] when n >= 0 -> nth (n - 1) t
--------------------------------------------------

//QUERIES///////////////////////////////////////////////////

fun length l of List ->
    foldl (_ acc => acc + 1) 0 l
--------------------------------------------------

fun last coll
    | [x, ...xs] ->
        fun _last hd tl
            | _ [x, ...xs] -> _last x xs
            | x [] -> x
        ------------

        _last x xs
--------------------------------------------------


fun prefix_of coll1 coll2
    | [hd, ...pre_tail] [hd, ...tail] -> prefix_of pre_tail tail
    | [] s -> True
    | [_, ..._] s -> False
--------------------------------------------------

fun suffix_of suf s  ->
   delta = (len s) - (len suf)
   tl = nth_tail delta s
   delta >= 0 and tl == suf
--------------------------------------------------

//SUBLISTS/////////////////////////////////////////////////////////////
fun drop count coll
    | 0 l -> l
    | count hd::tl -> drop (count - 1) tl
--------------------------------------------------

fun take count coll
    | 0 _ -> empty coll
    | _ [] -> empty coll
    | n [x, ...xs] -> x ::: (take (n - 1)  xs)
--------------------------------------------------

fun split_at (n of Int) l -> ((take n l), (drop n l)) end

fun take_while predicate coll
    | p [] -> empty coll
    | p [x, ...xs] -> if p x then x ::: (take_while p xs) else empty coll
--------------------------------------------------

fun drop_while predicate coll
    | p [] -> empty coll
    | p xs@[x, ...xs1] -> if p x then (drop_while p xs1) else xs
--------------------------------------------------

fun filter predicate coll
    | p [] -> empty coll
    | p x::xs ->
        if p x then
            x ::: filter p xs
        else
            filter p xs
--------------------------------------------------

fun span predicate coll
    | p [] ->
        c = empty coll
        (c, c)
    | p xs@[x, ...xs1] ->
        if not (p x) then
            (empty coll, xs)
        else
            (ys, zs) = (span p xs1)
            (x:::ys, zs)
        ------------------------------
--------------------------------------------------

fun delete item coll
    | item [item, ...xs] -> xs
    | item [x, ...xs] -> x ::: (delete item xs)
    | _ [] -> empty coll
--------------------------------------------------

fun insert index v coll
    | 0 v coll -> v:::coll
    | i v [] -> throw IndexError ("Invalid insertion index", index, v)
    | i v x::xs -> x ::: (insert (i - 1) v xs)

fun append v coll ->
    insert (length coll) v coll

////QUERIES//////////////////////////////////////////////////////////////////

fun conjunction l ->
    foldr (v acc => v and acc) True l end

fun disjunction l ->
    foldr (v acc => v or acc) False l end

fun any p l ->
    disjunction (map p l) end

fun all p l ->
    conjunction (map p l) end

fun element x l ->
    any (v => v == x) l end

fun contains l x ->
    element x l end

//BUILDERS/////////////////////////////////////////////////////////////

fun concat l1 l2 ->
    foldr (x y => x ::: y) l2 l1 end

fun uncons coll | [x, ...xs] -> (x, xs) end

fun init coll
    | [x] -> empty coll
    | [x, ...xs] -> x ::: (init xs)
    | [] -> throw (ValueError "empty seq in init")
------------------------------


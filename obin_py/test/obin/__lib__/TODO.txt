deep calls in datastructs data -> (1, record) == (1, record) NotIImplementedError in record._equal_(record)
 we need to put process in every api call it is very very big annoying job/ it is better to rewrite all interpreter in
 with this in mind
--------------------------------------------------

THINK ABOUT DEFAULT VALUES
--------------------------------

MAKE {} SYNTAX IN FIELDS AND CONSTRUCTING WITH KEYWORD ARGS
--------------------------------

RANGES
------------

Rangeable and Bounded for union
--------------------------------------------------

PROPER OR CASES
 match x with
    | 1 | 2 | 3 -> printfn "Found 1, 2, or 3!"
    | a -> printfn "%d" a

-----------------------------

MACROS
a lot of work and i dont know how to do it exactly
----------------------------------------------------

ERRORS
--------------------------

META
------------------------

REMOVE VOIDS AS VALUES IN DATASTRUCTS
----------------------

SEPARATE TOKEN STREAMS
--------------------------------------------------

ADD A WAY TO INTERRUPT SEQ LOOPS
--------------------------------------------------

SINGLE PASS AND DEF, MAYBE
-------------------


PATTERN_MATCH_ERRORS as ERRORS NOT TUPLES
--------------------------------------------------
NESTED BLOCK COMMENTS
--------------------------------------------------
PAREN is MISSING but we got NOT ALL LAYOUT IS CLOSED  error
    print (ts:into [] (ts:map lam x ->
                                    if x > 4 ->
                                        ts:reduced x
                                    else ->
                                        x
                              end) l

SINGLE VALUE ASSIGNMENT SUPPORT IN COMPILER
CAN`T DO THAT YOU LOOSE YOUR match semantics
x=1; x=1; x=2->error
INSTEAD determine if it first assignment or it needs check
--------------------------------

COMPILE FUNCTION CLAUSES INTO MATCH INSTEAD OF FUNC
--------------------------------


REMOVE NT_WHEN AFTER REFACTORING PATTERN COMPILER
--------------------------------
ADD SUPPORT FOR | IN TRAIT STATEMENT DEFS
--------------------------------

FIXME
this is error prone code, currently branches not merged because
distinction goes with variable names and a1 != b1

match (1,2)
    | a1 -> a1.0
    | b1 -> a1.1

--------------------------------

trait Any for self
    def id self -> obin:unique_id self
    def type_id self -> obin:type_id self
---

fun is_identical self other -> (id self) == (id other)




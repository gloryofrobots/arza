fun span predicate list
    | p [] -> ([], [])
    | p xs@[x, ...xs1] ->
        if not (p x) -> ([], xs)
        else ->
            (ys, zs) = (span p xs1)
            (x::ys, zs)

//fun span predicate list
//    | p [] -> ([], []);
//    | p xs@[x, ...xs1] ->
//        if not (p x) -> ([], xs);
//        else ->
//            (ys, zs) = (span p xs1);
//            (x::ys, zs);
//        end
//end
//import from obin:core:types (Bool, Char, Int, Float, Symbol, String, List, Vector, Tuple, Map,
//                             Function, Generic, Method, NativeFunction, Fiber, Trait, Datatype, TVar, Env)

//type Nothing
//
//type Value val
//
//type Shape
//    | X x
//    | Y y
//    | Point x y
//    | Square width height
//    | Rect left top right bottom
//    | Line point1 point2
//    | Empty

fun span predicate list
    | p [] -> ([], [])
    | p xs@[x, ...xs1] ->
        if not (p x) -> ([], xs)
        else ->
            (ys, zs) = (span p xs1)
            (x::ys, zs)

fun span predicate list
    | p [] -> ([], []);
    | p xs@[x, ...xs1] ->
        if not (p x) -> ([], xs);
        else ->
            (ys, zs) = (span p xs1);
            (x::ys, zs);
        end
end

fun split_at (n of Int) (l of List) -> ((take n l), (drop n  l))

////fun f3 () -> 42 end
//
//fun f5 (a1 a2 a3 a4 . a5 ...rest)
//    | x (y,z) a b {name=name, age=(years, month)} _ ->
//        (x, y, z, a, b, name, years, month, rest)
//--------------------------------------------------------
////
////
//fun func1 a1 a2 a3 a4 a5 a6 a7 a8 ...a9
//    | 1 2 3 4 5 var0 var1 var2 var4 -> (var0, var1, var2, var4)
//    | _ _ _ _ _ _ _ {key1, var1 @ key2, key3=25}  ([var2, #second, var3 @ #third, ...var4]) ->
//        (var1, var2, var3, var4)
//------------------------------
//
//fun fn_fail arg
//    | 1 -> #one
//    | 2 -> #two
//    | 3 -> #three
//    | 4 -> #four
//--------------------
//
//
//fun ++++/ () -> 42 end
//fun ++>> x y -> 42 end
//fun ++-+ x y -> 42 end
//fun ++---^--^ x y
//    | x y -> 42 end
//



//fun t  x . y ->
//    f 331 332 334 .
//      (g 441 442 .
//         443 444) . 551 . 552 553 .
//       554
//end

//type Ordering
//    | LT | GT | EQ
//------------------

//trait Collection for self
//    def len self
//    def is_empty self
//    def put key value self
//    def at key seslf
//    def del obj self
//    def elem key self
//---------------------------------
//
//trait Eq for x
//    def == x y -> throw (#NotImplemented, x, y)
//    def != x y -> not (x == y)
//---------------------------------
//
//trait Ord  for x of Eq
//    def <= x y -> throw (#NotImplemented, x, y)
//    def < x y -> (cmp x y) == LT
//    def >= x y -> (cmp x y) != LT
//    def > x y -> (cmp x y) == GT
//
//    def cmp x y ->
//                if x == y -> EQ
//                elif x <= y -> LT
//                else -> GT
//                --------------
//
//    def max x y ->  y in_case x <= y else x
//    def min x y -> x in_case x <= y else y
//---------------------------------
//
//trait Num for x
//    def - x y
//    def + x y
//    def * x y
//    def / x y
//    def mod x y
//    // unary -
//    def negate x
//---------------
//
//trait Str for self
//    def str self
//---
//
////YOU need kinds here
////trait FromStr for self of ToStr
////    def from_str self
////---
//
//trait Inspectable for self of (Str, Eq)
//    def inspect self -> str self
//---
//
//trait Mappable for self
//    def map f self
//---
//
//trait Appendable for self
//    //concat operator
//    def ++ self other
//    def append self value
//---------------------------------
//
//
//trait Dict for self of Collection
//    def keys self
//    def values self
//------
//
//trait Seq for self
//    def first self
//    def rest self
//    // prepend/cons operator
//    def cons  value self
//    def empty self
//---
//
//trait Indexed for self
//    def index_of obj self
//---
//
//trait Seqable for self
//    def seq self
//---
//
//trait Sliceable for self
//    def slice first . last . self
//    def drop count self
//    def take count self
//---
//
////ERRORS
////TODO MAKE THIS DECLARATION ONE MACRO
//type ImportError args end
//type RuntimeError args end
//type TypeError args end
//type NotImplementedError args end
//type ZeroDivisionError args end
//type ReferenceError args end
//type ConstructorError args end
//type KeyError args end
//type ValueError args end
//type SliceError args end
//type IndexError args end
//type InvokeError args end
//type InvalidArgCount args end
//type MethodInvokeError args end
//type MethodNotImplementedError args end
//type MethodSpecializeError args end
//type CompileError args end
//type ParseError args end
//type UnpackSequenceError args end
//type FiberFlowError args end
//type MatchError args end
//type FunctionArgumentsMatchError args end
//type ExceptionMatchError args end
//type ExportError args end
//type TraitAlreadyImplementedError args end
//type TraitImplementationError args end
//type TraitConstraintError args end
//
////FUNS
//fun lookup key default coll ->
//    try
//        at key coll
//    catch
//        | e of KeyError -> default
//        | e -> throw e
//    ---------------
//---
//
//fun not_elem x c -> not (elem x c) end
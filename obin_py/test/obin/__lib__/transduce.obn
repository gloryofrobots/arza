import from var (var)

trait Transformer for self
    def init self
    def result self res
    def step self res input

type WrapTransformer fn

implement Transformer for WrapTransformer
    def init self -> throw NotImplementedError #init
    def result self acc -> acc
    def step self input acc -> self.fn input acc

fun wrap f
    | f of Transformer -> f
    | f -> WrapTransformer f

type Reduced value

fun reduced x -> Reduced x

fun is_reduced val
    | val of Reduced -> True
    | _ -> False

fun ensure_reduced x
    | val of Reduced -> val
    | val -> Reduced val

fun deref r of Reduced -> r.value

fun unreduced x
    | r of Reduced -> deref r
    | r -> r

fun reduce_seq xf acc coll ->
    fun _reduce xf acc coll
        | xf acc [] ->
            acc
        | xf acc hd::tl ->
            acc1 = step xf hd acc
            if is_reduced acc1 ->
                deref acc1
            else ->
                _reduce xf acc1 tl
    res = _reduce xf acc coll
    result xf res

//
//Given a transducer, a builder function, an initial value
// and a iterable collection - returns the reduction.

fun transduce xf f init_val coll ->
    reduce reduce_seq xf f init_val coll

fun reduce reduce_fun xf f init_val coll ->
    fn = wrap f
    xf1 = xf fn
    reduce_fun xf1 init_val coll

fun into init_val xf coll ->
    f = match init_val with
            | x of Appendable -> append
            | x of Seq -> lam x acc -> x::acc
            | x of Dict ->
                lam entry coll
                    | (key, val) coll -> put key val coll

    transduce xf f init_val coll


//  Convert a transducer transformer object into a function so
//  that it can be used with existing reduce implementation i.e. native,
//  xf = ts:map inc >> ts:filter even
//  xf_fn = ts:to_fun xf cons
//  affirm:is_equal (seq:foldl xf_fn [] [1,2,3,4]) [5, 3]

fun to_fun xf builder
   | xf builder of Transformer ->
      rxf = xf(builder)
      lam val acc -> step rxf val acc
   | xf builder -> to_fun xf (wrap builder)

fun first () ->
    wrap lam val acc -> reduced val end

type MapTransformer f xf

implement Transformer for MapTransformer
    def init self -> init self.xf
    def result self acc -> result self.xf acc
    def step self val acc ->
//        print "MAP STEP"
        step self.xf (self.f val) acc

fun map f xf -> MapTransformer f xf

-------------------------------------------

type FilterTransformer predicate xf

implement Transformer for FilterTransformer
    def init self -> init self.xf
    def result self acc -> result self.xf acc
    def step self val acc ->
//        print "FILTER STEP"
        if self.predicate val ->
            step self.xf val acc
        else ->
            acc

fun filter predicate xf -> FilterTransformer predicate xf

// Similar to filter except the predicate is used to
// eliminate values.
fun remove predicate xf -> filter (not << predicate) xf

type CompletingTransformer cf xf

implement Transformer for CompletingTransformer
    def init self -> init self.xf
    def result self acc -> self.cf acc
    def step self val acc -> step self.xf val acc
//
///
// A completing transducer constructor. Useful to provide cleanup
// logic at the end of a reduction/transduction.
fun completing cf xf -> CompletingTransformer cf xf


type TakeTransformer n xf

implement Transformer for TakeTransformer
    def init self -> init self.xf
    def result self acc -> result self.xf acc
    def step self val acc ->
        n = !self.n
        self.n := n - 1
        if n > 0 ->
           step self.xf val acc
        else ->
           ensure_reduced acc

// A take transducer constructor. Will take n values before
// returning a reduced result.
fun take n xf -> TakeTransformer (var n) xf

type TakeWhileTransformer predicate xf

implement Transformer for TakeWhileTransformer
    def init self -> init self.xf
    def result self acc -> result self.xf acc
    def step self val acc ->
        if self.predicate val ->
           step self.xf val acc
        else ->
            reduced acc

// Like the take transducer except takes as long as the pred
// return true for inputs.
fun take_while p xf -> TakeWhileTransformer p xf

type TakeNthTransformer i n xf

implement Transformer for TakeNthTransformer
    def init self -> init self.xf
    def result self acc -> result self.xf acc
    def step self val acc ->
        self.i := !self.i + 1

        if mod (!self.i) self.n == 0  ->
           step self.xf val acc
        else ->
            acc

// A transducer that takes every Nth input
fun take_nth n xf -> TakeNthTransformer (var (-1)) n xf

type DropTransformer n xf

implement Transformer for DropTransformer
    def init self -> init self.xf
    def result self acc -> result self.xf acc
    def step self val acc ->
        n = !self.n
        if n > 0 ->
            self.n := n - 1
            acc
        else ->
           step self.xf val acc

// A dropping transducer constructor
fun drop n xf -> DropTransformer (var n) xf

type DropWhileTransformer continue_dropping predicate xf

implement Transformer for DropWhileTransformer
    def init self -> init self.xf
    def result self acc -> result self.xf acc
    def step self val acc ->
        if !self.continue_dropping and self.predicate val ->
            acc
        else ->
            self.continue_dropping := False
            step self.xf val acc

// A dropping transducer that drop inputs as long as
// pred is true.
fun drop_while predicate xf -> DropWhileTransformer (var True) predicate xf

//
///
// @constructor
// @implements {com.cognitect.transducers.ITransformer}
///
//transducers.KeepIndexed = function(f, xf) {
//    this.i = -1;
//    this.f = f;
//    this.xf = xf;
//};
//transducers.KeepIndexed.prototype["@@transducer/init"] = function() {
//    return this.xf["@@transducer/init"]();
//};
//transducers.KeepIndexed.prototype["@@transducer/result"] = function(result) {
//    return this.xf["@@transducer/result"](result);
//};
//transducers.KeepIndexed.prototype["@@transducer/step"] = function(result, input) {
//    this.i++;
//    var v = this.f(this.i, input);
//    if(v == null) {
//        return result;
//    } else {
//        return this.xf["@@transducer/step"](result, input);
//    }
//};
//
///
// Like keep but the provided function will be passed the
// index as the first argument and the value second.
// @method transducers.keepIndexed
// @param {Function} f a function
// @return {com.cognitect.transducers.KeepIndexed} a keepIndexed transducer
// @example
//     var t = transducers;
//     var xf = t.keepIndexed(function(i, x) { if(typeof x == "string") return "cool"; });
//     t.into([], xf, [0,1,"foo",3,4,"bar"]); // ["foo","bar"]
///
//transducers.keepIndexed = function(f) {
//    if(TRANSDUCERS_DEV && (typeof f != "function")) {
//        throw new Error("keepIndexed must be given a function");
//    } else {
//        return function(xf) {
//            return new transducers.KeepIndexed(f, xf);
//        };
//    }
//};
//
///
// Given a transformer returns a transformer which preserves
// reduced by wrapping one more time. See cat.
// @method transducers.preservingReduced
// @param {com.cognitect.transducers.ITransformer} xf a transformer
// @return {com.cognitect.transducers.ITransformer} a transformer which preserves reduced
///
//transducers.preservingReduced = function(xf) {
//    return {
//        "@@transducer/init": function() {
//            return xf["@@transducer/init"]();
//        },
//        "@@transducer/result": function(result) {
//            return result;
//        },
//        "@@transducer/step": function(result, input) {
//            var ret = xf["@@transducer/step"](result, input);
//            if(transducers.isReduced(ret)) {
//                return transducers.reduced(ret);
//            } else {
//                return ret;
//            }
//        }
//    };
//};
//
///
// Given a transformer return a concatenating transformer
// @method transducers.cat
// @param {com.cognitect.transducers.ITransformer} xf a transformer
// @return {com.cognitect.transducers.ITransformer} a concatenating transformer
///
//transducers.cat = function(xf) {
//    var rxf = transducers.preservingReduced(xf);
//    return {
//        "@@transducer/init": function() {
//            return xf["@@transducer/init"]();
//        },
//        "@@transducer/result": function(result) {
//            return xf["@@transducer/result"](result);
//        },
//        "@@transducer/step": function(result, input) {
//            return transducers.reduce(rxf, result, input);
//        }
//    };
//};
//
///
// A mapping concatenating transformer
// @method transducers.mapcat
// @param {Function} f the mapping function
// @return {com.cognitect.transducers.ITransformer} a mapping concatenating transducer
// @example
//     var t = transducers;
//     var reverse = function(arr) { var arr = Array.prototype.slice.call(arr, 0); arr.reverse(); return arr; }
//     var xf = t.mapcat(reverse);
//     t.into([], xf, [[3,2,1],[6,5,4]]); // [1,2,3,4,5,6]
///
//transducers.mapcat = function(f) {
//    return transducers.comp(transducers.map(f), transducers.cat);
//};

derive Dict for (Reduced, MapTransformer, FilterTransformer, WrapTransformer,
                 CompletingTransformer, TakeTransformer, TakeWhileTransformer,
                 TakeNthTransformer, DropTransformer, DropWhileTransformer)

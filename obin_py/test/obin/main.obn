import affirm
//import tests:test_operators

//import tests:types:test_types
//import tests:test_partial
//import tests:test_co
//import tests:test_destruct
//import tests:test_exception
//import tests:test_modify
//import tests:test_operator_override
//import tests:test_module
//import tests:test_match
//import tests:test_base
//import tests:test_bool
//import tests:test_static_refs
//import tests:test_fun
//import tests:test_var
//import tests:datastructs:test_datastructs
//import tests:test_iter


fun log ...msgs ->
    if True ->
        apply print msgs
    else ->
        ()

fun test() ->
    log "RUN TESTS"

//    log "TEST TYPES"
//    test_types:test()
//    log "TEST PARTIAL"
//    test_partial:test()
//    log "TEST BOOL"
//    test_bool:test()
//    log "TEST MATCH"
//    test_match:test()
//    log "TEST BASE"
//    test_base:test()
//    log "TEST DESTRUCT"
//    test_destruct:test()
//    log "TEST STATIC REFS"
//    test_static_refs:test()
//    log "TEST CO"
//    test_co:test()
//    log "TEST EXCEPTION"
//    test_exception:test()
//    log "TEST MODIFY"
//    test_modify:test()
//    log "TEST OP OVERRIDE"
//    test_operator_override:test()
//    log "TEST MODULE"
//    test_module:test()
//    log "TEST FUN"
//    test_fun:test()
//    log "TEST VAR"
//    test_var:test()
//    log "TEST DATASTRUCTS"
//    test_datastructs:test()
//    log "TEST ITER"
//    test_iter:test()

//    log "TEST OPERATORS"
//    test_operators:test()

fun sqr n -> print "sqr" n; n * n

type LazyList first rest
extend LazyList
    with Seq
        def first self -> self.first
        def rest self ->
fun squares n -> sqr n :: lazy

(defn squares
  ([n] (cons (mysqr n) (lazy-seq (squares (inc n))))))
;; => #'user/squares

(def sqrs (squares 1))
;; => mysqr  <-- NOTE THAT mysqr WAS CALLED WHEN WE SIMPLY REQUESTED COLLECTION
;; => #'user/sqrs

(take 1 sqrs)
;; => (1) <-- HERE WE ARE GETTING FIRST ELEMENT THAT WAS CALCULATED BEFORE

;; Now let's redefine 'squares' by wrapping its entire body in lazy-seq:
(defn squares
  ([n] (lazy-seq (cons (mysqr n) (squares (inc n))))))
;; => #'user/squares

;; And when we request the collection:
(def sqrs (squares 1))
;; => #'user/sqrs
;; NOTE THAT mysqr WAS NOT CALLED HERE

(take 1 sqrs)
;; => mysqr <- AND HERE mysqr IS CALLED WHEN FIRST ELEMENT IS ACTUALLY REQUESTED
;; => (1)
fun stream fn ->


fun main () ->
    l = lazyval lam () -> 42 end
    print (l ())
    print (l ())
    print (l ())

    test()


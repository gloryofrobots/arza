//import affirm
//import tests:test_operators

//import tests:types:test_types
//import tests:test_co
//import tests:test_destruct
//import tests:test_exception
//import tests:test_modify
//import tests:test_operator_override
//import tests:test_module
//import tests:test_match
//import tests:test_base
//import tests:test_bool
//import tests:test_static_refs
//import tests:test_fun
//import tests:datastructs:test_datastructs


//fun log ...msgs ->
//    if True ->
//        apply print msgs
//    else ->
//        ()
//
//fun test() ->
//    log "RUN TESTS"
//
//    log "TEST TYPES"
//    test_types:test()
//    log "TEST BOOL"
//    test_bool:test()
//    log "TEST DATASTRUCTS"
//    test_datastructs:test()
//    log "TEST MATCH"
//    test_match:test()
//    log "TEST BASE"
//    test_base:test()
//    log "TEST DESTRUCT"
//    test_destruct:test()
//    log "TEST STATIC REFS"
//    test_static_refs:test()
//    log "TEST CO"
//    test_co:test()
//    log "TEST EXCEPTION"
//    test_exception:test()
//    log "TEST MODIFY"
//    test_modify:test()
//    log "TEST OP OVERRIDE"
//    test_operator_override:test()
//    log "TEST MODULE"
//    test_module:test()
//    log "TEST FUN"
//    test_fun:test()
//
////    log "TEST OPERATORS"
////    test_operators:test()
import list

infixl |> |> 11
fun |> x f -> f x

infixl <| <| 10
fun <| f x -> f x


infixl >> >> 12
fun >> f g ->
    fun compose_right f g x -> g ( f(x) )

    &compose_right f g
---------------

infixl << << 12
fun << f g ->
    fun compose f g x -> f (g x)

    &compose f g
---------------

fun ~ f x -> f x

fun add x y -> x + y
fun mul x y -> x * y
fun not_i x
    | 0 -> 0
    | _ -> 1

fun one () -> 1

fun twice f -> &f >> &f


fun flip f ->
    lam x y -> f y x

fun even x -> mod x 2 == 0
fun odd x -> not (even x)

fun main () ->
    filter = list:filter
    map = list:map
    l = list:range 0 10
    print l
    sub = flip (&-)
    square = lam x -> x * x
    triple = &* 3
    l1 =
        l |> &filter even
          |> &map (&add 1)
          |> &map (&sub 2)
          |> &map (triple >> square)


    print l1
//    gt = flip (&>)
//    gt_3 = &gt 3
//
//    print <| gt_3 2
//    print <| gt_3 3
//    print <| gt_3 4
//
//    print <| 8 `mod` 2
//    print <| 8 `mod` 3
//
//    add1_mul2 = &add 1 >> &mul 2
//    print (add1_mul2 4)
//    print <| add1_mul2 4
//
//    mul2_add1 = &add 1 << &mul 2
//    print (mul2_add1 4)
//
//
//    add_1_twice = twice (&add 1)
//    print (add_1_twice 9)



//    print (add_1 3)
//    print (add_1 4)
//    print 1 2
//    test()


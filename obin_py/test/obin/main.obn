import affirm
//import tests:test_operators

//import tests:types:test_types
//import tests:test_partial
//import tests:test_co
//import tests:test_destruct
//import tests:test_exception
//import tests:test_modify
//import tests:test_operator_override
//import tests:test_module
//import tests:test_match
//import tests:test_base
//import tests:test_bool
//import tests:test_static_refs
//import tests:test_fun
//import tests:test_var
//import tests:datastructs:test_datastructs
//import tests:test_iter


fun log ...msgs ->
    if True ->
        apply print msgs
    else ->
        ()

fun test() ->
    log "RUN TESTS"

//    log "TEST TYPES"
//    test_types:test()
//    log "TEST PARTIAL"
//    test_partial:test()
//    log "TEST BOOL"
//    test_bool:test()
//    log "TEST MATCH"
//    test_match:test()
//    log "TEST BASE"
//    test_base:test()
//    log "TEST DESTRUCT"
//    test_destruct:test()
//    log "TEST STATIC REFS"
//    test_static_refs:test()
//    log "TEST CO"
//    test_co:test()
//    log "TEST EXCEPTION"
//    test_exception:test()
//    log "TEST MODIFY"
//    test_modify:test()
//    log "TEST OP OVERRIDE"
//    test_operator_override:test()
//    log "TEST MODULE"
//    test_module:test()
//    log "TEST FUN"
//    test_fun:test()
//    log "TEST VAR"
//    test_var:test()
//    log "TEST DATASTRUCTS"
//    test_datastructs:test()
//    log "TEST ITER"
//    test_iter:test()

//    log "TEST OPERATORS"
//    test_operators:test()


type LazyList
    | LazyCons head tail
    | LazyNil

extend LazyList
    with Seq
        def first self ->
            match self with
                | x of LazyNil -> throw NotImplementedError (first, self)
                | x of LazyCons -> self.head

        def rest self ->
            match self with
                | x of LazyNil -> throw NotImplementedError (rest, self)
                | x of LazyCons -> !self.tail
    with Seqable
        def to_seq self -> self
    with Sized
        def len self -> throw NotImplementedError (len, self)
        def is_empty self ->
            match self with
                    | x of LazyNil -> True
                    | x of LazyCons -> False
    with Constructable
        def cons val self ->
            LazyCons val self
    with Emptiable
        def empty self ->
            print "EMPTY " self
            LazyNil
//
fun lcons val fn ->
    LazyCons val (lazyval fn)
//
fun sqr n -> print "sqr" n (n * n); n * n

fun squares n -> lcons (sqr n) lam () -> squares (n + 1)
//
import seq
import io


fun main () ->
//    l = lazyval lam () -> 42 end
//    print (l ())
//    print (l ())
//    print (l ())
//    sqrs = squares 1
//    print "TAKE" (seq:take 4 sqrs)
//    print "TAKE2" (seq:take 5 sqrs)
    io:p 1 2 "#3" [1,2,3,4,5]

//    test()

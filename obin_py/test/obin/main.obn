import io
import affirm
import tests:test_operators

import tests:types:test_types
import tests:test_partial
import tests:test_co
import tests:test_destruct
import tests:test_exception
import tests:test_modify
import tests:test_operator_override
import tests:test_module
import tests:test_match
import tests:test_base
import tests:test_bool
import tests:test_static_refs
import tests:test_fun
import tests:test_var
import tests:datastructs:test_datastructs
import tests:test_iter


fun log ...msgs ->
    if True ->
        apply io:print msgs
    else ->
        ()

fun test() ->
    log "RUN TESTS"

    log "TEST TYPES"
    test_types:test()
    log "TEST PARTIAL"
    test_partial:test()
    log "TEST BOOL"
    test_bool:test()
    log "TEST MATCH"
    test_match:test()
    log "TEST BASE"
    test_base:test()
    log "TEST DESTRUCT"
    test_destruct:test()
    log "TEST STATIC REFS"
    test_static_refs:test()
    log "TEST CO"
    test_co:test()
    log "TEST EXCEPTION"
    test_exception:test()
    log "TEST MODIFY"
    test_modify:test()
    log "TEST OP OVERRIDE"
    test_operator_override:test()
    log "TEST MODULE"
    test_module:test()
    log "TEST FUN"
    test_fun:test()
    log "TEST VAR"
    test_var:test()
    log "TEST DATASTRUCTS"
    test_datastructs:test()
    log "TEST ITER"
    test_iter:test()

    log "TEST OPERATORS"
    test_operators:test()


type LazyList
    | LazyCons head tail
    | LazyNil

extend LazyList
    with Seq
        def first self ->
            match self with
                | x of LazyNil -> throw NotImplementedError (first, self)
                | x of LazyCons -> self.head

        def rest self ->
            match self with
                | x of LazyNil -> throw NotImplementedError (rest, self)
                | x of LazyCons -> !self.tail
    with Seqable
        def to_seq self -> self
    with Sized
        def len self -> throw NotImplementedError (len, self)
        def is_empty self ->
            match self with
                    | x of LazyNil -> True
                    | x of LazyCons -> False
    with Constructable
        def cons val self ->
            LazyCons val self
    with Emptiable
        def empty self ->
            io:print "EMPTY " self
            LazyNil
//
fun lcons val fn ->
    LazyCons val (lazyval fn)
//
fun sqr n -> io:print "sqr" n (n * n); n * n

fun squares n -> lcons (sqr n) lam () -> squares (n + 1)
//
import seq
import io


fun main () ->
//    l = lazyval lam () -> 42 end
//    io:print (l ())
//    io:print (l ())
//    io:print (l ())
//    sqrs = squares 1
//    io:print "TAKE" (seq:take 4 sqrs)
//    io:print "TAKE2" (seq:take 5 sqrs)
//    io:print 1 2 "#3" [1,2,3,4,5]

//    affirm:is_throw_expected (lam x -> 1 or 0 end) () (TypeError ("Bool expected", 1))
    test()

__author__ = 'gloryofrobots'
from obin.builtins.internals.operations import *
from obin.runtime.routine import complete_native_routine
from obin.runtime import error
from obin.types import api, space
from obin.types.space import newtuple, isnumber, isint, isentity


def setup(process, module, stdlib):
    # AUTOGENERATED operators_gen.py
    api.put_native_function(process, module, u"___is", ___is, 2)
    api.put_native_function(process, module, u"___ne", ___ne, 2)
    api.put_native_function(process, module, u"___eq", ___eq, 2)
    api.put_native_function(process, module, u"___not", ___not, 1)
    api.put_native_function(process, module, u"___isnot", ___isnot, 2)
    api.put_native_function(process, module, u"___in", ___in, 2)
    api.put_native_function(process, module, u"___add", ___add, 2)
    api.put_native_function(process, module, u"___mod", ___mod, 2)
    api.put_native_function(process, module, u"___mul", ___mul, 2)
    api.put_native_function(process, module, u"___div", ___div, 2)
    api.put_native_function(process, module, u"___sub", ___sub, 2)
    api.put_native_function(process, module, u"___uminus", ___uminus, 1)
    api.put_native_function(process, module, u"___uplus", ___uplus, 1)
    api.put_native_function(process, module, u"___ge", ___ge, 2)
    api.put_native_function(process, module, u"___gt", ___gt, 2)
    api.put_native_function(process, module, u"___lt", ___lt, 2)
    api.put_native_function(process, module, u"___le", ___le, 2)
    api.put_native_function(process, module, u"___bitnot", ___bitnot, 1)
    api.put_native_function(process, module, u"___bitor", ___bitor, 2)
    api.put_native_function(process, module, u"___bitxor", ___bitxor, 2)
    api.put_native_function(process, module, u"___bitand", ___bitand, 2)
    api.put_native_function(process, module, u"___lsh", ___lsh, 2)
    api.put_native_function(process, module, u"___rsh", ___rsh, 2)
    api.put_native_function(process, module, u"___ursh", ___ursh, 2)
    api.put_native_function(process, module, u"___cons", ___cons, 2)
    api.put_native_function(process, module, u"___notin", ___notin, 2)
    api.put_native_function(process, module, u"___nota", ___nota, 2)
    api.put_native_function(process, module, u"___isa", ___isa, 2)
    api.put_native_function(process, module, u"___kindof", ___kindof, 2)
    ## debugging
    # if not we_are_translated():
    #     api.put_native_function(process, obj, u'pypy_repr', pypy_repr)
    #     api.put_native_function(process, obj, u'inspect', inspect)


def call2(process, generic, l, r):
    api.call(process, generic, newtuple([l, r]))


def call1(process, generic, w):
    api.call(process, generic, newtuple([w]))


# TODO INLINE
def is_both_numbers(w1, w2):
    return isnumber(w1) and isnumber(w2)


def is_both_integers(w1, w2):
    return isint(w1) and isint(w2)


def is_both_strings(w1, w2):
    return space.isstring(w1) and space.isstring(w2)


def is_not_entities(w1, w2):
    return not isentity(w1) and not isentity(w2)


def apply_binary(process, routine, operation, left, right):
    routine.stack.push(operation(process, left, right))


def apply_unary(process, routine, operation, val):
    routine.stack.push(operation(process, val))


@complete_native_routine
def ___is(process, routine):
    left = routine.get_arg(0)
    right = routine.get_arg(1)
    apply_binary(process, routine, is_w, left, right)


@complete_native_routine
def ___ne(process, routine):
    left = routine.get_arg(0)
    right = routine.get_arg(1)

    if is_not_entities(left, right):
        apply_binary(process, routine, noteq_w, left, right)
    else:
        call2(process, process.std.generics.NotEqual, left, right)


@complete_native_routine
def ___eq(process, routine):
    left = routine.get_arg(0)
    right = routine.get_arg(1)

    if is_not_entities(left, right):
        apply_binary(process, routine, eq_w, left, right)
    else:
        call2(process, process.std.generics.Equal, left, right)


@complete_native_routine
def ___not(process, routine):
    left = routine.get_arg(0)
    apply_unary(process, routine, not_w, left)


@complete_native_routine
def ___isnot(process, routine):
    left = routine.get_arg(0)
    right = routine.get_arg(1)
    apply_binary(process, routine, isnot_w, left, right)


@complete_native_routine
def ___in(process, routine):
    left = routine.get_arg(0)
    right = routine.get_arg(1)
    if is_not_entities(left, right):
        apply_binary(process, routine, in_w, left, right)
    else:
        call2(process, process.std.generics.In, left, right)


@complete_native_routine
def ___add(process, routine):
    left = routine.get_arg(0)
    right = routine.get_arg(1)

    if is_both_numbers(left, right):
        apply_binary(process, routine, add_n_n, left, right)
    elif is_both_strings(left, right):
        apply_binary(process, routine, add_s_s, left, right)
    else:
        call2(process, process.std.generics.Add, left, right)


@complete_native_routine
def ___mod(process, routine):
    left = routine.get_arg(0)
    right = routine.get_arg(1)

    if is_both_numbers(left, right):
        apply_binary(process, routine, mod_n_n, left, right)
    else:
        call2(process, process.std.generics.Mod, left, right)


@complete_native_routine
def ___mul(process, routine):
    left = routine.get_arg(0)
    right = routine.get_arg(1)

    if is_both_numbers(left, right):
        apply_binary(process, routine, mult_n_n, left, right)
    else:
        call2(process, process.std.generics.Mul, left, right)


@complete_native_routine
def ___div(process, routine):
    left = routine.get_arg(0)
    right = routine.get_arg(1)

    if is_both_numbers(left, right):
        apply_binary(process, routine, div_n_n, left, right)
    else:
        call2(process, process.std.generics.Div, left, right)


@complete_native_routine
def ___sub(process, routine):
    left = routine.get_arg(0)
    right = routine.get_arg(1)

    if is_both_numbers(left, right):
        apply_binary(process, routine, sub_n_n, left, right)
    else:
        call2(process, process.std.generics.Sub, left, right)


@complete_native_routine
def ___uminus(process, routine):
    left = routine.get_arg(0)

    if isnumber(left):
        apply_unary(process, routine, uminus_n, left)
    else:
        call1(process, process.std.generics.UnaryMinus, left)


@complete_native_routine
def ___uplus(process, routine):
    left = routine.get_arg(0)
    if isnumber(left):
        apply_unary(process, routine, uplus_n, left)
    else:
        call1(process, process.std.generics.UnaryPlus, left)


@complete_native_routine
def ___ge(process, routine):
    left = routine.get_arg(0)
    right = routine.get_arg(1)
    if is_both_numbers(left, right):
        apply_binary(process, routine, compare_ge_n_n, left, right)
    else:
        call2(process, process.std.generics.GreaterEqual, left, right)


@complete_native_routine
def ___gt(process, routine):
    left = routine.get_arg(0)
    right = routine.get_arg(1)

    if is_both_numbers(left, right):
        apply_binary(process, routine, compare_gt_n_n, left, right)
    else:
        call2(process, process.std.generics.GreaterThen, left, right)


@complete_native_routine
def ___lt(process, routine):
    left = routine.get_arg(0)
    right = routine.get_arg(1)

    if is_both_numbers(left, right):
        apply_binary(process, routine, compare_gt_n_n, right, left)
    else:
        call2(process, process.std.generics.GreaterThen, right, left)


@complete_native_routine
def ___le(process, routine):
    left = routine.get_arg(0)
    right = routine.get_arg(1)
    if is_both_numbers(left, right):
        apply_binary(process, routine, compare_ge_n_n, right, left)
    else:
        call2(process, process.std.generics.GreaterEqual, right, left)


@complete_native_routine
def ___bitnot(process, routine):
    left = routine.get_arg(0)
    if isint(left):
        apply_unary(process, routine, bitnot_i, left)
    else:
        call1(process, process.std.generics.BitNot, left)


@complete_native_routine
def ___bitor(process, routine):
    left = routine.get_arg(0)
    right = routine.get_arg(1)

    if is_both_integers(left, right):
        apply_binary(process, routine, bitor_i_i, left, right)
    else:
        call2(process, process.std.generics.BitOr, left, right)


@complete_native_routine
def ___bitxor(process, routine):
    left = routine.get_arg(0)
    right = routine.get_arg(1)

    if is_both_integers(left, right):
        apply_binary(process, routine, bitxor_i_i, left, right)
    else:
        call2(process, process.std.generics.BitXor, left, right)


@complete_native_routine
def ___bitand(process, routine):
    left = routine.get_arg(0)
    right = routine.get_arg(1)

    if is_both_integers(left, right):
        apply_binary(process, routine, bitand_i_i, left, right)
    else:
        call2(process, process.std.generics.BitAnd, left, right)


@complete_native_routine
def ___lsh(process, routine):
    left = routine.get_arg(0)
    right = routine.get_arg(1)

    if is_both_integers(left, right):
        apply_binary(process, routine, lsh_i_i, left, right)
    else:
        call2(process, process.std.generics.LeftShift, left, right)


@complete_native_routine
def ___rsh(process, routine):
    left = routine.get_arg(0)
    right = routine.get_arg(1)

    if is_both_integers(left, right):
        apply_binary(process, routine, rsh_i_i, left, right)
    else:
        call2(process, process.std.generics.RightShift, left, right)


@complete_native_routine
def ___ursh(process, routine):
    left = routine.get_arg(0)
    right = routine.get_arg(1)
    if is_both_integers(left, right):
        apply_binary(process, routine, ursh_i_i, left, right)
    else:
        call2(process, process.std.generics.UnsignedRightShift, left, right)


@complete_native_routine
def ___cons(process, routine):
    left = routine.get_arg(0)
    right = routine.get_arg(1)

    apply_binary(process, routine, cons_w, left, right)


@complete_native_routine
def ___notin(process, routine):
    left = routine.get_arg(0)
    right = routine.get_arg(1)

    if is_not_entities(left, right):
        apply_binary(process, routine, notin_w, left, right)
    else:
        call2(process, process.std.generics.NotIn, left, right)


@complete_native_routine
def ___nota(process, routine):
    left = routine.get_arg(0)
    right = routine.get_arg(1)
    apply_binary(process, routine, nota_w, left, right)


@complete_native_routine
def ___isa(process, routine):
    left = routine.get_arg(0)
    right = routine.get_arg(1)
    apply_binary(process, routine, isa_w, left, right)


@complete_native_routine
def ___kindof(process, routine):
    left = routine.get_arg(0)
    right = routine.get_arg(1)
    apply_binary(process, routine, kindof_w, left, right)

__author__ = 'gloryofrobots'
from obin.builtins.internals.operations import *
from obin.runtime.routine import complete_native_routine, complete_or_interrupt_native_routine
from obin.runtime import error
from obin.types import api, space
from obin.types.space import newtuple, isnumber, isint, isentity
from obin.builtins.internals import operators

def setup(process, module, stdlib):
    # AUTOGENERATED operators_gen.py
    api.put_native_function(process, module, operators.OP_IS, ___is, 2)
    api.put_native_function(process, module, operators.OP_NE, ___ne, 2)
    api.put_native_function(process, module, operators.OP_EQ, ___eq, 2)
    api.put_native_function(process, module, operators.OP_NOT, ___not, 1)
    api.put_native_function(process, module, operators.OP_ISNOT, ___isnot, 2)
    api.put_native_function(process, module, operators.OP_IN, ___in, 2)
    api.put_native_function(process, module, operators.OP_ADD, ___add, 2)
    api.put_native_function(process, module, operators.OP_MOD, ___mod, 2)
    api.put_native_function(process, module, operators.OP_MUL, ___mul, 2)
    api.put_native_function(process, module, operators.OP_DIV, ___div, 2)
    api.put_native_function(process, module, operators.OP_SUB, ___sub, 2)
    api.put_native_function(process, module, operators.OP_UMINUS, ___uminus, 1)
    api.put_native_function(process, module, operators.OP_UPLUS, ___uplus, 1)
    api.put_native_function(process, module, operators.OP_GE, ___ge, 2)
    api.put_native_function(process, module, operators.OP_GT, ___gt, 2)
    api.put_native_function(process, module, operators.OP_LT, ___lt, 2)
    api.put_native_function(process, module, operators.OP_LE, ___le, 2)
    api.put_native_function(process, module, operators.OP_BITNOT, ___bitnot, 1)
    api.put_native_function(process, module, operators.OP_BITOR, ___bitor, 2)
    api.put_native_function(process, module, operators.OP_BITXOR, ___bitxor, 2)
    api.put_native_function(process, module, operators.OP_BITAND, ___bitand, 2)
    api.put_native_function(process, module, operators.OP_LSH, ___lsh, 2)
    api.put_native_function(process, module, operators.OP_RSH, ___rsh, 2)
    api.put_native_function(process, module, operators.OP_URSH, ___ursh, 2)
    api.put_native_function(process, module, operators.OP_CONS, ___cons, 2)
    api.put_native_function(process, module, operators.OP_NOTIN, ___notin, 2)
    api.put_native_function(process, module, operators.OP_NOTA, ___nota, 2)
    api.put_native_function(process, module, operators.OP_ISA, ___isa, 2)
    api.put_native_function(process, module, operators.OP_KINDOF, ___kindof, 2)
    ## debugging
    # if not we_are_translated():
    #     api.put_native_function(process, obj, u'pypy_repr', pypy_repr)
    #     api.put_native_function(process, obj, u'inspect', inspect)


def call2(process, generic, l, r):
    api.call(process, generic, newtuple([l, r]))
    return space.newinterrupt()


def call1(process, generic, w):
    api.call(process, generic, newtuple([w]))
    return space.newinterrupt()


# TODO INLINE
def is_both_numbers(w1, w2):
    return isnumber(w1) and isnumber(w2)


def is_both_integers(w1, w2):
    return isint(w1) and isint(w2)


def is_both_strings(w1, w2):
    return space.isstring(w1) and space.isstring(w2)


def is_not_entities(w1, w2):
    return not isentity(w1) and not isentity(w2)


def apply_binary(process, routine, operation, left, right):
    routine.stack.push(operation(process, left, right))


def apply_unary(process, routine, operation, val):
    routine.stack.push(operation(process, val))


@complete_native_routine
def ___is(process, routine):
    left = routine.get_arg(0)
    right = routine.get_arg(1)
    apply_binary(process, routine, is_w, left, right)


@complete_native_routine
def ___ne(process, routine):
    left = routine.get_arg(0)
    right = routine.get_arg(1)

    if is_not_entities(left, right):
        apply_binary(process, routine, noteq_w, left, right)
    else:
        call2(process, process.std.generics.NotEqual, left, right)


@complete_native_routine
def ___eq(process, routine):
    left = routine.get_arg(0)
    right = routine.get_arg(1)

    if is_not_entities(left, right):
        apply_binary(process, routine, eq_w, left, right)
    else:
        call2(process, process.std.generics.Equal, left, right)


@complete_native_routine
def ___not(process, routine):
    left = routine.get_arg(0)
    apply_unary(process, routine, not_w, left)


@complete_native_routine
def ___isnot(process, routine):
    left = routine.get_arg(0)
    right = routine.get_arg(1)
    apply_binary(process, routine, isnot_w, left, right)


@complete_native_routine
def ___in(process, routine):
    left = routine.get_arg(0)
    right = routine.get_arg(1)
    if is_not_entities(left, right):
        apply_binary(process, routine, in_w, left, right)
    else:
        call2(process, process.std.generics.In, left, right)


@complete_native_routine
def ___add(process, routine):
    left = routine.get_arg(0)
    right = routine.get_arg(1)

    if is_both_numbers(left, right):
        apply_binary(process, routine, add_n_n, left, right)
    elif is_both_strings(left, right):
        apply_binary(process, routine, add_s_s, left, right)
    else:
        call2(process, process.std.generics.Add, left, right)


@complete_native_routine
def ___mod(process, routine):
    left = routine.get_arg(0)
    right = routine.get_arg(1)

    if is_both_numbers(left, right):
        apply_binary(process, routine, mod_n_n, left, right)
    else:
        call2(process, process.std.generics.Mod, left, right)


@complete_or_interrupt_native_routine
def ___mul(process, routine):
    left = routine.get_arg(0)
    right = routine.get_arg(1)

    if is_both_numbers(left, right):
        return mult_n_n(process, left, right)
    else:
        return call2(process, process.std.generics.Mul, left, right)


@complete_native_routine
def ___div(process, routine):
    left = routine.get_arg(0)
    right = routine.get_arg(1)

    if is_both_numbers(left, right):
        apply_binary(process, routine, div_n_n, left, right)
    else:
        call2(process, process.std.generics.Div, left, right)


@complete_native_routine
def ___sub(process, routine):
    left = routine.get_arg(0)
    right = routine.get_arg(1)

    if is_both_numbers(left, right):
        apply_binary(process, routine, sub_n_n, left, right)
    else:
        call2(process, process.std.generics.Sub, left, right)


@complete_native_routine
def ___uminus(process, routine):
    left = routine.get_arg(0)

    if isnumber(left):
        apply_unary(process, routine, uminus_n, left)
    else:
        call1(process, process.std.generics.UnaryMinus, left)


@complete_native_routine
def ___uplus(process, routine):
    left = routine.get_arg(0)
    if isnumber(left):
        apply_unary(process, routine, uplus_n, left)
    else:
        call1(process, process.std.generics.UnaryPlus, left)


@complete_native_routine
def ___ge(process, routine):
    left = routine.get_arg(0)
    right = routine.get_arg(1)
    if is_both_numbers(left, right):
        apply_binary(process, routine, compare_ge_n_n, left, right)
    else:
        call2(process, process.std.generics.GreaterEqual, left, right)


@complete_native_routine
def ___gt(process, routine):
    left = routine.get_arg(0)
    right = routine.get_arg(1)

    if is_both_numbers(left, right):
        apply_binary(process, routine, compare_gt_n_n, left, right)
    else:
        call2(process, process.std.generics.GreaterThen, left, right)


@complete_native_routine
def ___lt(process, routine):
    left = routine.get_arg(0)
    right = routine.get_arg(1)

    if is_both_numbers(left, right):
        apply_binary(process, routine, compare_gt_n_n, right, left)
    else:
        call2(process, process.std.generics.GreaterThen, right, left)


@complete_native_routine
def ___le(process, routine):
    left = routine.get_arg(0)
    right = routine.get_arg(1)
    if is_both_numbers(left, right):
        apply_binary(process, routine, compare_ge_n_n, right, left)
    else:
        call2(process, process.std.generics.GreaterEqual, right, left)


@complete_native_routine
def ___bitnot(process, routine):
    left = routine.get_arg(0)
    if isint(left):
        apply_unary(process, routine, bitnot_i, left)
    else:
        call1(process, process.std.generics.BitNot, left)


@complete_native_routine
def ___bitor(process, routine):
    left = routine.get_arg(0)
    right = routine.get_arg(1)

    if is_both_integers(left, right):
        apply_binary(process, routine, bitor_i_i, left, right)
    else:
        call2(process, process.std.generics.BitOr, left, right)


@complete_native_routine
def ___bitxor(process, routine):
    left = routine.get_arg(0)
    right = routine.get_arg(1)

    if is_both_integers(left, right):
        apply_binary(process, routine, bitxor_i_i, left, right)
    else:
        call2(process, process.std.generics.BitXor, left, right)


@complete_native_routine
def ___bitand(process, routine):
    left = routine.get_arg(0)
    right = routine.get_arg(1)

    if is_both_integers(left, right):
        apply_binary(process, routine, bitand_i_i, left, right)
    else:
        call2(process, process.std.generics.BitAnd, left, right)


@complete_native_routine
def ___lsh(process, routine):
    left = routine.get_arg(0)
    right = routine.get_arg(1)

    if is_both_integers(left, right):
        apply_binary(process, routine, lsh_i_i, left, right)
    else:
        call2(process, process.std.generics.LeftShift, left, right)


@complete_native_routine
def ___rsh(process, routine):
    left = routine.get_arg(0)
    right = routine.get_arg(1)

    if is_both_integers(left, right):
        apply_binary(process, routine, rsh_i_i, left, right)
    else:
        call2(process, process.std.generics.RightShift, left, right)


@complete_native_routine
def ___ursh(process, routine):
    left = routine.get_arg(0)
    right = routine.get_arg(1)
    if is_both_integers(left, right):
        apply_binary(process, routine, ursh_i_i, left, right)
    else:
        call2(process, process.std.generics.UnsignedRightShift, left, right)


@complete_native_routine
def ___cons(process, routine):
    left = routine.get_arg(0)
    right = routine.get_arg(1)

    apply_binary(process, routine, cons_w, left, right)


@complete_native_routine
def ___notin(process, routine):
    left = routine.get_arg(0)
    right = routine.get_arg(1)

    if is_not_entities(left, right):
        apply_binary(process, routine, notin_w, left, right)
    else:
        call2(process, process.std.generics.NotIn, left, right)


@complete_native_routine
def ___nota(process, routine):
    left = routine.get_arg(0)
    right = routine.get_arg(1)
    apply_binary(process, routine, nota_w, left, right)


@complete_native_routine
def ___isa(process, routine):
    left = routine.get_arg(0)
    right = routine.get_arg(1)
    apply_binary(process, routine, isa_w, left, right)


@complete_native_routine
def ___kindof(process, routine):
    left = routine.get_arg(0)
    right = routine.get_arg(1)
    apply_binary(process, routine, kindof_w, left, right)



import seq
import from _lists (cons, tail, head, empty, is_empty)

specify seq:seq(l of List) -> l;

specify seq:head(l of List) -> head(l);

specify seq:tail(l of List) -> tail(l);

specify seq:empty(l of List) -> empty();

specify seq:is_empty(l of List) -> is_empty(l);

specify seq:cons(a of Any, l of List) -> cons(a, l);



//TRANSFORMERS///////////////////////////////////////////////////////

def map(f of Callable, l of List) ->
    fun _map
         case (f, []) -> []
         case (f, [hd, ...tl]) -> f(hd) :: _map(f, tl)
    end
    _map(f, l)
end

def intersperse(val, l of List) ->
    fun _intersperse
        case (val, []) -> []
        case (val, [hd, ...tl]) -> hd :: val :: _intersperse(val, tl)
    end
    _intersperse(val, l)
end

def reverse(l of List) ->
    fun _reverse
        case ([], result) -> result
        case ([hd, ...tl], result) -> _reverse(tl, hd :: result)
    end
    _reverse(l, [])
end

//REDUCERS///////////////////////////////////////////////////////
def on_reduced
    case (#ReducedValue, val) -> val
    case (e) -> throw e
end

def foldl(f of Callable, init_val, l of List) ->
    fun _foldl
        case (f, acc, []) -> acc
        case (f, acc, [hd, ...tl]) ->
            try
                foldl(f, f(hd, acc), tl)
            catch e ->
                on_reduced(e);
    end
    _foldl(f, init_val, l)
end


def foldr(f of Callable, init_val, l of List) ->
    fun _foldr
        case (f, acc, []) -> acc
        case (f, acc, [hd, ...tl]) ->
            try
                 f(hd, foldr(f, acc, tl))
            catch e ->
                on_reduced(e);
    end
    _foldr(f, init_val, l)
end


def scanl(f of Callable, init_val, l of List) ->
    fun _scanl
        case (f, acc, []) -> acc::[]
        case (f, acc, [hd, ...tl]) -> acc :: _scanl(f, f(hd, acc), tl)
    end
    try
        _scanl(f, init_val, l)
    catch e ->
        on_reduced(e);
end

///ACCESSORS//////////////////////////////////////

def nth_tail
    case (0, l) -> l
    case (1, [_, ...t]) -> t
    case (n, [_, ...t]) ->
        nth_tail(n - 1, t) when n >= 0 else throw (#InvalidIndex, n)
end

def nth
    case (0, L) -> L
    case (1, [h, ...t]) -> h
    case (n, [h, ...t]) ->
        nth(n - 1, t) when n >= 0 else throw (#InvalidIndex, n)
end


def length(l of List) ->
    foldl(fun (_, acc) -> acc + 1 end, 0, l);

//QUERIES///////////////////////////////////////////////////

def prefix
    case ([hd, ...pre_tail], [hd, ...tail]) -> prefix(pre_tail, tail)
    case ([], l) -> true
    case ([_, ..._], l) -> false
end

def suffix(suf of List, l of List) ->
   delta = length(l) - length(suf)
   delta >= 0 and nth_tail(delta, l) == suf
end

//SUBLISTS/////////////////////////////////////////////////////////////

def drop(count of Int, l of List) ->
    fun _drop
        case (0, l) -> l
        case (count, [hd, ...tl]) -> _drop(count - 1, tl);
    _drop(count, l)
end

//BUILDERS/////////////////////////////////////////////////////////////

def concat(l1 of List, l2 of List) ->
     foldr(`::`, l2, l1);


def range
    case (first of Int, last of Int) ->
        if last < 0
            step = - 1
        else
            step = 1;
        range(first, last, step)
    ///////////////////////////////////////
    case (first of Int, last of Int, step of Int) ->
        when step == 0
            throw (#RangeError, "Step cannot be zero.");

        when last < first and step > 0
            throw (#RangeError, "Expected negative step.");

        fun _range(first, last, step, condition, result) ->
             if condition(first, last)
                reverse(result)
             else
                _range(first + step, last, step, condition, first :: result);
        end

        condition = `>=` when step > 0 else `<=`
        _range(first, last, step, condition, [])
end

def range2
    case (first of Int, last of Int) ->
        if last < 0
            step = - 1
        else
            step = 1;
        range2(first, last, step)
    ///////////////////////////////////////
    case (first of Int, last of Int, step of Int) ->
        fun _range
            case (N, X, D, L) when N >= 4 ->
                print("first", L)
                print(#N, N)
                print(#X, X)
                print(#D, D)
                Y = X - D
                Z = Y - D
                W = Z - D
                print(#Y, Y)
                print(#Z, Z)
                print(#W, W)
                _range(N - 4, W - D, D, W ::Z :: Y :: X :: L)
            case (N, X, D, L) when N >= 2 ->
                print("second", L)
                Y = X - D
                _range(N - 2, Y - D, D, Y :: X :: L)
            case (1, X, _, L) ->
                print("third", L)
                X :: L
            case (0, _, _, L) -> print ("fourth ", L), L;

        if step > 0 and first - step <= last or
            step < 0 and first - step >= last
            n = (last - first + step) / step
            print("N", n)
            _range(n-1, step * (n - 1) + first - 1, step, [])
        elif step == 0 and first == last
            _range(1, first, step, [])
        else
            throw (#InvalidRange, first, last, step)
        end
end
//seq(First, Last, Inc)
//    when is_integer(First), is_integer(Last), is_integer(Inc) ->
//    if
//        Inc > 0, First - Inc =< Last;
//        Inc < 0, First - Inc >= Last ->
//            N = (Last - First + Inc) div Inc,
//            seq_loop(N, Inc*(N-1)+First, Inc, []);
//        Inc =:= 0, First =:= Last ->
//            seq_loop(1, First, Inc, [])
//    end.

//seq_loop(N, X, D, L) when N >= 4 ->
//     Y = X-D, Z = Y-D, W = Z-D,
//     seq_loop(N-4, W-D, D, [W,Z,Y,X|L]);
//seq_loop(N, X, D, L) when N >= 2 ->
//     Y = X-D,
//     seq_loop(N-2, Y-D, D, [Y,X|L]);
//seq_loop(1, X, _, L) ->
//     [X|L];
//seq_loop(0, _, _, L) ->
//     L.

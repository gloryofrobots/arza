//TODO FIX IT
length = ___length
//TODO
//Symbols can also be created using symbol(),
//which takes any number of arguments and creates a new symbol by concatenating their string representations together:

@prefix(`-`, `__uminus__`)
@prefix(`+`, `__plus__`)
@prefix(`~`, `~`)
//@infixr(`|`, `|`, 35)
@infixr(`^`, `^`, 45)
@infixr(`&`, `&`, 45)
@infixl(`<`, `<`, 50)
@infixl(`>`, `>`, 50)
@infixl(`>=`, `>=`, 50)
@infixl(`<=`, `<=`, 50)
@infixl(`==`, `==`, 50)
@infixl(`!=`, `!=`, 50)
@infixl(`<<`, `<<`, 55)
@infixl(`>>`, `>>`, 55)
@infixl(`>>>`, `>>>`, 55)
@infixl(`+`, `+`, 60)
@infixl(`-`, `-`, 60)
@infixl(`%`, `%`, 65)
@infixl(`*`, `*`, 65)
@infixl(`/`, `/`, 65)
@infixr(`::`, `::`, 70)
@infixl(`++`, `++`, 70)

type Zero end

type Point2 x y
    construct
    | x y
    | x -> y = x
    -------------
---------

//type Vec2 p1 p2
//    construct
//    | p1 of Point2, p2 of Point2
//    | x1 y1 x2 y2 -> p1 = Point2 x y; p2 = Point2 x2 y2;
//    | p2 @ p1
//    -----------
//
//trait Num self
//    method is_zero self
//    method add self a
//---------------
//
//
//implement Num for Point2
//    specify is_zero
//        | self -> self.x == 0 and self.y == 0
//    specify add Point2
//        | self {x=0, y=0} -> self
//        | {x=0, y=0} p2 -> p2
//        | self p2 -> Point2 (self.x + p2.x) (self.y + p2.y)
//    specify add Vec2
//        | self v -> add (Vec2 self) v
//---------------------------
//
//
//implement Num for Vec2
//    specify is_zero
//        | self -> (is_zero self.p1) and (is_zero self.p2)
//    specify add for Vec2
//        | self v  -> Vec2 (add self.p1  v.p1) (add self.p2 v.p2)
//    specify add for Point2
//        | self p -> (add self (Vec2 p))
//--------------------
//
//implement Num for Zero
//    specify is_zero
//        | self -> true
//    specify add for Number
//        | self i -> i
//------------
//
//specify add for Num Zero
//    | self i -> self
//---
//
//specify add
//    for Point2 Point2
//        | self {x=0, y=0} -> self
//        | {x=0, y=0} p2 -> p2
//        | p1 p2 -> Point2 (p1.x + p2.x) (p1.y + p2.y)
//    for Point2 Vec2
//        | self v -> add (Vec2 self) v
//    for Vec2 Vec2
//        | self v  -> Vec2 (add self.p1  v.p1) (add self.p2 v.p2)
//    for Vec2 Point2
//        | self p -> (add self (Vec2 p))
//    for Zero Num
//        | self i -> i
//    for Num Zero
//        | self i -> self
//------------------------------------
////union Option = None | Some v

//fun main () ->
//    p1 = Point2 1 2
//    v1 = Vec2 p1
//    v2 = Vec2 (Point2 2 3) (Point2 4 5)
//    v3 = add v1 v2
//------------

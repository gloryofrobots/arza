import from _list (cons, tail, head, empty, is_empty)

//TRANSFORMERS///////////////////////////////////////////////////////

fun map
| f [] -> []
| f [hd, ...tl] -> (f hd) :: (map f tl)
----------------------------------------

fun intersperse
| val [] -> []
| val [hd, ...tl] -> hd :: val :: (intersperse val tl)
--------------------------------------------------

fun reverse
| l of List -> reverse l []
| [] result -> result
| [hd, ...tl] result -> (reverse tl hd :: result)
----------------------------------------

//REDUCERS///////////////////////////////////////////////////////

fun foldl
| f acc [] -> acc
| f acc [hd, ...tl] -> foldl f (f hd acc) tl
----------------------------------------

fun foldr
| f acc [] -> acc
| f acc [hd, ...tl] -> f hd (foldr f acc tl)
--------------------------------------------------

fun scanl
| f acc [] -> acc::[]
| f acc [hd, ...tl] -> acc :: (scanl f (f hd acc) tl)
--------------------------------------------------


///ACCESSORS//////////////////////////////////////

fun nth_tail
| 0 l -> l
| 1 [_, ...t] -> t
| n [_, ...t] when n >= 0 ->
    nth_tail (n - 1) t
--------------------------------------------------

fun nth
| 0 l -> l
| 1 [h, ...t] -> h
| n [h, ...t] when n >= 0 -> nth (n - 1) t
--------------------------------------------------

fun length | l of List ->
    foldl lam _ acc -> acc + 1; 0 l
--------------------------------------------------

//QUERIES///////////////////////////////////////////////////

fun prefix
| [hd, ...pre_tail] [hd, ...tail] -> prefix pre_tail tail
| [] l -> true
| [_, ..._] l -> false
--------------------------------------------------

fun suffix
| suf of List l of List ->
   delta = (length l) - (length suf)
   tl = nth_tail delta l
   delta >= 0 and tl == suf
--------------------------------------------------

//SUBLISTS/////////////////////////////////////////////////////////////
fun drop
| 0 l -> l
| count [hd, ...tl] -> drop (count - 1) tl
--------------------------------------------------

fun take
| 0 _ -> []
| _ [] -> []
| n [x, ...xs] -> x :: (take n-1, xs)
--------------------------------------------------

fun split_at | n of Int l of List -> ((take n l), (drop n  l)) end

fun take_while
| p [] -> []
| p [x, ...xs] -> x :: (take_while p xs) if p x else []
--------------------------------------------------

fun drop_while
| p [] -> []
| p xs@[x, ...xs1] -> (drop_while p xs1) if p x else xs
--------------------------------------------------

fun span
| p [] -> ([], [])
| p xs@[x, ...xs1] ->
    cond
    | not (p x) -> ([], xs)
    | else ->
        (ys, zs) = (span p xs1)
        (x::ys, zs)
    ------------------------------
--------------------------------------------------

fun delete
| item [item, ...xs] -> xs
| item [x, ...xs] -> x :: (delete item xs)
| _ [] -> []
--------------------------------------------------

////QUERIES//////////////////////////////////////////////////////////////////

fun conjunction l ->
    foldr lam v acc -> v and acc; true l end

fun disjunction l ->
    foldr lam v acc -> v or acc; false l end

fun any p l ->
    disjunction (map p l) end

fun all p l ->
    conjunction (map p l) end

fun element x l ->
    any lam v -> v == x; l end

fun contains l x ->
    element x l end

//BUILDERS/////////////////////////////////////////////////////////////

fun concat | l1 l2 ->
    foldr &:: l2 l1 end

fun range
| first of Int last of Int ->
    step = -1 if last < 0 else 1
    range first last step
    ///////////////////////////////////////
| first of Int, last of Int, step of Int ->
    fun _range
    | N X D L when N >= 4 ->
        Y = X - D
        Z = Y - D
        W = Z - D
        _range (N - 4)  (W - D)  D  (W :: Z :: Y :: X :: L)

    | N X D L when N >= 2 ->
        Y = X - D
        _range (N - 2) (Y - D) D (Y :: X :: L)

    | 1 X _ L -> X :: L

    | 0 _ _ L -> L
    --------------------------------------------------

    cond
    | step > 0 and first - step <= last or
      step < 0 and first - step >= last ->
        n = ((last - first + step) / step) - 1
        _range n (step * (n - 1) + first) step []

    | step == 0 and first == last ->
        _range 1  first step []
    | else ->
        throw (#InvalidRange, first, last, step)
    ------------------------------
--------------------------------------------------

fun last
| [x, ...xs] -> last x xs
| _ [x, ...xs] -> last x xs
| x [] -> x
--------------------------------------------------

fun uncons | [x, ...xs] -> (x, xs) end

fun init
| [x] -> []
| [x, ...xs] -> x :: (init xs)
| [] -> throw #EmptyListError
------------------------------

fun replicate
| n  x when n >= 0 -> replicate n x []
| 0 _ l -> l
| n x l -> replicate (n - 1) x (x :: l)
---------------------------------------------------


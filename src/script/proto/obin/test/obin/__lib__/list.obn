import seq

import from _lists (cons, tail, head, empty, is_empty)

specify seq:seq | l of List -> l end

specify seq:head | l of List -> head l end

specify seq:tail | l of List -> tail l end

specify seq:empty | l of List -> empty () end

specify seq:is_empty | l of List -> is_empty l end

specify seq:cons | a of Any l of List -> cons a l end

//TRANSFORMERS///////////////////////////////////////////////////////

fun map
| f [] -> []
| f [hd, ...tl] -> (f hd) :: (map f tl)
----------------------------------------

fun intersperse
| val [] -> []
| val [hd, ...tl] -> hd :: val :: (intersperse val tl)
--------------------------------------------------

fun reverse
| [] result -> result
| [hd, ...tl] result -> (reverse tl hd :: result)
----------------------------------------

//REDUCERS///////////////////////////////////////////////////////

fun foldl
| f acc [] -> acc
| f acc [hd, ...tl] -> foldl f (f hd acc) tl
----------------------------------------

fun foldr
| f acc [] -> acc
| f acc [hd, ...tl] -> f hd (foldr f acc tl)
--------------------------------------------------

fun _scanl
| f acc [] -> acc::[]
| f acc [hd, ...tl] -> acc :: (_scanl f (f hd acc) tl)
--------------------------------------------------


///ACCESSORS//////////////////////////////////////

fun nth_tail
| 0 l -> l
| 1 [_, ...t] -> t
| n [_, ...t] when n >= 0 -> nth_tail n - 1 t
--------------------------------------------------

fun nth
| 0 l -> l
| 1 [h, ...t] -> h
| n [h, ...t] when n >= 0 -> nth n - 1 t
--------------------------------------------------

fun length | l of List ->
    foldl lambda _ acc -> acc + 1; 0 l
--------------------------------------------------

//QUERIES///////////////////////////////////////////////////

fun prefix
| [hd, ...pre_tail] [hd, ...tail] -> prefix pre_tail tail
| [] l -> true
| [_, ..._] l -> false
--------------------------------------------------

fun suffix | suf of List l of List ->
   delta = (length l) - (length suf)
   delta >= 0 and (nth_tail delta l) == suf
--------------------------------------------------

//SUBLISTS/////////////////////////////////////////////////////////////

fun drop(count of Int, l of List) ->
    fun _drop
    | (0, l) -> l
    | (count, [hd, ...tl]) -> _drop(count - 1, tl) end
    _drop(count, l)
end

fun take (n of Int, l) ->
    fun _take
    | (0, _) -> []
    | (_, []) -> []
    | (n, [x, ...xs]) -> x :: _take(n-1, xs) end
    _take(n, l)
end

fun split_at(n of Int, l of List) -> (take(n, l), drop(n, l)) end

fun take_while
| (p, []) -> []
| (p, [x, ...xs]) -> x :: take_while(p, xs) when p(x) else []
end

fun drop_while
| (p, []) -> []
| (p, xs@[x, ...xs1]) -> drop_while(p, xs1) when p(x) else xs
end

fun span
| (p, []) -> ([], [])
| (p, xs@[x, ...xs1]) ->
        if not p(x)
            ([], xs)
        else
            (ys, zs) = span(p, xs1)
            (x::ys, zs) end
end

fun delete
| (item, [item, ...xs]) -> xs
| (item, [x, ...xs]) -> x :: delete(item, xs)
| (_, []) -> []
end
////QUERIES//////////////////////////////////////////////////////////////////

fun conjunction(l of List) -> foldr(fun(v, acc) -> v and acc end, true, l) end
fun disjunction(l of List) -> foldr(fun(v, acc) -> v or acc end, false, l) end
fun any(p, l of List) ->  disjunction(map(p, l)) end
fun all(p, l of List) ->  conjunction(map(p, l)) end
fun element(x, l of List) ->  any(fun (v) -> v == x end, l) end
fun contains(l of List, x) ->  element(x, l) end


//BUILDERS/////////////////////////////////////////////////////////////

fun concat(l1 of List, l2 of List) ->
     foldr(`::`, l2, l1) end


//fun range
//| (first of Int, last of Int) ->
//        if last < 0
//            step = - 1
//        else
//            step = 1 end
//        range(first, last, step)
//    ///////////////////////////////////////
//| (first of Int, last of Int, step of Int) ->
//        when step == 0
//            throw (#RangeError, "Step cannot be zero.") end
//
//        when last < first and step > 0
//            throw (#RangeError, "Expected negative step.") end
//
//        fun _range(first, last, step, condition, result) ->
//             if condition(first, last)
//                reverse(result)
//             else
//                _range(first + step, last, step, condition, first :: result) end
//        end
//
//        condition = `>=` when step > 0 else `<=`
//        _range(first, last, step, condition, [])
//end

fun range
| (first of Int, last of Int) ->
        if last < 0
            step = - 1
        else
            step = 1 end
        range(first, last, step)
    ///////////////////////////////////////
| (first of Int, last of Int, step of Int) ->
        fun _range
        | (N, X, D, L) when N >= 4 ->
                Y = X - D
                Z = Y - D
                W = Z - D
                _range(N - 4, W - D, D, W :: Z :: Y :: X :: L)
        | (N, X, D, L) when N >= 2 ->
                Y = X - D
                _range(N - 2, Y - D, D, Y :: X :: L)
        | (1, X, _, L) ->
                X :: L
        | (0, _, _, L) -> L end

        if step > 0 and first - step <= last or
            step < 0 and first - step >= last
            n = ((last - first + step) / step) - 1
            _range(n, step * (n - 1) + first, step, [])
        elif step == 0 and first == last
            _range(1, first, step, [])
        else
            throw (#InvalidRange, first, last, step)
        end
end

fun last
| ([x, ...xs]) -> last(x, xs)
| (_, [x, ...xs]) -> last(x, xs)
| (x, []) -> x
end

fun uncons([x, ...xs]) -> (x, xs) end


fun init
| ([x]) -> []
| ([x, ...xs]) -> x :: init(xs)
| ([]) ->  throw #EmptyListError
end

fun replicate
| (n of Int, x) when n >= 0 -> replicate(n, x, [])
| (0, _, l) -> l
| (n, x, l) -> replicate(n-1, x, x :: l)
end


generic seq
generic head
generic tail
generic is_empty
generic empty
generic cons
generic length

//TRANSFORMERS///////////////////////////////////////////////////////

def map(f of Callable, l of Seq) ->
    fun _map
         case (f, []) -> []
         case (f, [hd, ...tl]) -> cons(f(hd), _map(f, tl))
    end
    _map(f, l)
end

def intersperse(val, l of Seq) ->
    fun _intersperse
        case (val, []) -> []
        case (val, [hd, ...tl]) -> cons(hd, cons(val, _intersperse(val, tl)))
    end
    _intersperse(val, l)
end

def reverse(l of Seq) ->
    fun _acc
        case ([], result) -> result
        case ([hd, ...tl], result) -> _acc(tl, cons(hd, result))
    end
    _acc(l, [])
end

//REDUCERS///////////////////////////////////////////////////////

def foldl(f of Callable, init_val, l of Seq) ->
    fun _foldl
        case (f, acc, []) -> acc
        case (f, acc, [hd, ...tl]) ->
            try
                foldl(f, f(hd, acc), tl)
            catch e
                if e == #StopIteration
                    acc
                else
                   throw e;
            end
    end
    _foldl(f, init_val, l)
end


def foldr(f of Callable, init_val, l of Seq) ->
    fun _foldr
        case (f, acc, []) -> acc
        case (f, acc, [hd, ...tl]) ->
            try
                 f(hd, foldr(f, acc, tl))
            catch e
                if e == #StopIteration
                    acc
                else
                   throw e;
            end
    end
    _foldr(f, init_val, l)
end

///ACCESSORS//////////////////////////////////////

def nth_tail
    case (0, L) -> L
    case (1, [_, ...T]) -> T
    case (N, [_, ...T]) ->
        nth_tail(N - 1, T) when N >= 0 else throw (#InvalidIndex, N)
end

def nth
    case (0, L) -> L
    case (1, [H, ...T]) -> H
    case (N, [H, ...T]) ->
        nth(N - 1, T) when N >= 0 else throw (#InvalidIndex, N)
end


def length(l of Seq) ->
    foldl(fun (_, acc) -> acc + 1 end, 0, l);

//QUERIES///////////////////////////////////////////////////

def prefix
    case ([hd, ...pre_tail], [hd, ...tail]) -> prefix(pre_tail, tail)
    case ([], l) -> true
    case ([_, ..._], l) -> false
end

def suffix(suf of Seq, l of Seq) ->
   delta = length(l) - length(suf)
   delta >= 0 and nth_tail(delta, l) == suf
end

//SUBLISTS/////////////////////////////////////////////////////////////

def drop(count of Integer, l of Seq) ->
    fun _drop
        case (0, l) -> l
        case (count, [hd, ...tl]) -> _drop(count - 1, tl);
    _drop(count, l)
end

//BUILDERS/////////////////////////////////////////////////////////////

def concat(l1 of Seq, l2 of Seq) ->
     foldr(cons, l2, l1);

load testit
{assert_equal, assert_equal_batch, assert_throw, assert_throw_expected} = testit
def test ->
    f1 = def (a,b,c) ->
        print(a, b, c)
    end

    f1(1,2,3)

    def f2() -> print("def() ->  end") end
    f2()

    def f3 -> print("def ->  end") end
    f3()

    def f4(a,b,c,...rest) ->
        print(a,b,c,rest)
    end

    f4(1,2,3,4,5,6)

    def f5(x, (y,z), a, b, {name=name, age=(years, month)}, ...rest) ->
        print("x",x, "(y,z)", (y,z),
                "a", a,"b",b,"{name=name, age=(years, month)}", name, years, month,"rest", rest )
    end
    f5(1, (2,3), 4,5, {name=6, age=(7,8)}, 9,10,11,12)

    def fact
        case (0) -> 1
        case (n) -> n * fact(n - 1);

    assert_equal(fact(7), 5040)
    assert_equal(fact(0), 1)

    def func1
        case (1,2,3,4,5,var0, var1, var2, ...var4) -> (var0, var1, var2, var4)
        case ({key1, var1 @ key2, key3=25}, [var2, :second, var3 @ :third, ...var4]) -> (var1, var2, var3, var4)
        case (var6, var7) -> var6 + var7
        case (42) -> "Main question answer"
        case (_) -> :nothing;


    assert_equal(func1(1,2,3,4,5,6,7,8,9,10,11),
                    (6, 7, 8, (9, 10, 11)))
    assert_equal(
        func1({key1=:key1, key2=:key2, key3=25}, [:first, :second, :third, 4,5,6,7])
        ,(:key2, :first, :third, [4, 5, 6, 7]))

    def func2
        case (a,b,c) -> (:first, a, b, c)
        case (a, b) -> (:second, a, b)
        case (a) -> (:third, a)
        case () -> (:fourth);

    assert_equal_batch(
              func2,
              ((1,2,3), (:first, 1,2,3)),
              ((4,5), (:second, 4,5)),
              ((6,), (:third, 6)),
              ([], :fourth)
    )


    assert_equal(apply(def () -> :empty end, ()), :empty)
    assert_equal(apply(def -> :empty end, ()), :empty)

    def func3
        case (1) -> :first
        case (42) -> :second
        case () -> :third;

    assert_equal_batch(
              func3,
              ([1], :first),
              ([42], :second),
              ((), :third)
    )

    ////////////////////////////////////////////////////

    // when possible function compiles
    // into destructive assignment automaton instead of more complicated pattern matching graph
    //destruct func
    def fn_simple(arg1, arg2, ...rest) -> (arg1, arg2, rest) end
    //case func
    def fn_case(arg1, arg2 of Integer,  ...rest) -> (arg1, arg2, rest) end

    assert_equal(fn_simple(0,1,4,5,6), fn_case(0,1,4,5,6))

    ////////////////////////////////////////////////////

    //destruct func
    def fn_simple1(arg1, arg2, {key1, key2}, ...rest) -> (arg1, arg2, key1, key2, rest) end
    //case func
    def fn_case1(arg1, arg2, { var1 @ key1=2, key2} of Map, ...rest) -> (arg1, arg2, var1, key2, rest) end

    assert_equal(fn_simple1(0,1, {key1=2, key2=3}, 4,5,6), fn_case1(0,1, {key1=2, key2=3}, 4,5,6))

    ////////////////////////////////////////////////////
    assert_equal(
        def (x, y) ->
            x + y end (2,3),
        5)

    ////////////////////////////////////////////////////
    def fn_fail
        case (1) -> :one
        case (2) -> :two
        case (3) -> :three
        case (4) -> :four;

    assert_equal_batch(fn_fail,
        ([1], :one),
        ([2], :two),
        ([3], :three),
        ([4], :four))
    1 / 0
    assert_throw(fn_fail, [5])
    assert_throw_expected(fn_fail, [0], (:FunctionArgumentsMatchError,))
    assert_equal(
        try
           fn_fail("I am string")
        catch exc
           [exc, exc, exc];
        , [(:FunctionArgumentsMatchError,), (:FunctionArgumentsMatchError,), (:FunctionArgumentsMatchError,)]
    )

end
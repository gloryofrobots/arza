load affirm

// SYNTAX
def `++++/` -> 42 end
def `++>>`(x,y) -> 42 end
def `++-__+` case (x,y) -> 42 end
def `++---^--^`
    case (x,y) -> 42 end

// compiler single pass problem example
//    [fun length(x) -> 1 + length(x - 1) when x > 0 else 0 end]
//    fun Y(y) -> length(y) end
//    Y(3)

def test ->
    f1 = fun (a, b, c) -> (a, b, c) end
    affirm.is_equal(f1(1,2,3), (1,2,3))
    //call after declaration
    affirm.is_equal(
        (fun (a,b,c) -> (c, b, a) end)(1,2,3),
        (3,2,1)
    )
    affirm.is_equal(
        fun (a,b,c) -> (c, b, a) end(1,2,3),
        (3,2,1)
    )
    //////////////////////////////////////////////////////////////////////////

    fun f4(a,b,c,...rest) ->
            [a, b, c, rest] end

    affirm.is_equal(f4(1,2,3,4,5,6), [1, 2, 3, (4, 5, 6)])

    //////////////////////////////////////////////////////////////////////////

    fun f5(x, (y,z), a, b, {name=name, age=(years, month)}, ...rest) ->
        (x, y, z, a, b, name, years, month, rest)
    end
    affirm.is_equal(f5(1, (2,3), 4,5, {name=6, age=(7,8)}, 9,10,11,12), (1, 2, 3, 4, 5, 6, 7, 8, (9, 10, 11, 12)))

    //////////////////////////////////////////////////////////////////////////

    fun fact
        case (0) -> 1
        case (n) -> n * fact(n - 1);

    affirm.is_equal(fact(7), 5040)
    affirm.is_equal(fact(0), 1)

    fun func1
        case (1,2,3,4,5,var0, var1, var2, ...var4) -> (var0, var1, var2, var4)
        case ({key1, var1 @ key2, key3=25}, [var2, #second, var3 @ #third, ...var4]) -> (var1, var2, var3, var4)
        case (var6, var7) -> var6 + var7
        case (42) -> "Main question answer"
        case (_) -> #nothing;


    affirm.is_equal(func1(1,2,3,4,5,6,7,8,9,10,11),
                    (6, 7, 8, (9, 10, 11)))
    affirm.is_equal(
        func1({key1=#key1, key2=#key2, key3=25}, [#first, #second, #third, 4,5,6,7])
        ,(#key2, #first, #third, [4, 5, 6, 7]))

    fun func2
        case (a,b,c) -> (#first, a, b, c)
        case (a, b) -> (#second, a, b)
        case (a) -> (#third, a)
        case () -> (#fourth);

    affirm.is_equal_batch(
              func2,
              ((1,2,3), (#first, 1,2,3)),
              ((4,5), (#second, 4,5)),
              ((6,), (#third, 6)),
              ([], #fourth)
    )


    affirm.is_equal(apply(fun () -> #empty end, ()), #empty)
    affirm.is_equal(apply(fun -> #empty end, ()), #empty)

    fun func3
        case (1) -> #first
        case (42) -> #second
        case () -> #third;

    affirm.is_equal_batch(
              func3,
              ([1], #first),
              ([42], #second),
              ((), #third)
    )

    ////////////////////////////////////////////////////

    // when possible function compiles
    // into destructive assignment automaton instead of more complicated pattern matching graph
    //destruct func
    fun fn_simple(arg1, arg2, ...rest) -> (arg1, arg2, rest) end
    //case func
    fun fn_case(arg1, arg2 of Integer,  ...rest) -> (arg1, arg2, rest) end

    affirm.is_equal(fn_simple(0,1,4,5,6), fn_case(0,1,4,5,6))

    ////////////////////////////////////////////////////

    //destruct func
    fun fn_simple1(arg1, arg2, {key1, key2}, ...rest) -> (arg1, arg2, key1, key2, rest) end
    //case func
    fun fn_case1(arg1, arg2, { var1 @ key1=2, key2} of Map, ...rest) -> (arg1, arg2, var1, key2, rest) end

    affirm.is_equal(fn_simple1(0,1, {key1=2, key2=3}, 4,5,6), fn_case1(0,1, {key1=2, key2=3}, 4,5,6))

    ////////////////////////////////////////////////////
    affirm.is_equal(
        fun (x, y) ->
            x + y end (2,3),
        5)

    ////////////////////////////////////////////////////
    fun fn_fail
        case (1) -> #one
        case (2) -> #two
        case (3) -> #three
        case (4) -> #four;

    affirm.is_equal_batch(fn_fail,
        ([1], #one),
        ([2], #two),
        ([3], #three),
        ([4], #four))

    affirm.is_throw(fn_fail, [5])
    affirm.is_throw_expected(fn_fail, [0], (#FunctionArgumentsMatchError,))
    affirm.is_equal(
        try
           fn_fail("I am string")
        catch exc
           [exc, exc, exc];
        , [(#FunctionArgumentsMatchError,), (#FunctionArgumentsMatchError,), (#FunctionArgumentsMatchError,)]
    )

    ////////////////////////////////////////////////
    //Empty args first
    affirm.is_equal_batch(
        fun case () -> 42
            case (x,y) -> x + y;,
        ((1,2), 3),
        ((), 42))

    ////////////////////////////////////////////////
    affirm.is_equal(fun () -> 42 end(), 42)
    affirm.is_equal(fun -> 42 end(), 42)
end
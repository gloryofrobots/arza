import affirm

union Ordering | EQ | GT | LT
------

trait Equal x
    method eq x y -> not (ne x y)
    method ne x y -> not (eq x y)
---

trait Order x
    method le x y -> (cmp x y) != GT
    method lt x y -> (cmp x y) == LT
    method ge x y -> (cmp x y) != LT
    method gt x y -> (cmp x y) == GT
    method cmp x y ->
        condition
        | eq x x -> EQ
        | le x y -> LT
        | otherwise -> GT
        ---

    method max x y ->
        condition
        | x `le` y -> y
        | otherwise -> y
        ----

    method min x y ->
        condition
        | x `le` y -> x
        | otherwise -> y
        -------
-----

type Val v
---

type Val2 v
---

implement Equal for Val
    method eq
        | v1 v2 -> v1.v == v2.v
---

implement Equal for Val2
    method ne
        | v1 v2 -> v1.v != v2.v
---

implement Order for Val
    method cmp
        | self other ->
            condition
            | self.v == other.v -> EQ
            | self.v <= other.v -> LT
            | otherwise -> GT
            ---
-------

implement Order for Val2
    method le | self other -> self.v <= other.v
-------


fun test () ->
    v1_1 = (Val 1)
    v1_2 = (Val 1)
    v1_3 = Val 2

    v2_1 = Val2 1
    v2_2 = Val2 1
    v2_3 = Val2 2

    affirm:is_true (eq v1_1 v1_2)
    affirm:is_false (ne v1_1 v1_2)
    affirm:is_false (eq v1_3 v1_2)
    affirm:is_false (eq v1_2 v1_3)

    affirm:is_true (eq v2_1 v2_2)
    affirm:is_false (ne v2_1 v2_2)
    affirm:is_false (eq v2_3 v2_2)
    affirm:is_false (eq v2_2 v2_3)

    affirm:is_true (eq v1_1 v2_2)
    affirm:is_false (ne v2_1 v1_2)
    affirm:is_false (eq v1_3 v2_2)
    affirm:is_false (eq v1_2 v2_3)

    affirm:is_false (lt v1_3 v1_3)
    affirm:is_true (le v1_3 v1_3)
    affirm:is_false (gt v1_3 v1_3)
    affirm:is_true (ge v1_3 v1_3)

    affirm:is_false (lt v2_3 v2_3)
    affirm:is_true (le v2_3 v2_3)
    affirm:is_false (gt v2_3 v2_3)
    affirm:is_true (ge v2_3 v2_3)
end

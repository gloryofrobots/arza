

module customers(panic, log)
    trait Hungry, Adult, Customer, Vegan, Ordinary, Child, Male, Female

    generic visit(self of Customer, cort of FoodCort) ->
        foodcort:prepare(cort, self, self.money) end


    func customer(traits, name, money) ->
        {name=name, money=money} isa traits ++ [Customer] end

    func adult_customer = Adult => customer(adult)


    def customer(traits, name, money) ->

    def vegan(name, money, beard_size) ->
       customer(name, money) {beard_size=beard_size} end

    ordinary = Ordinary => customer

    def child(name, parent) ->
        customer(name, parent.money) {parent=parent} nota Adult isa [Child, Hungry] end
end




module customers
    trait Hungry
    trait Male
    trait Female

    origin Adult
        case (passport_id) ->
            {passport_id = passport_id};

    origin Child
        case (parent) ->
            {parent = parent};

    origin Customer
        case(name, money) ->
            {name = name, money = money};

    origin AdultCustomer(Customer, Adult);
    origin Vegan(AdultCustomer)
        case (self, beard_size) -> self {beard_size=beard_size};

    origin Ordinary(Customer)
    origin ChildCostumer(Costumer, Child)
        case (self) ->
            delete(self, :money);

    generic visit(self of Customer, cort of FoodCort) =>
        foodcort:prepare(cort, self, self.money);

end

module customers
    trait Customer;
    trait Vegan
    trait Ordinary

    origin Customer(*traits) ->
        func (name, money) ->
           {name, money, traits}

    generic visit(self of Customer, cort of FoodCort) =>
        foodcort:prepare(cort, self, self.money)
    end

    func customer(name, money, traits) ->
        object({name=name, money=money}, traits :: [Customer]) end

    func vegan(name, money) ->
        _customer(name, money, Vegan) end

    func ordinary(name, money) ->
        _customer(name, money, Ordinary) end
end
#########################################################################

module items

exports packing, pack, VegBurger, ChickenBurger, Pepsi, Coke

trait Item
trait Burger
trait ColdDrink

trait Wrapper
trait Bottle


generic _item(traits of Enumerable, price of Float, name of String) =>
     construct (concat(traits, Item),
                    record {price=price, name=name})
end


origin VegBurger() =>
    _item([VegBurger, Burger], 0.25, "VegBurger")
end


origin ChickenBurger() =>
    _item([ChickenBurger, Burger], 40.45, "ChickenBurger")
end


origin Pepsi() =>
    _item([Pepsi, ColdDrink], 1.45, "Pepsi")
end

origin Coke() =>
    _item([Coke, ColdDrink], 1.65, "Coke")
end


generic pack =>
   case (self of Wrapper) =>
      print("Wrapper of ", self.label) end

   case (self of Bottle) =>
      print("Bottle", self.label, " volume: ", self.volume) end
end


generic packing =>
   case (self of Burger) =>
      construct(Wrapper, { label = "Burger"})
   end

    case (self of ColdDrink) =>
      construct(Bottle, { label = "ColdDrink", volume = 1.0})
    end
end

#########################################################################

module foodcort
exports cost, NotEnoughMoneyError, prepare
trait NotEnoughMoneyError;

func cost(meal) =>
    if meal isnot nil
        reduce(func(item, result) =>
                    result + item.price
               end,
               0.0,
             meal as Vector)
    else
        nil
    end
end



// It answers to append and all other list funcs
origin Menu(items) =>
    construct([Menu], items) end


specify __tostring__(self of Menu) =>
    each(func(item) =>
            string.build(
                         "Item", string.nl,
                         "name", item.name, string.nl,
                         "price", item.price, string.nl
                          "packing", items.packing(item)
                        )
           end,
           self as Vector);;


origin FoodCort =>
    construct(FoodCort, nil) end


generic prepare =>
    func check_amount(menu, money) =>
        if cost(menu) > money
            throw Error(NotEnoughMoneyError,
                            {"money"=money}) 
        end
    end

    case (cort of FoodCort, customer of customers.Vegan, money of Float) =>
        menu = Menu([items.VegBurger(), items.Coke()])
        check_amount(menu, money) 
    end


    case (cort of FoodCort, customer of customers.Ordinary, money of Float) =>
        menu = Menu([items.ChickenBurger(), items.Pepsi()])
        check_amount(menu, money) 
    end 
end

OliveGarden = FoodCort()

Joe = customers.Vegan()
Bob = customers.Ordinary()
Joe.visit(OliveGarden)
Bob.visit(OliveGarden)
visit(Joe, OliveGarden)

reduce(`+`,
  func BigFun() =>
    if x == 25 
      print(x)
      =>_some_work(x)
      y = 23 - 34
    elif x == 23 
      x = 12
      print (x)
      x -= 134
    else
      x = 12
      x = 456
    end
  end, [1,2,3,3,4,5])


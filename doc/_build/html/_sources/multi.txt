Interfaces and multimethods
===========================

.. highlight:: arza


Arza's approach to polymorphism is probably the most original part of the language

If you want to learn in details about multiple dispatch you can read excelent Eli Bendersky's articles
https://eli.thegreenplace.net/2016/a-polyglots-guide-to-multiple-dispatch/


Arza uses generic functions with multiple dispatch and intefaces that restricts and formalises relations
between types and generics.

Interface is a term that most often is an attribute of object oriented system. It describes set of operations
that specific class can do.

But how can concept of interfaces can be applied to multimethods?
In Arza interface can be described as a set of generic functions and specific argument positions in this functions.

For example

::

   interface Storage =
      get(storage of Storage, key)

   interface Key =
      use get(storage, key of Key)

In example above we declare two interfaces that share the same generic function :code:`get`.

Expression :code:`storage of Storage` bind first argument of function :code:`get` to interface :code:`Storage`.

Interface :code:`Storage` will be implemented by all types that act like first arguments in :code:`get`.
Interface :code:`Key` will be implemented by all types that act like second arguments in :code:`get`.

The same code can be written in shorter way

::

   // all declarations are equivalent

   interface Storage =
      get(Storage, key)

   //here I is interface alias
   interface Storage(I) =
      get(storage of I, key)

   // or even shorter
   interface Storage(I) =
      get(I, key)


**Generic function can be declared only inside interface. They can not be declared twice**

::

   interface Storage =
      get(storage of Storage, key)

   interface Key =
      // this is error, function get already declared above
      get(storage, key of Key)
      // instead define reference with `use` expression
      use get(storage, key of Key)

Interfaces do not create namespaces, our function :code:`get`
will be available as :code:`get`, not as :code:`Storage:get`

**Generic function will dispatch only on arguments for whom interfaces are declared.**


Interfaces in Arza perform two important functions

* Formalisation of type behavior. Consider Arza's pattern matching.
  If custom type used as first argument in :code:`first` and :code:`rest` generics,
  it can be destructured by :code:`x::xs and [x, x1, ...xs]` patterns.

  Because in prelude  there is interface 

  ::

    interface Seq =
        first(Seq)
        rest(Seq)

  Compiler just perform this check :code:`arza:is_implemented(customtype, Seq)`

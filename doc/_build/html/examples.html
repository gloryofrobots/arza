<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">


<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    
    <title>Code examples &mdash; arza 0.1 documentation</title>
    
    <link rel="stylesheet" href="_static/default.css" type="text/css" />
    <link rel="stylesheet" href="_static/pygments.css" type="text/css" />
    
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    './',
        VERSION:     '0.1',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true
      };
    </script>
    <script type="text/javascript" src="_static/jquery.js"></script>
    <script type="text/javascript" src="_static/underscore.js"></script>
    <script type="text/javascript" src="_static/doctools.js"></script>
    <link rel="top" title="arza 0.1 documentation" href="index.html" />
    <link rel="prev" title="Processes" href="process.html" /> 
  </head>
  <body>
    <div class="related">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="process.html" title="Processes"
             accesskey="P">previous</a> |</li>
        <li><a href="index.html">arza 0.1 documentation</a> &raquo;</li> 
      </ul>
    </div>  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body">
            
  <div class="section" id="code-examples">
<h1>Code examples<a class="headerlink" href="#code-examples" title="Permalink to this headline">¶</a></h1>
<div class="section" id="simple-game">
<h2>Simple game<a class="headerlink" href="#simple-game" title="Permalink to this headline">¶</a></h2>
<div class="highlight-arza"><div class="highlight"><pre><span class="cm">// This is simple battleship game</span>
<span class="cm">// All ships have 1x1 size and they don&#39;t move throughout course of the game</span>
<span class="cm">// gameplay consists of random shooting by each of the ships</span>

<span class="cm">// module imports</span>
<span class="cm">// print functions</span>
<span class="k">import</span> <span class="n">io</span>
<span class="cm">// sequence combinators</span>
<span class="k">import</span> <span class="n">seq</span>
<span class="k">import</span> <span class="n">string</span>
<span class="cm">// test assertions</span>
<span class="k">import</span> <span class="n">affirm</span>

<span class="cm">// type declaration</span>
<span class="k">type</span> <span class="n">Ship</span>(<span class="n">id</span>, <span class="n">hp</span>, <span class="n">pos</span>)

<span class="cm">// defining method for generic function str which will be called by print function</span>

<span class="k">def</span> <span class="n">str</span>({<span class="n">id</span>, <span class="n">hp</span>, <span class="n">pos</span>} <span class="k">of</span> <span class="n">Ship</span>) =
    <span class="cm">// Arza lacks sprintf for now, instead this is simple concatenation</span>
    <span class="n">string</span>:<span class="n">all</span>(<span class="s">&quot;&lt;Ship id=&quot;</span>, <span class="n">id</span>, <span class="s">&quot; hp=&quot;</span>, <span class="n">hp</span>, <span class="s">&quot; pos=&quot;</span>, <span class="n">pos</span>, <span class="s">&quot;&gt;&quot;</span>)

<span class="cm">// Other type with initializer</span>
<span class="cm">// Product of this type will be value which initializer returns</span>
<span class="k">type</span> <span class="n">Game</span>(<span class="n">cols</span>, <span class="n">rows</span>, <span class="n">ships</span>, _<span class="n">id</span>)
    <span class="k">init</span>(<span class="n">game</span>, <span class="n">cols</span>, <span class="n">rows</span>) =
        <span class="n">game</span>.{
            <span class="cm">// field attrs</span>
            <span class="n">rows</span> = <span class="n">rows</span>,
            <span class="n">cols</span> = <span class="n">cols</span>,
            <span class="cm">// list with ships, list is not a best type of data structure here but the simplest one</span>
            <span class="n">ships</span>=[],
            <span class="cm">// special id increment for new ships</span>
            _<span class="n">id</span>=0
        }


<span class="k">def</span> <span class="n">str</span>({<span class="n">rows</span>, <span class="n">cols</span>, <span class="n">ships</span>} <span class="k">of</span> <span class="n">Game</span>) =
    <span class="n">string</span>:<span class="n">all</span>(
        <span class="s">&quot;&lt;Game (&quot;</span>,
        <span class="n">rows</span>,
        <span class="s">&quot;, &quot;</span>,
        <span class="n">cols</span>,
        <span class="s">&quot;) &quot;</span>,
        <span class="cm">// if is an expression like almost everything</span>
        <span class="k">if</span> <span class="n">not</span> <span class="n">is</span>_<span class="n">empty</span>(<span class="n">ships</span>) <span class="k">then</span> <span class="s">&quot;ships: </span><span class="se">\n</span><span class="s">....&quot;</span> <span class="k">else</span> <span class="s">&quot;&quot;</span>,
        <span class="n">string</span>:<span class="n">join</span>(<span class="s">&quot;</span><span class="se">\n</span><span class="s">....&quot;</span>, <span class="n">ships</span>),
        <span class="s">&quot; &gt;&quot;</span>
    )

<span class="cm">// checking if position is on board</span>
<span class="k">fun</span> <span class="n">is</span>_<span class="n">valid</span>_<span class="n">pos</span>({<span class="n">rows</span>, <span class="n">cols</span>}, (<span class="n">x</span>, <span class="n">y</span>) <span class="k">as</span> <span class="n">pos</span>) =
    <span class="n">x</span> &gt;= 0 <span class="k">and</span> <span class="n">x</span> &lt; <span class="n">cols</span> <span class="k">and</span> <span class="n">y</span> &gt;= 0 <span class="k">and</span> <span class="n">y</span> &lt; <span class="n">rows</span>

<span class="cm">// add ship and return new game record</span>
<span class="cm">// because values are immutable in arza</span>
<span class="k">fun</span> <span class="n">add</span>_<span class="n">ship</span>(<span class="n">game</span>, <span class="n">pos</span>) =
    <span class="cm">// increment id counter</span>
    <span class="k">let</span> <span class="n">new</span>_<span class="n">id</span> = <span class="n">game</span>._<span class="n">id</span> + 1
    <span class="cm">// create new ship with 2 hit points</span>
    <span class="k">let</span> <span class="n">ship</span> = <span class="n">Ship</span>(<span class="n">new</span>_<span class="n">id</span>, 2, <span class="n">pos</span>)
    <span class="cm">// .{ operator allows to create modified immutable structure</span>
    <span class="cm">// here we creating new instance of Game from old one with changed keys _id and ships</span>
    <span class="cm">// @ placeholder means previous value and :: is cons operator</span>
    <span class="n">game</span>.{
        _<span class="n">id</span> = <span class="n">new</span>_<span class="n">id</span>,
        <span class="n">ships</span> = <span class="n">ship</span>::@
        <span class="cm">// can be written as</span>
        <span class="cm">// ships = cons(ship, @)</span>
    }


<span class="cm">// using seq module for finding ship at pos ship_pos</span>
<span class="k">fun</span> <span class="n">atpos</span>({<span class="n">ships</span>} <span class="k">of</span> <span class="n">Game</span>, <span class="n">ship</span>_<span class="n">pos</span>) =
    <span class="cm">// function arguments are subjects of pattern matching</span>
    <span class="cm">// {ships} of Game means argument must be of type Game</span>
    <span class="cm">// and must implement Map interface and has attribute ships</span>
    <span class="cm">// binding ships will be created</span>
    <span class="n">seq</span>:<span class="n">find</span>_<span class="n">with</span>(
        <span class="n">ships</span>,
        <span class="cm">// default value</span>
        <span class="n">None</span>,
        <span class="cm">//lambda expression</span>
        <span class="n">ship</span> -&gt; <span class="n">ship</span>_<span class="n">pos</span> == <span class="n">ship</span>.<span class="n">pos</span>
    )


<span class="k">fun</span> <span class="n">update</span>_<span class="n">ship</span>(<span class="n">game</span>, <span class="n">newship</span>) =
    <span class="cm">// modifing game.ships</span>
    <span class="n">game</span>.{
        <span class="n">ships</span> = <span class="n">seq</span>:<span class="n">map</span>(
            <span class="cm">// equivalent to game.ships</span>
            @,
            <span class="cm">// using parens to delimit multi expression function</span>
            (<span class="k">fun</span>(<span class="n">ship</span>) =
                (<span class="k">if</span> <span class="n">ship</span>.<span class="n">id</span> == <span class="n">newship</span>.<span class="n">id</span> <span class="k">then</span>
                    <span class="n">newship</span>
                <span class="k">else</span>
                    <span class="n">ship</span>))
        )
    }


<span class="cm">// fire at random position</span>
<span class="k">fun</span> <span class="n">fire</span>({<span class="n">rows</span>, <span class="n">cols</span>} <span class="k">as</span> <span class="n">game</span>, <span class="n">ship</span>) =
    <span class="k">let</span>
        <span class="n">x</span> = <span class="n">randi</span>(0, <span class="n">rows</span>)
        <span class="n">y</span> = <span class="n">randi</span>(0, <span class="n">cols</span>)
        <span class="n">fire</span>_<span class="n">pos</span> = (<span class="n">x</span>, <span class="n">y</span>)

    <span class="k">if</span> <span class="n">fire</span>_<span class="n">pos</span> == <span class="n">ship</span>.<span class="n">pos</span> <span class="k">then</span>
        <span class="cm">//retry</span>
        <span class="n">fire</span>(<span class="n">game</span>, <span class="n">ship</span>)
    <span class="k">else</span>
        <span class="n">fire</span>_<span class="n">at</span>(<span class="n">game</span>, <span class="n">ship</span>, <span class="n">fire</span>_<span class="n">pos</span>)


<span class="cm">// as operator in pattern matching will bind left value to right name in case of successful branch</span>
<span class="k">fun</span> <span class="n">fire</span>_<span class="n">at</span>({<span class="n">rows</span>, <span class="n">cols</span>, <span class="n">ships</span>} <span class="k">as</span> <span class="n">game</span>, <span class="n">ship</span>, <span class="n">fire</span>_<span class="n">pos</span>) =
    <span class="k">let</span> <span class="n">enemy</span> = <span class="n">atpos</span>(<span class="n">game</span>, <span class="n">fire</span>_<span class="n">pos</span>)
    <span class="cm">// if we found enemy change its hp</span>
    <span class="cm">// this all immutable of course, so we return new game state</span>
    <span class="k">match</span> <span class="n">enemy</span>
        | <span class="n">enemy</span> <span class="k">of</span> <span class="n">Ship</span> =
            <span class="n">update</span>_<span class="n">ship</span>(<span class="n">game</span>, <span class="n">enemy</span>.{<span class="n">hp</span> = @ - 1})
        | <span class="n">None</span> =
            <span class="n">game</span>


<span class="k">fun</span> <span class="n">turn</span>({<span class="n">rows</span>, <span class="n">cols</span>, <span class="n">ships</span>} <span class="k">as</span> <span class="n">game</span>) =
    <span class="cm">// this basically foreach through all ships</span>
    <span class="cm">// foldl is used because we can put current state as accumulator</span>
    <span class="cm">/*</span>
<span class="cm">        foldl is basically this function</span>
<span class="cm">        fun foldl</span>
<span class="cm">            | ([], acc, f) = acc</span>
<span class="cm">            | (hd::tl, acc, f) = foldl(tl, f(hd, acc), f)</span>
<span class="cm">    */</span>
    <span class="n">seq</span>:<span class="n">foldl</span>(
        <span class="n">ships</span>,
        <span class="n">game</span>,
        <span class="k">fun</span> (<span class="n">ship</span>, <span class="n">new</span>_<span class="n">game</span>) =
            <span class="n">fire</span>(<span class="n">new</span>_<span class="n">game</span>, <span class="n">ship</span>)
    )


<span class="cm">// win conditions</span>
<span class="cm">// all ships are dead then draw</span>
<span class="cm">// if one ship alive she is the winner</span>
<span class="cm">// else continue playing</span>
<span class="k">fun</span> <span class="n">checkgame</span>(<span class="n">game</span>) =
    <span class="k">let</span> (<span class="n">alive</span>, <span class="n">dead</span>) = <span class="n">seq</span>:<span class="n">partition</span>(<span class="n">game</span>.<span class="n">ships</span>, <span class="k">fun</span>({<span class="n">hp</span>}) = <span class="n">hp</span> &gt; 0 )
    <span class="k">match</span> <span class="n">alive</span>
        | [] = (<span class="n">game</span>, (<span class="s">#DRAW,</span> <span class="s">&quot;All dead&quot;</span>))
        | <span class="n">x</span>::[] = (<span class="n">game</span>, (<span class="s">#WINNER,</span> <span class="n">x</span>))
        | _ = <span class="n">None</span>


<span class="cm">// This game main loop</span>
<span class="cm">// This type of function is called recursive wrappers in arza</span>
<span class="cm">// first branch will be executed only once</span>
<span class="cm">// and subsequent calls will not check when count &gt; 0 guard</span>
<span class="k">fun</span> <span class="n">run</span>(<span class="n">game</span>, <span class="n">count</span>) <span class="n">when</span> <span class="n">count</span> &gt; 0
    | (<span class="n">game</span>, 0) = (<span class="n">game</span>, (<span class="s">#DRAW,</span> <span class="s">&quot;Time is out&quot;</span>))
    | (<span class="n">game</span>, <span class="n">count</span>_<span class="n">turns</span>) =
        <span class="k">let</span> <span class="n">game</span>1 = <span class="n">turn</span>(<span class="n">game</span>)
        <span class="k">match</span> <span class="n">checkgame</span>(<span class="n">game</span>1)
            | <span class="n">None</span> = <span class="n">run</span>(<span class="n">game</span>1, <span class="n">count</span>_<span class="n">turns</span> - 1)
            | <span class="n">result</span> = <span class="n">result</span>


<span class="cm">// just simple random game</span>
<span class="k">fun</span> <span class="n">random</span>_<span class="n">game</span>() =
    <span class="k">let</span>
        <span class="n">size</span> = 4
        <span class="n">pos</span> = () -&gt; <span class="n">randi</span>(0, <span class="n">size</span>)
        (<span class="n">game</span>, <span class="n">result</span>) = <span class="n">Game</span>(<span class="n">size</span>, <span class="n">size</span>)
                |&gt; <span class="n">add</span>_<span class="n">ship</span>(_, (<span class="n">pos</span>(), <span class="n">pos</span>()))
                |&gt; <span class="n">add</span>_<span class="n">ship</span>(_, (<span class="n">pos</span>(), <span class="n">pos</span>()))
                |&gt; <span class="n">run</span>(_, 100)
    <span class="n">io</span>:<span class="n">p</span>(<span class="s">#GAME,</span> <span class="n">game</span>)
    <span class="n">io</span>:<span class="n">p</span>(<span class="s">#RESULT,</span> <span class="n">result</span>)


<span class="cm">// and some testing</span>
<span class="k">fun</span> <span class="n">test</span>() =
    <span class="k">fun</span> <span class="n">test</span>_<span class="n">game</span>() =
        <span class="k">let</span> <span class="n">game</span> = <span class="n">Game</span>(4, 4)
                |&gt; <span class="n">add</span>_<span class="n">ship</span>(_, (3,1))
                |&gt; <span class="n">add</span>_<span class="n">ship</span>(_, (0,0))
        <span class="k">let</span> <span class="n">ship</span>1 = <span class="n">atpos</span>(<span class="n">game</span>, (3, 1))
        <span class="k">let</span> <span class="n">ship</span>2 = <span class="n">atpos</span>(<span class="n">game</span>, (0, 0))
        (<span class="n">game</span>, <span class="n">ship</span>1, <span class="n">ship</span>2)

    <span class="k">let</span>
        (<span class="n">game</span>, <span class="n">ship</span>1, <span class="n">ship</span>2) = <span class="n">test</span>_<span class="n">game</span>()
    <span class="k">in</span>
        <span class="k">let</span>
            (<span class="n">game</span>1, <span class="n">result</span>) = <span class="n">game</span>
                |&gt; <span class="n">fire</span>_<span class="n">at</span>(_, <span class="n">ship</span>1, <span class="n">ship</span>2.<span class="n">pos</span>)
                |&gt; <span class="n">fire</span>_<span class="n">at</span>(_, <span class="n">ship</span>2, <span class="n">ship</span>1.<span class="n">pos</span>)
                |&gt; <span class="n">fire</span>_<span class="n">at</span>(_, <span class="n">ship</span>1, <span class="n">ship</span>2.<span class="n">pos</span>)
                |&gt; <span class="n">fire</span>_<span class="n">at</span>(_, <span class="n">ship</span>2, <span class="n">ship</span>1.<span class="n">pos</span>)
                |&gt; <span class="n">checkgame</span>(_)
        <span class="k">in</span>
            <span class="n">affirm</span>:<span class="n">is</span>_<span class="n">equal</span>(<span class="n">result</span>.0, <span class="s">#DRAW)</span>

    <span class="k">let</span>
        (<span class="n">game</span>, <span class="n">ship</span>1, <span class="n">ship</span>2) = <span class="n">test</span>_<span class="n">game</span>()
    <span class="k">in</span>
        <span class="k">let</span>
            (<span class="n">game</span>1, (<span class="n">label</span>, <span class="n">winner</span>)) = <span class="n">game</span>
                |&gt; <span class="n">fire</span>_<span class="n">at</span>(_, <span class="n">ship</span>1, <span class="n">ship</span>2.<span class="n">pos</span>)
                |&gt; <span class="n">fire</span>_<span class="n">at</span>(_, <span class="n">ship</span>2, <span class="n">ship</span>1.<span class="n">pos</span>)
                |&gt; <span class="n">fire</span>_<span class="n">at</span>(_, <span class="n">ship</span>1, <span class="n">ship</span>2.<span class="n">pos</span>)
                |&gt; <span class="n">checkgame</span>(_)
        <span class="k">in</span>
            <span class="n">affirm</span>:<span class="n">is</span>_<span class="n">equal</span>(<span class="n">label</span>, <span class="s">#WINNER)</span>
            <span class="n">affirm</span>:<span class="n">is</span>_<span class="n">equal</span>(<span class="n">winner</span>.<span class="n">id</span>, <span class="n">ship</span>1.<span class="n">id</span>)
</pre></div>
</div>
</div>
<div class="section" id="mutable-state">
<span id="mutable-state-label"></span><h2>Mutable State<a class="headerlink" href="#mutable-state" title="Permalink to this headline">¶</a></h2>
<div class="highlight-arza"><div class="highlight"><pre><span class="cm">// this program will implement mutable state via processes</span>

<span class="k">import</span> <span class="n">process</span>
<span class="k">import</span> <span class="n">decor</span>

<span class="k">type</span> <span class="n">State</span>(<span class="n">pid</span>)

<span class="cm">// special error</span>
<span class="k">type</span> <span class="n">StateError</span> <span class="k">is</span> <span class="n">Error</span>

<span class="cm">// because State will implement at generic all calls like state.key or</span>
<span class="cm">// matches {key1, key2} will be infinitely recursive</span>
<span class="cm">// to avoid this we need to cast state to parent Record type</span>
<span class="cm">// asrecord defined in prelude like fun asrecord(r) = r as Record</span>
<span class="k">fun</span> <span class="n">pid</span>(<span class="n">s</span>) = <span class="n">asrecord</span>(<span class="n">s</span>).<span class="n">pid</span>


<span class="k">fun</span> <span class="n">is</span>_<span class="n">valid</span>(<span class="n">s</span>) =
    <span class="n">not</span> <span class="n">process</span>:<span class="n">is</span>_<span class="n">finished</span>(<span class="n">pid</span>(<span class="n">s</span>))

<span class="k">fun</span> __<span class="n">ensure</span>_<span class="n">process</span>(<span class="n">s</span>) =
    <span class="k">if</span> <span class="n">not</span> <span class="n">is</span>_<span class="n">valid</span>(<span class="n">s</span>) <span class="k">then</span>
        <span class="k">throw</span> <span class="n">StateError</span>(<span class="s">&quot;Process inactive&quot;</span>)
    <span class="k">else</span>
        <span class="n">s</span>

<span class="cm">// creating assertion decorators as partially applied function decor:call_first</span>
<span class="k">let</span> <span class="n">ensure</span>1 = <span class="n">decor</span>:<span class="n">call</span>_<span class="n">first</span>(_, 1, __<span class="n">ensure</span>_<span class="n">process</span>)
<span class="k">let</span> <span class="n">ensure</span>2 = <span class="n">decor</span>:<span class="n">call</span>_<span class="n">first</span>(_, 2, __<span class="n">ensure</span>_<span class="n">process</span>)
<span class="k">let</span> <span class="n">ensure</span>3 = <span class="n">decor</span>:<span class="n">call</span>_<span class="n">first</span>(_, 3, __<span class="n">ensure</span>_<span class="n">process</span>)

<span class="cm">// trait is function which can operate on types</span>
<span class="cm">// traits have global side effects</span>
<span class="cm">// they used to specify behavior for one or more types</span>
<span class="cm">// and can be applied to different set of types with &#39;instance&#39; expression</span>
<span class="cm">// this is anonymous trait. They are used just for convinience to avoid typing long type names</span>

<span class="cm">// generic functions at, put has specific meaning in arza because expression</span>
<span class="cm">// x.y transforms by compiler into at(x, #y) and x.{y=1} into put(x, #y, 1)</span>
<span class="k">trait</span> (<span class="n">T</span>) <span class="k">for</span> <span class="n">State</span> =
    <span class="cm">// T means State</span>
    <span class="k">def</span> <span class="n">close</span>(<span class="n">s</span> <span class="k">of</span> <span class="n">T</span>) =
        <span class="n">process</span>:<span class="n">kill</span>(<span class="n">pid</span>(<span class="n">s</span>), 0)

    <span class="cm">// all ensure decorators assert that state process is not dead</span>
    @<span class="n">ensure</span>3
    <span class="k">def</span> <span class="n">put</span>(<span class="n">s</span> <span class="k">of</span> <span class="n">T</span>, <span class="n">key</span>, <span class="n">value</span>) =
        <span class="cm">// sending tuple to process</span>
        <span class="cm">// #put is symbol specifiing type of action</span>
        <span class="n">pid</span>(<span class="n">s</span>) ! (<span class="s">#put,</span> <span class="n">key</span>, <span class="n">value</span>)
        <span class="cm">// returning itself</span>
        <span class="n">s</span>

    @<span class="n">ensure</span>2
    <span class="k">def</span> <span class="n">at</span>(<span class="n">s</span> <span class="k">of</span> <span class="n">T</span>, <span class="n">key</span>) =
        <span class="cm">// sending request</span>
        <span class="n">pid</span>(<span class="n">s</span>) ! (<span class="s">#at,</span> <span class="n">self</span>(), <span class="n">key</span>)
        <span class="cm">// and receiving reply</span>
        <span class="k">receive</span> (<span class="s">#at,</span> <span class="n">val</span>) = <span class="n">val</span>

    @<span class="n">ensure</span>1
    <span class="k">def</span> &amp;(<span class="n">s</span> <span class="k">of</span> <span class="n">T</span>) =
        <span class="n">pid</span>(<span class="n">s</span>) ! (<span class="s">#get,</span> <span class="n">self</span>())
        <span class="k">receive</span> (<span class="s">#get,</span> <span class="n">val</span>) = <span class="n">val</span>

    @<span class="n">ensure</span>2
    <span class="k">def</span> := (<span class="n">s</span> <span class="k">of</span> <span class="n">T</span>, <span class="n">val</span>) =
        <span class="n">pid</span>(<span class="n">s</span>) ! (<span class="s">#set,</span> <span class="n">val</span>)
        <span class="n">s</span>

    @<span class="n">ensure</span>2
    <span class="k">def</span> <span class="n">del</span>(<span class="n">s</span> <span class="k">of</span> <span class="n">T</span>, <span class="n">el</span>) =
        <span class="n">pid</span>(<span class="n">s</span>) ! (<span class="s">#del,</span> <span class="n">el</span>)
        <span class="n">s</span>

    @<span class="n">ensure</span>2
    <span class="k">def</span> <span class="n">has</span>(<span class="n">s</span> <span class="k">of</span> <span class="n">T</span>, <span class="n">el</span>) =
        <span class="n">pid</span>(<span class="n">s</span>) ! (<span class="s">#has,</span> <span class="n">self</span>(), <span class="n">el</span>)
        <span class="k">receive</span> (<span class="s">#has,</span> <span class="n">val</span>) = <span class="n">val</span>

    @<span class="n">ensure</span>1
    <span class="k">def</span> <span class="n">arza</span>:<span class="n">len</span> (<span class="n">s</span> <span class="k">of</span> <span class="n">T</span>) =
        <span class="n">pid</span>(<span class="n">s</span>) ! (<span class="s">#len,</span> <span class="n">self</span>())
        <span class="k">receive</span> (<span class="s">#len,</span> <span class="n">val</span>) = <span class="n">val</span>

    @<span class="n">ensure</span>2
    <span class="k">def</span> ==(<span class="n">s</span> <span class="k">of</span> <span class="n">T</span>, <span class="n">data</span>) = &amp;<span class="n">s</span> == <span class="n">data</span>

    @<span class="n">ensure</span>1
    <span class="k">def</span> <span class="n">arza</span>:<span class="n">is</span>_<span class="n">empty</span>(<span class="n">s</span> <span class="k">of</span> <span class="n">T</span>) = <span class="n">len</span>(<span class="n">s</span>) &gt; 0


<span class="cm">// this is actual process</span>
<span class="k">fun</span> _<span class="n">loop</span>(<span class="n">data</span>) =
    <span class="cm">// this block will receive messages from other processes</span>
    <span class="k">receive</span>
        | (<span class="s">#set,</span> <span class="n">new</span>_<span class="n">data</span>) =
            <span class="cm">// just replace data</span>
            _<span class="n">loop</span>(<span class="n">new</span>_<span class="n">data</span>)

        | (<span class="s">#get,</span> <span class="n">pid</span>) =
            <span class="cm">// receiving action with receiver</span>
            <span class="cm">// replying to receiver</span>
            <span class="n">pid</span> ! (<span class="s">#get,</span> <span class="n">data</span>)
            <span class="cm">// going to loop again because otherwise process will be finished</span>
            _<span class="n">loop</span>(<span class="n">data</span>)

        | (<span class="s">#at,</span> <span class="n">pid</span>, <span class="n">key</span>) =
            <span class="n">pid</span> ! (<span class="s">#at,</span> <span class="n">data</span>.[<span class="n">key</span>])
            _<span class="n">loop</span>(<span class="n">data</span>)

        | (<span class="s">#has,</span> <span class="n">pid</span>, <span class="n">key</span>) =
            <span class="cm">// calling has generic func  as has operator</span>
            <span class="n">pid</span> ! (<span class="s">#has,</span> <span class="n">data</span> `<span class="n">has</span>` <span class="n">key</span>)
            _<span class="n">loop</span>(<span class="n">data</span>)

        | (<span class="s">#len,</span> <span class="n">pid</span>) =
            <span class="n">pid</span> ! (<span class="s">#len,</span> <span class="n">len</span>(<span class="n">data</span>))
            _<span class="n">loop</span>(<span class="n">data</span>)

        | (<span class="s">#put,</span> <span class="n">key</span>, <span class="n">val</span>) = _<span class="n">loop</span>(<span class="n">data</span>.{(<span class="n">key</span>)=<span class="n">val</span>})

        | (<span class="s">#del,</span> <span class="n">key</span>) = _<span class="n">loop</span>(<span class="n">del</span>(<span class="n">data</span>, <span class="n">key</span>))
        | <span class="n">msg</span> = <span class="k">throw</span> (<span class="s">#InvalidMessage,</span> <span class="n">msg</span>)

<span class="cm">//constructor function</span>
<span class="cm">/*</span>
<span class="cm">    you can use this module like</span>
<span class="cm">    import state</span>
<span class="cm">    let s = state:new({x=1, y=2, z=3})</span>
<span class="cm">    updates state structure</span>
<span class="cm">    s.{x=2}</span>
<span class="cm">    replaces state value</span>
<span class="cm">    s:=1</span>
<span class="cm">*/</span>
<span class="k">fun</span> <span class="n">new</span>(<span class="n">data</span>) =
    <span class="k">let</span> <span class="n">pid</span> = <span class="n">spawn</span>(_<span class="n">loop</span>, <span class="n">data</span>)
    <span class="n">State</span>(<span class="n">pid</span>)
</pre></div>
</div>
</div>
<div class="section" id="triple-dispatch">
<span id="triple-dispatch-label"></span><h2>Triple Dispatch<a class="headerlink" href="#triple-dispatch" title="Permalink to this headline">¶</a></h2>
<div class="highlight-arza"><div class="highlight"><pre><span class="k">import</span> <span class="n">seq</span>

<span class="cm">//case for triple dispatch described here https://softwareengineering.stackexchange.com/questions/291525/a-real-world-use-case-for-triple-dispatch</span>
<span class="cm">//</span>
<span class="cm">//This program represents a repository of citation information, containing books, articles and journals</span>
<span class="cm">//with action of formatting those books for consumption on demand.</span>
<span class="cm">//</span>
<span class="cm">//Let&#39;s take two approaches to formatting. National Library of Medicine (derived from the Vancouver Project)</span>
<span class="cm">//specifies citations in a particular way, mostly affecting how author names are laid out.</span>
<span class="cm">//NLM differs from American Psychological Association (APA) formatting.</span>
<span class="cm">//</span>
<span class="cm">//Also we have to publish these citations and choice of outputs are: plain text, PDF, HTML.</span>
<span class="cm">//Some of these items require different layout strategies,</span>
<span class="cm">//depending on the type of the format (APA indents following lines, NLM doesn&#39;t).</span>

<span class="cm">// Declaring interfaces</span>

<span class="k">interface</span> <span class="n">Repo</span>(<span class="n">I</span>) =
    <span class="n">add</span>(<span class="n">I</span>, <span class="n">item</span>)

<span class="k">interface</span> <span class="n">Source</span>(<span class="n">I</span>) =
    <span class="n">format</span>(<span class="n">item</span> <span class="k">of</span> <span class="n">I</span>, <span class="n">format</span>_<span class="n">standart</span>, <span class="n">output</span>_<span class="n">format</span>)

<span class="k">interface</span> <span class="n">Standart</span>(<span class="n">I</span>) =
    <span class="k">use</span> <span class="n">format</span>(<span class="n">item</span>, <span class="n">format</span>_<span class="n">standart</span> <span class="k">of</span> <span class="n">I</span>, <span class="n">output</span>_<span class="n">format</span>)

<span class="k">interface</span> <span class="n">Output</span>(<span class="n">I</span>) =
    <span class="k">use</span> <span class="n">format</span>(<span class="n">item</span>, <span class="n">format</span>_<span class="n">standart</span>, <span class="n">output</span>_<span class="n">format</span> <span class="k">of</span> <span class="n">I</span>)

<span class="k">fun</span> <span class="n">format</span>_<span class="n">books</span>(<span class="n">library</span>) =
    <span class="k">let</span> <span class="n">books</span> = <span class="n">seq</span>:<span class="n">map</span>(<span class="n">library</span>.<span class="n">books</span>, <span class="n">format</span>)

<span class="cm">// Declaring types</span>

<span class="k">type</span> <span class="n">Item</span>(<span class="n">author</span>, <span class="n">name</span>)
<span class="k">type</span> <span class="n">Record</span>(<span class="n">id</span>, <span class="n">item</span>)
<span class="k">type</span> <span class="n">Book</span> <span class="k">is</span> <span class="n">Item</span>
<span class="k">type</span> <span class="n">Article</span> <span class="k">is</span> <span class="n">Item</span>
<span class="k">type</span> <span class="n">Journal</span> <span class="k">is</span> <span class="n">Item</span>

<span class="k">type</span> <span class="n">FormatStandart</span>
<span class="k">type</span> <span class="n">NLM</span> <span class="k">is</span> <span class="n">FormatStandart</span>
<span class="k">type</span> <span class="n">APA</span> <span class="k">is</span> <span class="n">FormatStandart</span>

<span class="k">type</span> <span class="n">OutputFormat</span>
<span class="k">type</span> <span class="n">PDF</span> <span class="k">is</span> <span class="n">OutputFormat</span>
<span class="k">type</span> <span class="n">HTML</span> <span class="k">is</span> <span class="n">OutputFormat</span>
<span class="k">type</span> <span class="n">TXT</span> <span class="k">is</span> <span class="n">OutputFormat</span>

<span class="k">type</span> <span class="n">Library</span>(_<span class="n">id</span>, <span class="n">items</span>)
    <span class="k">init</span>(<span class="n">l</span>) =
        <span class="n">l</span>.{<span class="n">items</span> = []}

<span class="cm">// Defining generic functions</span>

<span class="k">def</span> <span class="n">add</span>(<span class="n">l</span> <span class="k">of</span> <span class="n">Library</span>, <span class="n">item</span>) =
    <span class="k">let</span> <span class="n">id</span> = <span class="n">l</span>._<span class="n">id</span> + 1
    <span class="n">l</span>.{
        <span class="n">id</span> = _<span class="n">id</span>,
        <span class="n">items</span> = <span class="n">Record</span>(<span class="n">id</span>, <span class="n">item</span>)::@
    }


<span class="k">def</span> <span class="n">format</span>(<span class="n">b</span> <span class="k">of</span> <span class="n">Book</span>, <span class="n">c</span> <span class="k">of</span> <span class="n">NLM</span>, <span class="n">f</span> <span class="k">of</span> <span class="n">TXT</span>) = <span class="n">None</span> <span class="cm">// do something here</span>
<span class="k">def</span> <span class="n">format</span>(<span class="n">b</span> <span class="k">of</span> <span class="n">Article</span>, <span class="n">c</span> <span class="k">of</span> <span class="n">NLM</span>, <span class="n">f</span> <span class="k">of</span> <span class="n">TXT</span>) = <span class="n">None</span> <span class="cm">// do something here</span>
<span class="k">def</span> <span class="n">format</span>(<span class="n">b</span> <span class="k">of</span> <span class="n">Journal</span>, <span class="n">c</span> <span class="k">of</span> <span class="n">NLM</span>, <span class="n">f</span> <span class="k">of</span> <span class="n">TXT</span>) = <span class="n">None</span> <span class="cm">// do something here</span>

<span class="k">def</span> <span class="n">format</span>(<span class="n">b</span> <span class="k">of</span> <span class="n">Book</span>, <span class="n">c</span> <span class="k">of</span> <span class="n">APA</span>, <span class="n">f</span> <span class="k">of</span> <span class="n">TXT</span>) = <span class="n">None</span> <span class="cm">// do something here</span>
<span class="k">def</span> <span class="n">format</span>(<span class="n">b</span> <span class="k">of</span> <span class="n">Article</span>, <span class="n">c</span> <span class="k">of</span> <span class="n">APA</span>, <span class="n">f</span> <span class="k">of</span> <span class="n">TXT</span>) = <span class="n">None</span> <span class="cm">// do something here</span>
<span class="k">def</span> <span class="n">format</span>(<span class="n">b</span> <span class="k">of</span> <span class="n">Journal</span>, <span class="n">c</span> <span class="k">of</span> <span class="n">APA</span>, <span class="n">f</span> <span class="k">of</span> <span class="n">TXT</span>) = <span class="n">None</span> <span class="cm">// do something here</span>

<span class="cm">// and so on and so on</span>
</pre></div>
</div>
</div>
<div class="section" id="some-sequence-functions">
<h2>Some sequence functions<a class="headerlink" href="#some-sequence-functions" title="Permalink to this headline">¶</a></h2>
<div class="highlight-arza"><div class="highlight"><pre><span class="k">fun</span> <span class="n">foldl</span>
    | ([], <span class="n">acc</span>, <span class="n">f</span>) = <span class="n">acc</span>
    | (<span class="n">hd</span>::<span class="n">tl</span>, <span class="n">acc</span>, <span class="n">f</span>) = <span class="n">foldl</span>(<span class="n">tl</span>, <span class="n">f</span>(<span class="n">hd</span>, <span class="n">acc</span>), <span class="n">f</span>)


<span class="k">fun</span> <span class="n">foldr</span>
    | ([], <span class="n">acc</span>, <span class="n">f</span>) = <span class="n">acc</span>
    | (<span class="n">hd</span>::<span class="n">tl</span>, <span class="n">acc</span>, <span class="n">f</span>) = <span class="n">f</span>(<span class="n">hd</span>, <span class="n">foldr</span>(<span class="n">tl</span>, <span class="n">acc</span>, <span class="n">f</span>))


<span class="k">fun</span> <span class="n">reduce</span>(<span class="n">sq</span>, <span class="n">f</span>)
    | (<span class="n">x</span>::<span class="n">xs</span>, <span class="n">f</span>) = <span class="n">foldl</span>(<span class="n">xs</span>, <span class="n">x</span>, <span class="n">f</span>)
    | ([], <span class="n">f</span>) = <span class="k">throw</span> <span class="n">EmptySeqError</span>(<span class="n">sq</span>)


<span class="k">fun</span> <span class="n">map</span>(<span class="n">sq</span>, <span class="n">f</span>)
    | ([], <span class="n">f</span>) = <span class="n">empty</span>(<span class="n">sq</span>)
    | (<span class="n">hd</span>::<span class="n">tl</span>, <span class="n">f</span>) = <span class="n">f</span>(<span class="n">hd</span>) :: <span class="n">map</span>(<span class="n">tl</span>, <span class="n">f</span>)


<span class="k">fun</span> <span class="n">filter</span>(<span class="n">sq</span>, <span class="n">predicate</span>)
    | ([], <span class="n">p</span>) = <span class="n">empty</span>(<span class="n">sq</span>)
    | (<span class="n">x</span>::<span class="n">xs</span>, <span class="n">p</span>) =
        <span class="k">if</span> <span class="n">p</span>(<span class="n">x</span>) <span class="k">then</span>
            <span class="n">x</span> :: <span class="n">filter</span>(<span class="n">xs</span>, <span class="n">p</span>)
        <span class="k">else</span>
            <span class="n">filter</span>(<span class="n">xs</span>, <span class="n">p</span>)


<span class="k">fun</span> <span class="n">sort</span>(<span class="n">s</span>, <span class="n">f</span>) =
    <span class="k">let</span>
        <span class="k">fun</span> _<span class="n">merge</span>
            | ([], <span class="n">ys</span>) = <span class="n">ys</span>
            | (<span class="n">xs</span>, []) = <span class="n">xs</span>
            | (<span class="n">x</span>::<span class="n">xs</span>, <span class="n">y</span>::<span class="n">ys</span>) =
                <span class="k">if</span> <span class="n">f</span>(<span class="n">x</span>, <span class="n">y</span>) <span class="k">then</span> <span class="n">x</span> :: _<span class="n">merge</span>(<span class="n">xs</span>, <span class="n">y</span>::<span class="n">ys</span>)
                <span class="k">else</span> <span class="n">y</span> :: _<span class="n">merge</span>(<span class="n">x</span>::<span class="n">xs</span>, <span class="n">ys</span>)

        <span class="k">fun</span> _<span class="n">sort</span>
            | [] = []
            | [<span class="n">x</span>] <span class="k">as</span> <span class="n">s</span> = <span class="n">s</span>
            | <span class="n">xs</span> =
                <span class="k">let</span> (<span class="n">ys</span>, <span class="n">zs</span>) = <span class="n">split</span>(<span class="n">xs</span>)
                <span class="k">in</span> _<span class="n">merge</span>(_<span class="n">sort</span>(<span class="n">ys</span>), _<span class="n">sort</span>(<span class="n">zs</span>))

    <span class="k">in</span> _<span class="n">sort</span>(<span class="n">s</span>)


<span class="k">fun</span> <span class="n">zip</span>(<span class="n">seq</span>1, <span class="n">seq</span>2)
    | (<span class="n">x</span>::<span class="n">xs</span>, <span class="n">y</span>::<span class="n">ys</span>) = (<span class="n">x</span>, <span class="n">y</span>) :: <span class="n">zip</span>(<span class="n">xs</span>, <span class="n">ys</span>)
    | (_, _) = []


<span class="k">fun</span> <span class="n">unzip</span>(<span class="n">l</span>) =
    <span class="k">let</span> <span class="k">fun</span> _<span class="n">unzip</span>
        | ((<span class="n">x</span>, <span class="n">y</span>) :: <span class="n">ts</span>, <span class="n">xs</span>, <span class="n">ys</span>) = _<span class="n">unzip</span>(<span class="n">ts</span>, <span class="n">x</span> :: <span class="n">xs</span>, <span class="n">y</span> :: <span class="n">ys</span>)
        | ([], <span class="n">xs</span>, <span class="n">ys</span>) = (<span class="n">reverse</span>(<span class="n">xs</span>), <span class="n">reverse</span>(<span class="n">ys</span>))

    <span class="k">in</span> _<span class="n">unzip</span>(<span class="n">l</span>, [], [])


<span class="k">fun</span> <span class="n">zipwith</span>(<span class="n">seq</span>1, <span class="n">seq</span>2, <span class="n">f</span>)
    | (<span class="n">x</span>::<span class="n">xs</span>, <span class="n">y</span>::<span class="n">ys</span>, <span class="n">f</span>) = <span class="n">f</span>(<span class="n">x</span>, <span class="n">y</span>) :: <span class="n">zipwith</span>(<span class="n">xs</span>, <span class="n">ys</span>, <span class="n">f</span>)
    | (_, _, _) = []


<span class="k">fun</span> <span class="n">span</span>(<span class="n">sq</span>, <span class="n">predicate</span>)
    | ([], <span class="n">p</span>) =
        <span class="k">let</span> <span class="n">c</span> = <span class="n">empty</span>(<span class="n">sq</span>)
        <span class="k">in</span> (<span class="n">c</span>, <span class="n">c</span>)
    | ([<span class="n">x</span>, ...<span class="n">xs</span>1] <span class="k">as</span> <span class="n">xs</span>, <span class="n">p</span>) =
        <span class="k">if</span> <span class="n">not</span>(<span class="n">p</span>(<span class="n">x</span>)) <span class="k">then</span>
            (<span class="n">empty</span>(<span class="n">sq</span>), <span class="n">xs</span>)
        <span class="k">else</span>
            <span class="k">let</span> (<span class="n">ys</span>, <span class="n">zs</span>) = <span class="n">span</span>(<span class="n">xs</span>1, <span class="n">p</span>)
            <span class="k">in</span> (<span class="n">x</span>::<span class="n">ys</span>, <span class="n">zs</span>)
</pre></div>
</div>
</div>
</div>


          </div>
        </div>
      </div>
      <div class="sphinxsidebar">
        <div class="sphinxsidebarwrapper">
  <h3><a href="index.html">Table Of Contents</a></h3>
  <ul>
<li><a class="reference internal" href="#">Code examples</a><ul>
<li><a class="reference internal" href="#simple-game">Simple game</a></li>
<li><a class="reference internal" href="#mutable-state">Mutable State</a></li>
<li><a class="reference internal" href="#triple-dispatch">Triple Dispatch</a></li>
<li><a class="reference internal" href="#some-sequence-functions">Some sequence functions</a></li>
</ul>
</li>
</ul>

  <h4>Previous topic</h4>
  <p class="topless"><a href="process.html"
                        title="previous chapter">Processes</a></p>
  <h3>This Page</h3>
  <ul class="this-page-menu">
    <li><a href="_sources/examples.txt"
           rel="nofollow">Show Source</a></li>
  </ul>
<div id="searchbox" style="display: none">
  <h3>Quick search</h3>
    <form class="search" action="search.html" method="get">
      <input type="text" name="q" />
      <input type="submit" value="Go" />
      <input type="hidden" name="check_keywords" value="yes" />
      <input type="hidden" name="area" value="default" />
    </form>
    <p class="searchtip" style="font-size: 90%">
    Enter search terms or a module, class or function name.
    </p>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="genindex.html" title="General Index"
             >index</a></li>
        <li class="right" >
          <a href="process.html" title="Processes"
             >previous</a> |</li>
        <li><a href="index.html">arza 0.1 documentation</a> &raquo;</li> 
      </ul>
    </div>
    <div class="footer">
        &copy; Copyright 2018, gloryofrobots.
      Created using <a href="http://sphinx-doc.org/">Sphinx</a> 1.2.2.
    </div>
  </body>
</html>
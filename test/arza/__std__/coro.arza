from arza:lang:_coro import (spawn, is_complete, is_initialised,
                            is_terminated, is_active, is_passive,
                            is_finished)
import tuple
import io
import seq

//////////////////////////////////////


use Coroutine in
    def is_empty(self) as std_behavior:is_empty

    def len(self) = throw NotImplementedError ("Coroutine can't define len")

    def first(self) =
        if not is_empty(self) then
            self ()
        else
            throw FiberFlowError("Coroutine is closed")

    def rest(self) =
        if not is_empty(self) then
            self
        else
            []

    def to_seq(self) = self
    def empty(self) = []

describe Coroutine as (Sized, Seqable, Seq, Emptiable)

// REFS
type Reference(val)

fun ref(v) =
    let co =
           spawn(
                (fun (yield, v) =
                    (let
                        (fun loop(v) =
                            (let
                                msg = yield(v)
                            in
                                (match msg
                                    | #Read = loop(v)
                                    | (#Write, new_val) =
                                        loop(new_val)
                                )
                            )
                        )
                    in loop(v)
                    )
                )
          )
    in
        co(v)
        Reference(co)

use Reference in
    def repr(self) = str(self)

    def !(self) = self.val(#Read)

    def :=(self, value) = self.val((#Write, value))

    def ==(self, other) = self.val == other.val

    def str(self) = "Var"

describe Reference as (Displayed, Ref)
///////////////////////////////////////////////////////

// helper for creating looping generators
// example
// Infinite increment
//fun enum_from(num) =
//    coro:loop(
//        //first function remembers looper
//        (looper) ->
//             //second function sends data to looper each iteration
//             num -> looper(num + 1)
//        ,
//        num - 1
//    )
// instead of yield it gets looper function which do actual yielding back to receiver
// WARNING expects function as first argument which returns actual worker
// TASK of first function is to remember looper in its scope, so worker can access it

// common code
fun _loop(yield_argument, init_fn, args) =
    let
        co = spawn(
            (fun (yield) =
                (let
                    fn = init_fn(
                        fun (...args) =
                            yield(...yield_argument(args))
                            fn(...args)
                    )
                in
                    yield()
                    fn(...args)
                )
            )
        )
    in
       co()
       co

fun loop(...a) =
    let
        (init_fn, args) = tuple:split(a)
    in _loop(identity, init_fn, args)

// the same but with reduce interface
// useful when there are no need to yielding all looper arguments

fun loop_reduce(init_fn, x, acc) =
    _loop(fst >> tuple:ensure_tuple, init_fn, (x, acc))

////////////////////////////////////////////////////
// SEQUENCES
////////////////////////////////////////////////////

let
    take = seq:take
    take_while = seq:take_while
    nth = seq:nth

fun filter(predicate, coll) =
    spawn(
        fun (yield) =
            (let
                (fun _filter
                    | (p, []) = empty(coll)
                    | (p, x::xs) =
                        (if p(x) then
                            yield(x)
                            _filter(p, xs)
                        else
                            _filter(p, xs)
                        )
                )
            in
                _filter(predicate, coll)
            )
    )


fun map(fn, co) =
    spawn(
        fun (yield) =
            seq:foreach(
                (x) -> yield(fn(x)),
                co
            )
    )


fun drop(count, co) =
    spawn(
        fun (yield) =
            (let
                (fun _drop
                    | (_, []) =
                        empty(co)
                    | (0, s) =
                        seq:traverse(map(yield, s))
                    | (n, x::xs) =
                        _drop(n-1, xs)
                )

            in
                _drop(count, co)
            )
    )

fun drop_while(fn, co) =
    spawn(
        fun (yield) =
            (let
                (fun _drop_while
                    | (p, []) =
                        empty(co)
                    | (p, xs @ [x, ...xs1]) =
                        (if p(x) then
                            _drop_while(p, xs1)
                        else
                            seq:traverse(map(yield, xs))
                        )
                 )
            in
                _drop_while(fn, co)
            )
    )


fun each(co) =
    spawn(
        fun (yield) =
            (fun | [] = empty(co)
                 | s = seq:traverse( map(yield, s) )
            )(co)
    )


fun to_list(co) =
    seq:map(identity, co)


fun scanl(fn, acc, co) =
    spawn(
        fun (yield) =
            (let
                (fun _scanl
                    | (f, acc, []) = empty(co)
                    | (f, acc, x::xs) =
                        (let v = f(x, acc)
                        in
                            yield(v)
                            _scanl(f, v, xs)
                        )
                )
            in
                _scanl(fn, acc, co)
            )
    )


fun intersperse(val, co) =
    spawn(
        fun (yield) =
            seq:foreach(
                (fun (x) =
                    yield(x)
                    yield(val)
                ),
                co
            )
    )


fun zipwith(fn, co1, co2) =
    spawn(
        fun (yield) =
                (let (fun _zip
                        | (co1, co2) when is_empty(co1) or is_empty(co2) =
                            []
                        | (x::co1, y::co2) =
                            (if is_empty(co1) or is_empty(co2) then
                                fn(x,y)
                            else
                                yield(fn(x,y))
                                _zip(co1, co2)
                            )
                     )
                in
                    _zip(co1, co2)
                )
    )

fun zip(co1, co2) =
    spawn(
        fun (yield) =
                (let (fun _zip
                        | (co1, co2) when is_empty(co1) or is_empty(co2) =
                            []
                        | (x::co1, y::co2) =
                            (if is_empty(co1) or is_empty(co2) then
                                (x,y)
                            else
                                yield((x,y))
                                _zip(co1, co2)
                            )
                     )
                in
                    _zip(co1, co2)
                )
    )
///////////////////////////////////////////////////////



//REDUCERS///////////////////////////////////////////////////////
fun foldl
    | (f, acc, []) = acc
    | (f, acc, hd::tl) = foldl(f, f(hd, acc), tl)


fun foldr
    | (f, acc, []) = acc
    | (f, acc, hd::tl) = f(hd, foldr(f, acc, tl))


fun reduce(f, sq)
    | (f, x::xs) = foldl(f, x, xs)
    | (f, []) = throw EmptySeqError(sq)


fun scanl(func, accumulator, coll)
    | (f, acc, []) = acc :: empty(coll)
    | (f, acc, hd::tl) = acc :: scanl(f, f(hd, acc), tl)


//LOOPS ////////////////////////
// possible casting solution
//fun ensure_seq(fn) =
//    fun (f, coll) =
//        from_seq(fn(f, to_seq(coll)))

fun map(f, coll)
    | (f, []) = empty(coll)
    | (f, hd::tl) = f(hd) :: map(f, tl)


fun foreach(f, coll)
    | (f, []) = empty(coll)
    | (f, hd::tl) =
      f(hd)
      foreach(f, tl)


fun enum_to(last of Int, fn) = enum(0, last, fn)


fun enum(first of Int, last of Int, fn) =
    let
        step =
            if last < 0 then -1
            else 1
    in enum_by(first, last, step, fn)


fun enum_by (first of Int, last of Int, step of Int, fn) =
    let
        fun _enum_by
            | (f, l) when l == f = ()
            | (f, l) =
                fn(f)
                _enum_by(f+step, l)
    in
        _enum_by(first, last)


fun traverse(coll) = foreach(identity, coll)


fun intersperse(val, coll)
    | (val, []) = empty(coll)
    | (val, hd::tl ) = hd :: val :: intersperse(val, tl)


fun reverse(coll) =
    let fun _reverse
            | ([], result) = result
            | (hd::tl, result) = _reverse(tl, hd :: result)

    in _reverse(coll, empty(coll))


fun list(coll) =
    reverse(
        foldl(cons, [], coll)
    )


///ACCESSORS//////////////////////////////////////

fun nth_tail
    | (0, l) = l
    | (1, [_, ...t]) = t
    | (n, [_, ...t]) when n >= 0 = nth_tail(n - 1, t)


fun nth
    | (0, l) = l
    | (1, [h, ...t]) = h
    | (n, [h, ...t]) when n >= 0 = nth(n - 1, t)


//QUERIES///////////////////////////////////////////////////

fun length(l) =
    foldl((_, acc) -> acc + 1, 0, l)


fun last (x::xs) =
    let fun _last
            | (_, x::xs) = _last(x, xs)
            | (x, []) = x

    in _last(x, xs)


fun prefix_of
    | ([hd, ...pre_tail], [hd, ...tail]) = prefix_of(pre_tail, tail)
    | ([], s) = True
    | ([_, ..._], s) = False


fun suffix_of(suf, s) =
   let
       delta = len(s) - len(suf)
       tl = nth_tail(delta, s)
   in delta >= 0 and tl == suf


//SUBLISTS/////////////////////////////////////////////////////////////

fun drop
    | (0, l) = l
    | (count, hd::tl) = drop(count - 1, tl)


fun take(n, coll)
    | (0, _) = empty(coll)
    | (_, []) = empty(coll)
    | (n, [x, ...xs]) = x :: take(n - 1, xs)


fun split_at(n, l) =
    (take(n, l), drop(n, l))


fun take_while(predicate, coll)
    | (p, []) = empty(coll)
    | (p, [x, ...xs]) =
        if p(x) == True then x :: take_while(p, xs)
        else empty(coll)


fun drop_while(predicate, coll)
    | (p, []) = empty(coll)
    | (p, [x, ...xs1] as xs) =
        if p(x) == True then drop_while(p, xs1)
        else xs


fun filter(predicate, coll)
    | (p, []) = empty(coll)
    | (p, x::xs) =
        if p(x) then
            x :: filter(p, xs)
        else
            filter(p, xs)


fun span(predicate, coll)
    | (p, []) =
        let c = empty(coll)
        in (c, c)
    | (p, [x, ...xs1] as xs) =
        if not(p(x)) then
            (empty(coll), xs)
        else
            let (ys, zs) = span(p, xs1)
            in (x::ys, zs)


fun partition(predicate, l) =
    let fun _partition(pred, l, a, b)
            | (pred, x::xs, a, b) =
                if pred(x) then
                   _partition(pred, xs, x::a, b)
                else
                   _partition(pred, xs, a, x::b)

            | (pred, [], a, b) = (reverse(a), reverse(b))

    in _partition(predicate, l, [], [])


fun delete(item, coll)
    | (item, [item, ...xs]) = xs
    | (item, [x, ...xs]) = x :: delete(item, xs)
    | (_, []) = empty(coll)


fun insert(index, v, coll)
    | (0, v, coll) = v::coll
    | (i, v, []) = throw IndexError (["Invalid insertion index", index, v])
    | (i, v, x::xs) = x :: insert(i - 1, v, xs)


fun append(v, coll) =
    insert(length(coll), v, coll)


////QUERIES//////////////////////////////////////////////////////////////////

fun conjunction(l) =
    foldr((v, acc) -> v and acc, True, l)


fun disjunction(l) =
    foldr((v, acc) -> v or acc, False, l)


fun any(p, l) =
    disjunction(map(p, l))


fun all(p, l) =
    conjunction(map(p, l))


fun element(x, l) = any(v -> v == x, l)


fun contains(l, x) = element(x, l)


fun equal
    | (x::xs, x::ys) = equal(xs, ys)
    | ([], []) = True
    | (_, _) = False


//BUILDERS/////////////////////////////////////////////////////////////

fun concat(l1, l2) =
    foldr(`::`, l2, l1)


fun uncons(x::xs) = (x, xs)


fun initial(coll)
    | [x] = empty(coll)
    | [x, ...xs] = x :: initial(xs)
    | [] = throw ValueError ("empty seq in initial")


fun zip(seq1, seq2)
    | (x::xs, y::ys) = (x, y) :: zip(xs, ys)
    | (_, _) = []


fun unzip(l) =
    let fun _unzip
        | ((x, y) :: ts, xs, ys) = _unzip(ts, x :: xs, y :: ys)
        | ([], xs, ys) = (reverse(xs), reverse(ys))

    in _unzip(l, [], [])


fun zip3(s1, s2, s3)
    | (x::xs, y::ys, z::zs) = (x, y, z) :: zip3(xs, ys, zs)
    | (_, _, _) = []


fun unzip3(l) =
    let fun _unzip3(l, acc_x, acc_y, acc_z)
            | ([(x, y, z), ...ts], xs, ys, zs) = _unzip3(ts, x::xs, y::ys, z::zs)
            | ([], xs, ys, zs) = (reverse(xs), reverse(ys), reverse(zs))
    in _unzip3(l, [], [], [])


fun zipwith(f, seq1, seq2)
    | (f, x::xs, y::ys) = f(x, y) :: zipwith(f, xs, ys)
    | (_, _, _) = []


fun zipwith3(f, seq1, seq2, seq3)
    | (f, x::xs, y::ys, z::zs) = f(x, y, z) :: zipwith3(f, xs, ys, zs)
    | (_, _, _, _) = []


fun split
    | [] = ([], [])
    | [x] as s = (s, [])
    | x::y::xs =
        let (l, r) = split(xs)
        in (x::l, y::r)


fun sort(f, s) =
    let
        fun _merge
            | ([], ys) = ys
            | (xs, []) = xs
            | (x::xs, y::ys) =
                if f(x, y) then x :: _merge(xs, y::ys)
                else y :: _merge(x::xs, ys)

        fun _sort
            | [] = []
            | [x] as s = s
            | xs =
                let (ys, zs) = split(xs)
                in _merge(_sort(ys), _sort(zs))

    in _sort(s)


fun sort_asc(s) = sort(`<=`, s)


fun sort_desc(s) = sort(`>=`, s)

import std
import arza:lang:_number
import io

use
    (Float, Int) as 0
in
(
    def != (self, other) as std:Behavior.[`!=`]
    def == (self, other) as std:Behavior.[`==`]

    def str (self) as std:Behavior.[str]
    def repr (self) as std:Behavior.[repr]

    def - (x, y) as _number:sub
    def + (x, y) as _number:add
    def * (x, y) as _number:mul
    def / (x, y) as _number:div
    def mod (x, y) as _number:mod
    def negate (x) as _number:negate
    def ** (x, y) as  _number:pow

    def <= (x, y) as _number:le
)

derive (Comparable, LessEq, Ord, Num, Pow, Eq, PartialEq, Str, Displayed) for (Float, Int)


//extend
//    Int
//with
//(
//    def range(first, last of Int) ->
//        range_by(first, last, 1)
//
//    def range_by(first, last of Int, step of Int) ->
//        cmp =
//            if step > 0 then `>=`
//            elif step < 0 then `<=`
//            else throw ValueError ("Step can not be zero")
//
//        fun _progression _compare x last step  ->
//            if _compare x last then
//                []
//            else
//                x ::: _progression _compare (x + step) last step
//
//
//        _progression cmp first last step
//
//    def range_from first  -> range_from_by first 1
//
//    def range_from_by first (step of Int) ->
//        fun _progression x step ->
//            x ::: _progression (x + step) step
//
//        _progression first step
//)


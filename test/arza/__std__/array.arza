import arza:lang:_array
import string
import io
import std


trait TArray(A) for Array =
    std:TEq(A)

    def at (k, self of A) as std_behavior:at
    def put (k, v, self of A) as std_behavior:put
    def del (el, self of A) as std_behavior:del
    def elem (el, self of A) as std_behavior:elem
    def is_empty (self of A) as std_behavior:is_empty
    def len (self of A) as std_behavior:len

    def ++ (a1 of A, a2 of A) as _array:concat

    def prepend(v, self of A) as _array:prepend
    def append(v, self of A) as _array:append

    def slice(first, last, self of A) as _array:slice
    def drop(x, self of A) as _array:drop
    def take(x, self of A) as _array:take

    def index_of(el, self of A) as _array:index_of

    def repr(self of A) =
        if len(self) == 1 then
            "(" ++ repr(at(0, self)) ++ ",)"
        else
            "(" ++ string:join_with(repr, to_seq(self), ", ") ++ ")"

    def str(self of A) =
        if len(self) == 1 then
            "(" ++ str(at(0, self)) ++ ",)"
        else
            "(" ++ string:join_with(str, to_seq(self), ", ") ++ ")"

--------------------------------------------------

type ArraySeq = (arr, index, dest)
type ArraySeqEmpty = (dest)

trait TArraySeq(A) for ArraySeq =
    def first({arr, index} of A) = arr.[index]

    def rest(A(arr, index, dest)) =
        let
            l = len(arr) - index
        in
            if l <= 0 then
                ArraySeqEmpty(dest)
            else
                A(arr, index + 1, dest)


    def is_empty({arr, index} of A) = index >= len(arr)

    def empty(self of A) = ArraySeqEmpty(self.dest)

    def len({arr, index} of A) =
        let
            l = len(arr) - index
        in
            if l < 0 then 0
            else l

    def cons(v, A(arr, index, dest)) =
        A(arr, index+1, prepend(v, dest))

    def &&(self of A) = self.dest

describe ArraySeq as (Seq, Sized, Emptiable)

--------------------------------------------------

trait TArraySeqEmpty(A) for ArraySeqEmpty =
    def first(self of A) = throw EmptySeqError("ArraySequence is empty")

    def rest(self of A) =
        throw EmptySeqError("ArraySequence is empty")

    def is_empty(self of A) = True

    def len(self of A) = 0

    def cons(v, self of A) =
        prepend(v, self.dest)
        self

    def &&(self of A) = self.dest

describe ArraySeqEmpty as (Seq, Sized)

--------------------------------------------------

def to_seq(self of Array) = ArraySeq(self, 0, array())

fun map (f, arr of Array) =
    let
        size = len(arr)
        fun _map
            | (index, result) when index >= size = result
            | (index, result) =
                _map(
                    index + 1,
                    append(f(arr.[index]), result)
                )
    in
        _map(0, array())
//
//
//fun map(f, coll)
//    | (f, () of Array) = empty(coll)
//    | (f, hd::tl) = f(hd) :: map(f, tl)

describe Array as (Eq, Displayed,
       Sized, Collection,
       Prependable, Appendable, Concatable, Indexed,
       Seqable, Sliceable)

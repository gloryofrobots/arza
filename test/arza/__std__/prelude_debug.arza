///////// IMPORTS ////////////////
//export (f_ab, f_ab_2, CONST)
//
//import affirm
//
//import tests:lib_az:abc:module_ab as ab
////
//////unqualified names f_ab,f_ab_2,const
//from tests:lib_az:abc:module_ab  import (f_ab, f_ab_2, CONST as const)
////
//////ab2:f_ab
//import tests:lib_az:abc:module_ab as ab2 (f_ab, f_ab_2)
////
//////module_ab:f_ab, module_ab:f_ab_2
//import tests:lib_az:abc:module_ab (f_ab, f_ab_2)
////
//////all exported names imported
//from tests:lib_az:efg:module_e import _
//
////ab_3_f_ab
//from tests:lib_az:abc:module_ab import (f_ab as ab_3_f_ab)
////importing same names dont cause errors because names are equal
//from tests:lib_az:abc:module_ab hide (CONST)
////ab5:f_ab_2 only
//import tests:lib_az:abc:module_ab as ab5 hiding (f_ab, CONST)
//////////////////////////////////////////////////////////
/////////////////////////////
//////////////////////////////////////////

//infixr (:=, :=, 10)
//infixl (<|, <|, 15)
//infixl (|>, |>, 20)
//infixl (<<, <<, 25)
//infixl (>>, >>, 25)
//infixl (<, <, 35)
//infixl (>, >, 35)
//infixl (>=, >=, 35)
//infixl (<=, <=, 35)
//infixl (==, ==, 35)
//infixl (!=, !=, 35)
//infixl (++, ++, 40)
//infixl (+, +, 40)
//infixl (-, -, 40)
//infixl (*, *, 50)
//infixl (/, /, 50)
//prefix (-, negate, 55)
//infixl (**, **, 60)
//prefix (!, !, 70)
//infixl (.., .., 95)
//prefix (&, &, 96)


//fun f () = 0
//fun f (()) = ((()))
//fun f4 ((),) = ((()))
//
//fun f ((x,y) :: 4, 45) = 42
//fun f (x::xs) = 42
//fun f
//    | x::xs = 42
//    | [] = 24
//
//
//fun f () =
//(
//let
//    {a=[x,y,...z], B @ b="I am B", c of Float, D@d={e=(x,y,...zz)}} =
//        {a=[1,2,3,4,5], b="I am B", c=3.14, d={e=(1,2,3,4,5)}}
//in
//    affirm:is_equal(
//        (a, B, D, e, x, y, z, zz),
//        ([1,2,3,4,5], "I am B", {e=(1,2,3,4,5)}, (1,2,3,4,5), 1, 2, [3,4,5], (3,4,5))
//    )
//)
//
//let x = f4(())
//let m = (fun
//             | x = 2)(3)
//let x =
//    affirm:is_equal (
//        (fun | ([hd::tl], (1,2,3), {x=2, y=3}) = 24
//             | (_, y, z) = 23)(
//                [[1,2]], (1,2,3), {x=2, y=3}),
//        24
//    )
//fun f
//    | ((x,y) :: 4, 45) = 42
//    | (x,y) = 42
//
//let f = seq:map(x -> x * x, l)
//let g = seq:map((1,2,3), l)
//
//
//fun reverse(coll) =
//    let fun _reverse
//            | ([], result) = result
//            | (hd::tl, result) = _reverse(tl, hd :: result)
//
//    in  _reverse(coll, empty(coll))
//
//
//fun f () = (
//        (x,y,z)
//        (a,b,c)
//    )
//
//fun f () = (
//        (x,y,z) (a,b,c)
//    )
//
//trait TNum (
//    let - = _number:sub
//    let + = _number:add
//    let * = _number:mul
//    let / = _number:div
//    let mod = _number:mod
//    let negate = _number:negate
//    let ** =  _number:pow
//)
//
//
//fun f () =
//    let
//        v = m.x
//        x = m.{x}
//        y = m.{y=1, x=2}
//        x = m.name.x()
//        x = m.{name}.{x}
//    in x + y
//
//
//fun add(x, y) =
//    let
//        z = sqrt(x)
//        (n,b) = pow(z)
//        x::xs = tail(n)
//        [x, y, ...r] = n
//        fun tail
//            | [] = []
//            | x::xs = xs
//        y = map(fun (x) = (x, str(x)), [])
//    in sin(z, n, x)
//
//let y = map(fun x = (x, str(x)), [])
//
//let {R @ x=1, y = z of Int, _ = 3} = {x = 1, y = 3, "2" = 5}
//
//let (
//    x = 1
//    z = 2
//    {R @ x=1, y = z of Int, _ = 3} = {x = 1, y = 3, "2" = 5}
//    [1,2,3, ...rest] = [1,2,3,4,5,6,7]
//    m = () -> 42
//    m = (x) -> 42
//    m = (x,y,z) -> 42
//    m = x -> 42
//)
//
//let m = () -> 42
//let m = (x) -> 42
//let m = (x,y,z) -> 42
//let m = x -> 42
//
//let x = 1
//let Z = (1,2,3,4)
//
//let V = fun (x) = 1
//type (
//    Zero
//    Vec2 (p1, p2)
//    Car (speed, price, model, weight)
//)
//
//type Zero
//type Vec2 (p1, p2)
//type Car (speed, price, model, weight)
//
//fun f () = (
//
//    try
//        error()
//    catch e1 =
//        e1
//    finally
//        error2(#Finally)
//
//    try
//        try
//            error(#Catch)
//        catch
//            | err @ (1, y, 3) = #first
//            | (1,2, "ERROR@") = #second
//            | err @ (1, 2, x) = #third
//        finally
//            //uncatched
//            throw (e2, e3)
//    catch E = E
//)
//fun f () =
//    match [1,2,3]
//        | B1 @ [a, b, B2 @ c] when x == 1 = (B1, B2, a, b, c)
//        | _ = 42
//
//fun max_min (x, y) =
//    if x > y then (
//        (x, y)
//        x > 1
//    )
//    elif x == y then (x, x)
//    else (y, x)
//
//fun all(p, l) =
//    conjunction(map(p, l))
//
//fun uncons ([x, ...xs]) = (x, xs)
//
//fun map (f, coll)
//    | (f, []) = empty(coll)
//    | (f, hd::tl) = f(hd) :: map(f, tl)
//
//fun element(x, l) =
//    any (fun (v) = v == x, l)
//
//
//
//fun false () = False
//
//fun tail
//    | [] = []
//    | x::xs = xs
//
//
//fun main () =
//    let
//        fun tail
//            | [] = []
//            | x::xs = xs
//
//        numbers = enum_from(10)
//        ys = seq:take(10,
//                    map(fun (x) = (x, str(x)),
//                        drop(3,
//                            filter(odd, numbers))))
//    in (
//        io:print(ys)
//        io:print(x1, x2, ys)
//    )
//--------------------------------------------------
//
//fun split (s)
//    | [] = ([], [])
//    | s@[x] = (s, [])
//    | x::y::xs =
//        let
//            (l, r) = split(xs)
//        in (x::l, y::r)
//--------------------------------------------------
//
//
// TODO change ` to $, _ or []

interface Num (-, (..).0, +.0, *, /, mod.0, math:negate.0, sqrt)
interface (
    ReadOnlyCollection(at, elem)
    ShrinkableCollection(del)
    GrowableCollection(put)
    Collection() is (ReadOnlyCollection, ShrinkableCollection, GrowableCollection)

    Num (-, +.0, *, /, mod.0, math:negate.0)
    Ord(<, <=, >.0, >=.0, math:cmp, math:sort:max, min)
    PartialEq (==)
    Pow(**)
    Str (str)
    Addend(add.0, add.1)
    Sub(sub.0)
    Subtracted(sub.1)
)

//def != [List]
//    | (x of List, y of List) = 0
//    | ([] of List, y of Seq) = 0
//    | ({x, y} of List, y) = 0
//
//def add [Int, Float] (x, y) =
//(
//    print(x, y)
//    __add(x, y)
//)
//
//
//def radd [Int, Float]
//    (x, y) = add(y, x)
////
////
//def sub [Int, Float] as subtract
//
//{ #name = 1, #surname=2 }
//let S = {
//    (`==`) = 1,
//    (2+2) = 2
//}

//extend
//    Int
//    Float
//with
//(
//    def - as _number:sub
//    def == as ==.[Rational]
//    def + as +.[[Rational, Double]]
//    def add (x, y) = 42
//)


//extend
//    [X, Y, arza:Z]
//    [X1, math:Y1, Z1]
//with
//(
//    def {!=, ==} from StdBehavior
////    def != = TEq.[!=]
////    def == = TEq.[==]
//
//    def (ls, lss) with [A, math:B, C]
//    //def ls = ls.[A, B, C]
//    //def lss = lss.[A, B, C]
//
//    def == as `==`.[Rational]
//
//    def + as `+`.[[Rational, Double]]
//
//    def ls (l, s) =
//    (
//       add(3, 4)
//       sub(l, s)
//    )
//
//    def lss (l, s, s1 of Seq) = #lss
//)

//generic == (x, y)
////// not dispatchable on 0 and 2
//generic add (_, y, _)
//generic (
//    // ERROR
//    == (x, y)
//    - (x, y)
//    + (x, _)
//    ! (self)
//    len (self)
//    put (key, _, self)
//    add(x, y)
//    sub(x, _)
//    //Error
//    pow(_, _)
//)
//
//// signature [Int, Float]
//def add (x of Int, y of Float) = (x, y)
//// signature [_, Float]
//def add (x, y of Float) = (x, y)
//
//// [Value(Bool), Float]
//def add ( of Bool, y of Float) = (x, y)
//def add ( x of Bool, y of Float) as add.[[Instance]]

//
////def add (x, y) = 0
//
//use
//    Int as 0
//    Float as 1
//in
//(
//    def add (x, y) = x
//    def add (x, y) = y
//)
//
//
//use
//    Int as T1
//    Float as T2
//in
//(
//    def add (x of T1, y of T2) = x
//    def add (x of T2 , y of T1) = y
//)
//
//use
//    (Float, Int, Char) as 0
//in
//(
//    def f(x, y, z) = self
//)
//
//use
//    (Float, Int, Char) as 1
//in
//(
//    def f(x, y, z) = x
//    def f1(x, y, z) = x
//)
//
//use
//    (Map, Seq) as ...
//in
//(
//    def at(v, self) = self
//    def put(k, v, self) = self
//)

use
    String as Str
    Symbol as Sym
in
(
    def ++ (_str1 of Str, _str2 of Str) = _string:concat(_str1, _str2)
//    def ++ (_str of Str, sym of Sym) = _string:concat(_str, str(sym))
//    def ++ (_str of Sym, sym of Str) = _string:concat(str(sym), _str)
)

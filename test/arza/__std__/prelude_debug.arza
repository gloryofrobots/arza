infixl (+, +, 40)
infixl (-, -, 40)
infixl (*, *, 50)
infixl (/, /, 50)


fun f () =
    affirm:is_equal(
        match 1
            | x of int = #first
            | x of int when True = #third
        ,
        #second
    )

//use
//    String as Str
//    Symbol as Sym
//in
//    def ++ (s1 of Str, s2 of Str) = _string:concat(s1, s2)
//    def ++ (s1 of Str, s2 of Sym) = _string:concat(s1, str(s2))
//    def ++ (s1 of Sym, s2 of Str) = _string:concat(str(s1), s2)
//    def ++ (s1 of Sym, s2 of Sym) = symbol(_string:concat(str(s1), str(s2)))
////
//use (String, Char, Symbol) as 0 in
//    def != (self, other) as std_behavior:not_equal
//    def == (self, other) as std_behavior:equal
//
//    def str (self) as std_behavior:str
//    def repr (self) as std_behavior:repr
////
////(use (String, Char, Symbol) as 0 in
////        def != (self, other) as std_behavior:not_equal
////        def == (self, other) as std_behavior:equal
////
////    def str (self) as std_behavior:str
////    def repr (self) as std_behavior:repr
////)
////
////(use
////    String as Str
////    Symbol as Sym
////in
////    (def ++ (s1 of Str, s2 of Str) =
////        x + y
////        _string:concat(s1, s2)
////    )
////
////    (def ++ (s1 of Str, s2 of Sym) =
////        _string:concat(s1, str(s2))
////    )
////)
//use stuff:TestType as T in
//    def types:test_method_1(a1 of stuff:TestType, a2 of stuff:TestType, self of T) =
//        x + y
//        a1.val + a2.val + self.val
//
//    def types:test_method_2(a1, self of T, a2) = a1.val + a2.val + self.val
//    def types:test_method_3(self of T, a1, a2) = a1.val + a2.val + self.val
//    def types:test_method_4(self of T) = self.val
////
//use L as ... in
//    def len(self) = len(self.l)
//
//    def is_empty(self) =
//        x + y
//        is_empty(self.l)
//
//use Val2 as 0 in
//    def le(self, other) =
//        x + y
//        self.v + other.v
//    def cmp(x, y) as Order.[cmp]
//    def ge(x, y) as Order.[ge]
//
//
//def len(self of Int) = len(self.l)
//
//def len(self of Int, x) =
//    len(self.l)
//    x + y
//    1/2
//
//
//(def len(self of Int, x) = len(self.l)
//        x + y
//    1/2
//)
//
//derive (Eq, Displayed) for (Symbol, Char)
//
//derive Concatable for Symbol
//
//(derive
//    (Eq, Displayed)
//    for (Symbol, Char)
//)
//
//(derive
//    Concatable
//    for Symbol)
//
//
////// TODO EXPORT AS
//
//export (f_ab, f_ab_2, CONST)
//export f_ab
//
//type GT
//
//type
//    LT
//    Some (val)
//    Vec3(x, y, z)
//
//(type
//    LT
//        Some (val)
//
//            Vec3(x, y, z)
//)
//
//fun f(x,y) =
//
//    try
//        1/0
//        x - y
//    catch e2 =
//        throw e2
//    try
//        throw (1,2,"ERROR")
//    catch
//        | err @ (1, y, 3) = #first
//        | (1,2, "ERROR@") = #second
//        | err @ (1, 2, x) = #third
//    finally
//        (#fourth, err, x)
//
//    try
//        try
//            1/0
//            x - y
//        catch e2 =
//            throw e2
//    catch e3 =
//        try
//            error(#LifeSucks)
//        catch e4 =
//            e4
//    (try
//        (try
//                    1/0
//                    x - y
//                    catch e2 =
//                        throw e2
//        )
//    catch e3 =
//                (try
//                 error(#LifeSucks)
//                    catch e4 =
//            e4
//        )
//    )
//
//    try
//        throw (1,2,"ERROR")
//    catch
//        | err @ (1, y, 3) = #first
//        | (1,2, "ERROR@") = #second
//        | err @ (1, 2, x) = #third
//    finally
//        (#fourth, err, x)
//
//    affirm:is_equal((try
//                        throw (1,2,"ERROR")
//                     catch
//                        | err @ (1, y, 3) = #first
//                        | (1,2, "ERROR@") = #second
//                        | err @ (1, 2, x) = #third
//                     finally
//                        (#fourth, err, x)
//                     ),
//                     (#fourth, (1, 2, "ERROR"), "ERROR")
//    )
//
//
//    let
//        x = 1
//        f = (x) -> 1
//    in
//        x + y
//        x + f(x, x + y)
//
//    (let
//        x = 1
//                    f = (x) -> 1
//                in
//            x + y
//                        x + f(x, x + y)
//    )
//
//    f((fun (x, y) = x + y), 1, 2)
//    2 + 2
//        + 3
//    3
//    (4)
//    (fun(x)=
//        1 2)
//
//    (if (fun(x)=1) then 2
//    else
//            3)
//    (match 42
//            | 42 = False
//        | 43 = True 24)
//    24
//    match 42
//        | B4 @ 2 = (#result1, B4)
//        | B4 @ 42 = ((#result2, B4), 2)
//
//    (if True then
//                          2
//        elif False then
//            3
//            5; 4 + 5
//                            else 5
//    )
//
//    if True then
//        2
//    elif False then
//        3
//        5;
//        4 + 5
//    else
//        5
//
//
//
//
//let
//    fst = c -> at(0, c)
//    snd = c -> at(1, c)
//    thrd = c -> at(2, c)
//    frth = c -> at(3, c)
//
//(let
//            fst = c -> at(0, c)
//    snd = c -> at(1, c)
//)
//
//let x = 2
//
//generic
//    +(x, y)
//    negate(x)
//    put(key, value, self)
//
//(generic
//            +(x, y)
//
//        negate(x)
//    put(key, value, self)
//)
//
//(interface
//    Coll(put, del)
//                Dict(keys, values) is Collection    Sliceable(slice.2, drop.1, take.1)
//)
//////
//interface
//    Coll(put, del)
//    Dict(keys, values) is Collection
//    Sliceable(slice.2, drop.1, take.1)
//
//
//(fun f | 12 = 42
//)
//
//
//(fun fact(n)
//    | 0 = 1
//    | n =
//        n * fact (n - 1)
//        (match 42
//                | 42 = False
//            | 43 = True 24)
//)
//
//fun fact(n)
//    | n =
//        (match 42
//          | 42 = False
//                    | 42 =
//              False
//               True
//          | 42 =
//                False
//        )
//
//        match 42
//            | 42 = False
//            | 42 =
//                False
//                True
//            | 42 =
//                False
//    | n =
//        match 42
//            | 42 = False
//            | 42 =
//                False
//                True
//            | 42 =
//                False
//
//        match 42 | 42 = False
//                 | 42 = False
//                        True
//                 | 42 = False
//
//        if x then 2
//        elif x then
//                4
//        else
//            8
//
//        (if x then 2
//        elif x then
//                4
//        else
//            8)
//
//import affirm
//
//import tests:lib_az:abc:module_ab as ab
//
////
//////unqualified names f_ab,f_ab_2,const
//from tests:lib_az:abc:module_ab  import (f_ab, f_ab_2, CONST as const)
////
//////ab2:f_ab
//import tests:lib_az:abc:module_ab as ab2 (f_ab, f_ab_2)
////
//////module_ab:f_ab, module_ab:f_ab_2
//import tests:lib_az:abc:module_ab (f_ab, f_ab_2)
////
//////all exported names imported
//from tests:lib_az:efg:module_e import _
//
////ab_3_f_ab
//from tests:lib_az:abc:module_ab import (f_ab as ab_3_f_ab)
////importing same names dont cause errors because names are equal
//from tests:lib_az:abc:module_ab hide (CONST)
////ab5:f_ab_2 only
//import tests:lib_az:abc:module_ab as ab5 hiding (f_ab, CONST)
//


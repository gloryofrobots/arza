import arza:lang:_std_behavior as std_behavior

from arza:lang:_datatype import (record_values, record_keys, record_index_of)


from arza:lang:_types import (Bool, Char, Int, Float, Symbol, String, List, Vector, Tuple, Map,
                              Function, Partial, Generic, FiberChannel, Coroutine, Interface, Datatype,
                              Env, Array, AssocArray, PID)

from arza:lang:_interfaces import (Instance, Singleton, Any)

from arza:lang:_bit import (bitand, bitor, bitxor, bitnot, lshift, rshift)
from arza:lang:_number import (abs)
import arza:lang:_process

"""
SOME OF THE OPERATORS DEFINED INTERNALLY AND SOME BELOW
Precedence    Operator
    100           : .
    95           x() .{ .[ ->
    60           :: :::
    55           **
    50           *  /
    40           +  - ++
    35           ==  !=  <  <=  >  >=
    30           and
    25           or << >>
    20           |>
    15           " ." @ as of <| <-
    10           = :=
"""

infixr (:=, :=, 10)
// infix @ as of -> 15
infixr (<-, <-, 15)
infixr (!, __send__, 15)
infixl (<|, <|, 15)
infixl (|>, |>, 20)
// infix or -> 25
infixl (<<, <<, 25)
infixl (>>, >>, 25)
// infix and -> 30
infixl (<, <, 35)
infixl (>, >, 35)
infixl (>=, >=, 35)
infixl (<=, <=, 35)
infixl (==, ==, 35)
infixl (!=, !=, 35)
infixl (++, ++, 40)
infixl (+, +, 40)
infixl (-, -, 40)
infixl (*, *, 50)
infixl (/, /, 50)
// use qualified name to prevent infinite loops in cases of declaring local negate function using prefix -
prefix (-, arza:lang:negate, 55)
// infix :: -> 60
infixl (**, **, 60)
// prefix # -> 70
prefix (&, &, 70)
prefix (&&, &&, 70)
infixl (.., .., 90)
// infix (  .{ .[ -> 95
prefix (~, ~, 96)
// infix . : -> 100

////////////////////////////////////////////////////////////
///////////////// INTERFACES ///////////////////////////////
////////////////////////////////////////////////////////////

interface PartialEq(I) =
    fun ==(x of I, y)

interface Eq(I) is PartialEq =
    fun !=(x of I, y)

interface Comparable(I) =
    fun cmp(first of I, second)

interface LessEq(I) is PartialEq =
    fun <=(first of I, second)

interface Ord(I) =
    use <=(first of I, second)
    use cmp(first of I, second)
    fun <(first of I, second)
    fun >=(first of I, second)
    fun >(first of I, second)
    fun max(first of I, second)
    fun min(first of I, second)

interface Num(I) =
    fun -(x of I, y)
    fun +(x of I, y)
    fun *(x of I, y)
    fun /(x of I, y)
    fun mod(x of I, y)
    // unary -
    fun negate(x of I)

interface Pow(I) =
    fun **(x of I, y)

interface Str =
    fun str(Str)

interface Displayed(I) is Str =
    fun repr(I)

interface Len =
    fun len(Len)

interface Sized is Len =
    fun is_empty(Sized)

interface Coll =
    fun put(key, value, Coll)
    fun del(obj, c of Coll)

interface GrowableCollection(I) =
    use put(key, value, I)

interface ShrinkableCollection(I) =
    use del(obj, I)

interface ReadOnlyCollection(I) =
    fun at(key, I)
    fun elem(key, I)

interface Collection is (GrowableCollection, ShrinkableCollection, ReadOnlyCollection)

interface Dict(I) is Collection =
    fun keys(self of I)
    fun values(I)

interface Seq =
    fun first(Seq)
    fun rest(Seq)

interface Emptiable(I) =
    fun empty(I)

interface Consable(I) =
    fun cons(value, I)

interface Prependable(I) =
    fun prepend(value, I)

interface Appendable(I) =
    fun append(value, I)

interface Concatable(I) =
    fun ++(I, other)

interface Indexed(I) =
    fun index_of(obj, I)

interface Seqable(I) =
    fun to_seq(I)

interface Castable(I) =
    fun cast(to_what, I)

interface Sliceable(I) =
    fun slice (first, last, I)
    fun drop(count, I)
    fun take(count, I)

interface Bounded(I) =
    fun lower_bound(I)
    fun upper_bound(I)

interface Ranged(I) =
    fun range(I, last)
    fun range_by (I, last, step)
    fun range_from(I)
    fun range_from_by(I, step)

interface Ref(I) =
    fun &(I)

interface MutRef(I) =
    use &(I)
    fun :=(I, value)

interface Replace(I) =
    fun <- (I, value)

interface Extract(I) =
    fun &&(I)

interface Callable(I) =
    fun call(I, args)

////////////////////////////////////////////////////////////
///////////////// TYPES ////////////////////////////////////
////////////////////////////////////////////////////////////

type LT
type GT
type EQ
type Some (val)
type None

// Various Errors
type ImportError(args)
type RuntimeError(args)
type TypeError(args)
type NotImplementedError(args)
type ZeroDivisionError(args)
type MathDomainError(args)
type ReferenceError(args)
type ConstructorError(args)
type KeyError(args)
type ValueError(args)
type SliceError(args)
type IndexError(args)
type InvokeError(args)
type InvalidArgCount(args)
type MethodInvokeError(args)
type MethodNotImplementedError(args)
type MethodSpecializeError(args)
type CompileError(args)
type ParseError(args)
type UnpackSequenceError(args)
type FiberFlowError(args)
type MatchError(args)
type FunctionArgumentsMatchError(args)
type ExceptionMatchError(args)
type ExportError(args)
type ImplementationError(args)
type ConstraintError(args)
type EmptySeqError(args)
type OverflowError(args)
//Signal used to interrupt recursive processes
type Interrupt(result)
type MessageMatchError(args)
type RangeError(args)
type CoroutineEmpty(args)

// Bootstrap interfaces behavior

trait TInstance(T) for Instance =
    def index_of (val, self of T) as record_index_of
    def keys(self of T) as record_keys
    def values(self of T) as record_values

    def put (k, v, self of T) as std_behavior:put
    def at (k, self of T) as std_behavior:at
    def del (el, self of T) as std_behavior:del
    def elem (el, self of T) as std_behavior:elem
    def len (self of T) as std_behavior:len
    def is_empty (self of T) as std_behavior:is_empty
    def cast(to_what, self of T) as std_behavior:cast

trait TSingleton(T)
    for [Singleton, Function, Generic, Partial,
        Datatype, Bool, Instance, Interface, PID] =

    def == (self of T, other) as std_behavior:equal
    def != (self of T, other) as  std_behavior:not_equal

    def str (self of T) as std_behavior:str
    def repr (self of T) as std_behavior:repr

def at (k, self of Map) as std_behavior:at
def at (el, self of Tuple) as std_behavior:at


////////////////////////////////////////////////////////////
///////////////// FUNCTIONS ////////////////////////////////
////////////////////////////////////////////////////////////
fun put_default(key, default, coll) =
    if elem(key, coll) then
        coll
    else
        put(key, default, coll)

type Lense(source, getter, setter)

fun lense(source, getter, setter) =
    let
        branch = getter(source)
    in
        if not kindof(branch, Collection) then
            throw TypeError("Branch is not a Collection")
        else
            Lense(source, getter, setter)

fun lookup (key, default, coll) =
    try
        at(key, coll)
    catch
        | e of KeyError = default
        | e = throw e

fun not_elem(x, c) = not(elem (x, c))

fun identity(x) = x

fun ~ (func) = curry(func)
fun .. (f, g) = curry(f)(g)

fun |>(x, f) = f(x)
fun <|(f, x) = f(x)
fun >>(f, g) = x -> g(f(x))
fun <<(f, g) = x -> f(g(x))

fun twice(f) = f >> f
fun flip (f, x, y) = f(y, x)
fun even(x) = mod(x, 2) == 0
fun odd(x) = not(even(x))
fun inc(x) = x + 1
fun dec(x) = x - 1

fun last(coll) = at(len(coll) - 1, coll)

fun downcast(any of Instance) = any as Instance

let
    fst = c -> at(0, c)
    snd = c -> at(1, c)
    thrd = c -> at(2, c)
    frth = c -> at(3, c)

let
    self = _process:self
    spawn = _process:spawn

fun __send__ (p of PID, msg) = _process:send(p, msg)

def <- (p of PID, msg) as __send__

fun __override__(generic, types, func) = func(method(generic, types))

fun __receive__(fn) =
    let
        proc = self()
//        _ = PL("__RECEIVE__", proc)
        fun _loop() =
            if not _process:is_empty(proc) == False then
                _process:pause(proc)
                _loop()
            else
                let
                    msg = _process:pop(proc)
                in
//                    PL("@@POP", proc, msg, _process:mailbox(proc))
                    fn(msg)
    in
        _loop()

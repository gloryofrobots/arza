import arza:lang:_std_behavior as std_behavior

from arza:lang:_datatype import (record_values, record_keys, record_index_of)


from arza:lang:_types import (Bool, Char, Int, Float, Symbol, String, List, Vector, Tuple, Map,
                              Function, Partial, Generic, FiberChannel, Coroutine, Interface, Datatype,
                              Module, Array, AssocArray, PID)

from arza:lang:_interfaces import (Instance, Singleton, Any)

from arza:lang:_bit import (bitand, bitor, bitxor, bitnot, lshift, rshift)
from arza:lang:_number import (abs)
import arza:lang:_process

"""
SOME OF THE OPERATORS DEFINED INTERNALLY AND SOME BELOW
Precedence    Operator
    100           : .
    95           x() .{ .[ ->
    60           :: :::
    55           **
    50           *  /
    40           +  - ++
    35           ==  !=  <  <=  >  >=
    30           and
    25           or << >>
    20           |>
    15           " ." as of <| <-
    10           = :=
"""

infixr (:=, :=, 10)
// infix @ as of -> 15
infixr (<-, <-, 15)
infixr (!, __send__, 15)
infixl (<|, <|, 15)
infixl (|>, |>, 20)
// infix or -> 25
infixl (<<, <<, 25)
infixl (>>, >>, 25)
// infix and -> 30
infixl (<, <, 35)
infixl (>, >, 35)
infixl (>=, >=, 35)
infixl (<=, <=, 35)
infixl (==, ==, 35)
infixl (!=, !=, 35)
infixl (++, ++, 40)
infixl (+, +, 40)
infixl (-, -, 40)
infixl (*, *, 50)
infixl (/, /, 50)
// use qualified name to prevent infinite loops in cases of declaring local negate function using prefix -
prefix (-, arza:lang:negate, 55)
// infix :: -> 60
infixl (**, **, 60)
// prefix # -> 70
prefix (&, &, 70)
prefix (&&, &&, 70)
infixl (.., .., 90)
// infix (  .{ .[ -> 95
prefix (~, ~, 96)
// infix . : -> 100

////////////////////////////////////////////////////////////
///////////////// INTERFACES ///////////////////////////////
////////////////////////////////////////////////////////////

interface Eq(I) =
    fun ==(x of I, y)
    fun !=(x of I, y)

interface Comparable(I) =
    fun cmp(first of I, second)

interface LessEq(I) is Eq =
    fun <=(first of I, second)

interface Ord(I) =
    use <=(first of I, second)
    use cmp(first of I, second)
    fun <(first of I, second)
    fun >=(first of I, second)
    fun >(first of I, second)
    fun max(first of I, second)
    fun min(first of I, second)

interface Num(I) =
    fun -(x of I, y)
    fun +(x of I, y)
    fun *(x of I, y)
    fun /(x of I, y)
    fun mod(x of I, y)
    // unary -
    fun negate(x of I)

interface Pow(I) =
    fun **(x of I, y)

interface Str =
    fun str(Str)

interface Repr(I) is Str =
    fun repr(I)

interface Len =
    fun len(Len)

interface IsEmpty(I) =
    fun is_empty(I)

interface Put(I) =
    fun put(key, value, I)

interface Del(I) =
    fun del(obj, I)

interface At(I) =
    fun at(key, I)
    fun elem(key, I)

interface Coll is (Put, At, Del)

interface Dict(I) is Coll =
    fun keys(self of I)
    fun values(I)

interface Seq =
    fun first(Seq)
    fun rest(Seq)

interface Empty(I) =
    fun empty(I)

interface Cons(I) =
    fun cons(value, I)

interface Prepend(I) =
    fun prepend(value, I)

interface Append(I) =
    fun append(value, I)

interface Concat(I) =
    fun ++(I, other)

interface Indexed(I) =
    fun index_of(obj, I)

interface ToSeq(I) =
    fun to_seq(I)

interface FromSeq(I) =
    fun from_seq(I)

interface Slice(I) =
    fun slice (first, last, I)
    fun drop(count, I)
    fun take(count, I)

interface Bound(I) =
    fun lower_bound(I)
    fun upper_bound(I)

interface Range(I) =
    fun range(I, last)
    fun range_by (I, last, step)
    fun range_from(I)
    fun range_from_by(I, step)

interface Ref(I) =
    fun &(I)

interface MutRef(I) =
    use &(I)
    fun :=(I, value)

interface Replace(I) =
    fun <- (I, value)

interface Extract(I) =
    fun &&(I)

interface Call(I) =
    fun call(I, args)

interface Cast(I) =
    fun cast(valueof to_what, I)

////////////////////////////////////////////////////////////
///////////////// TYPES ////////////////////////////////////
////////////////////////////////////////////////////////////

type LT
type GT
type EQ
type Some (val)
type None

// Various Errors
type Error(args)
type ImportError is Error
type RuntimeError is Error
type TypeError is Error
type NotImplementedError is Error
type ZeroDivisionError is Error
type MathDomainError is Error
type ReferenceError is Error
type ConstructorError is Error
type KeyError is Error
type ValueError is Error
type SliceError is Error
type IndexError is Error
type InvokeError is Error
type InvalidArgCount is Error
type MethodInvokeError is Error
type MethodNotImplementedError is Error
type MethodSpecializeError is Error
type CompileError is Error
type ParseError is Error
type UnpackSequenceError is Error
type FiberFlowError is Error
type MatchError is Error
type FunctionArgumentsMatchError is Error
type ExceptionMatchError is Error
type ExportError is Error
type ImplementationError is Error
type ConstraintError is Error
type EmptySeqError is Error
type OverflowError is Error
//Signal used to interrupt recursive processes
type Interrupt is Error
type MessageMatchError is Error
type RangeError is Error
type CoroutineEmpty is Error

// Bootstrap interfaces behavior


trait (T) for Instance =
    def index_of (val, self of T) as record_index_of
    def keys(self of T) as record_keys
    def values(self of T) as record_values

    def put (k, v, self of T) as std_behavior:put
    def at (k, self of T) as std_behavior:at
    def del (el, self of T) as std_behavior:del
    def elem (el, self of T) as std_behavior:elem
    def len (self of T) as std_behavior:len
    def is_empty (self of T) as std_behavior:is_empty
    def cast(to_what, self of T) as std_behavior:cast


trait (T)
    for [Singleton, Function, Generic, Partial,
        Datatype, Bool, Instance, Interface, PID, Module] =

    def == (self of T, other) as std_behavior:equal
    def != (self of T, other) as  std_behavior:not_equal

    def str (self of T) as std_behavior:str
    def repr (self of T) as std_behavior:repr


def at (k, self of Map) as std_behavior:at
def at (el, self of Tuple) as std_behavior:at


////////////////////////////////////////////////////////////
///////////////// FUNCTIONS ////////////////////////////////
////////////////////////////////////////////////////////////
fun put_default(key, default, coll) =
    if elem(key, coll) then
        coll
    else
        put(key, default, coll)

type Lense(source, getter, setter)

fun lense(source, getter, setter) =
    let
        branch = getter(source)
    in
        if not kindof(branch, Coll) then
            throw TypeError("Branch is not a Coll")
        else
            Lense(source, getter, setter)

fun lookup (key, default, coll) =
    try
        at(key, coll)
    catch
        | e of KeyError = default
        | e = throw e

fun not_elem(x, c) = not elem(x, c)

fun identity(x) = x

fun ~ (func) = curry(func)
fun .. (f, g) = curry(f)(g)

fun |>(x, f) = f(x)
fun <|(f, x) = f(x)
fun >>(f, g) = x -> g(f(x))
fun <<(f, g) = x -> f(g(x))

fun twice(f) = f >> f
fun flip (f, x, y) = f(y, x)
fun even(x) = mod(x, 2) == 0
fun odd(x) = not even(x)
fun inc(x) = x + 1
fun dec(x) = x - 1

fun last(coll) = at(len(coll) - 1, coll)

fun downcast(any) = any as Instance

let
    fst = c -> at(0, c)
    snd = c -> at(1, c)
    thrd = c -> at(2, c)
    frth = c -> at(3, c)

let
    self = _process:self
    spawn = _process:spawn

// special __at__ method which can be used for default access in case of overloading at
let __at__ = std_behavior:at

fun __send__ (p of PID, msg) = _process:send(p, msg)

def <- (p of PID, msg) as __send__

fun __override__(generic, types, func) = func(method(generic, types))

fun __receive__(fn) =
    let
        proc = self()
//        _ = PL("__RECEIVE__", proc)
        fun _loop() =
            if not _process:is_empty(proc) == False then
                _process:pause(proc)
                _loop()
            else
                let
                    msg = _process:pop(proc)
                in
//                    PL("@@POP", proc, msg, _process:mailbox(proc))
                    fn(msg)
    in
        _loop()

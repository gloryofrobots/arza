import arza:lang:_std_behavior as std_behavior

from arza:lang:_datatype import (record_values, record_keys, record_index_of)


from arza:lang:_types import (Bool, Char, Int, Float, Symbol, String, List, Vector, Tuple, Map,
                              Function, Partial, Generic, FiberChannel, Coroutine, Interface, Datatype,
                              Env, Array, AssocArray)

from arza:lang:_interfaces import (Instance, Singleton, Any)

from arza:lang:_bit import (bitand, bitor, bitxor, bitnot, lshift, rshift)

"""
SOME OF THE OPERATORS DEFINED INTERNALLY AND SOME BELOW
Precedence    Operator
    100           : . .{ .[
    95           x()
    60           :: :::
    55           **
    50           *  /
    40           +  - ++
    35           ==  !=  <  <=  >  >=
    30           and
    25           or << >>
    20           |>
    15           " ." @ as of <|
    10           = :=
"""

infixr (:=, :=, 10)
// infix @ as of -> 15
infixl (<|, <|, 15)
infixl (|>, |>, 20)
// infix or -> 25
infixl (<<, <<, 25)
infixl (>>, >>, 25)
// infix and -> 30
infixl (<, <, 35)
infixl (>, >, 35)
infixl (>=, >=, 35)
infixl (<=, <=, 35)
infixl (==, ==, 35)
infixl (!=, !=, 35)
infixl (++, ++, 40)
infixl (+, +, 40)
infixl (-, -, 40)
infixl (*, *, 50)
infixl (/, /, 50)
// use qualified name to prevent infinite loops in cases of declaring local negate function using prefix -
prefix (-, arza:lang:negate, 55)
// infix :: -> 60
infixl (**, **, 60)
// prefix # -> 70
prefix (!, !, 70)
infixl (.., .., 90)
// infix (  .{ .[ -> 95
prefix (&, &, 96)
// infix . : -> 100

////////////////////////////////////////////////////////////
///////////////// GENERICS /////////////////////////////////
////////////////////////////////////////////////////////////

generic
    ==(x, y)
    !=(x, y)
    <=(x, y)
    <(x, y)
    >=(x, y)
    >(x, y)

    cmp(first, second)

    max(first, second)
    min(first, second)

    -(x, y)
    +(x, y)
    *(x, y)
    /(x, y)
    mod(x, y)
    // unary -
    negate(x)
    **(x, y)

    str(self)
    repr(self)

    len(self)
    is_empty(self)

    at(key, self)
    put(key, value, self)
    del(obj, self)
    elem(key, self)

    first(self)
    rest(self)

    empty(self)
    cons(value, self)
    prepend(value, self)
    ++(self, other)
    append(value, self)
    keys(self)
    values(self)
    index_of(obj, self)
    to_seq(self)

    slice (first, last, self)
    drop(count, self)
    take(count, self)
    lower_bound(self)
    upper_bound(self)

    range(self, last)
    range_by (self, last, step)
    range_from(self)
    range_from_by(self, step)
    !(self)
    :=(self, value)
    cast(to_what, self)

////////////////////////////////////////////////////////////
///////////////// INTERFACES ///////////////////////////////
////////////////////////////////////////////////////////////


// TODO make interfaces attach to all gf positions if position is not given
// for generics with dots use parens (..).0
interface
    PartialEq (==)
    Eq (!=) is PartialEq
    Comparable(cmp)
    LessEq(<=) is PartialEq
    Ord(<, <=, >, >=, cmp, max, min)

    Num (-, +, *, /, mod, negate)
    Pow(**)

    Str (str)
    Displayed (repr) is Str

    Len(len)
    Sized (is_empty) is Len

    Coll(put.2, del.1)
    GrowableCollection(put.2)
    ShrinkableCollection(del.1)
    ReadOnlyCollection(at.1, elem.1)
    Collection() is (GrowableCollection, ShrinkableCollection, ReadOnlyCollection)

    Seq(first, rest)
    Emptiable(empty)
    Consable(cons.1)
    Prependable(prepend.1)
    Appendable(append.1)
    Concatable(++.1)
    Dict(keys, values) is Collection
    Indexed(index_of.1)
    Seqable(to_seq)

    Castable(cast.1)

    Sliceable(slice.2, drop.1, take.1)
    Bounded(lower_bound, upper_bound)
    Ranged(range, range_by, range_from, range_from_by)
    Ref(!)
    MutRef(!, :=)

////////////////////////////////////////////////////////////
///////////////// TYPES ////////////////////////////////////
////////////////////////////////////////////////////////////

type
    LT
    GT
    EQ
    Some (val)
    None

// Various Errors
type
    ImportError(args)
    RuntimeError(args)
    TypeError(args)
    NotImplementedError(args)
    ZeroDivisionError(args)
    MathDomainError(args)
    ReferenceError(args)
    ConstructorError(args)
    KeyError(args)
    ValueError(args)
    SliceError(args)
    IndexError(args)
    InvokeError(args)
    InvalidArgCount(args)
    MethodInvokeError(args)
    MethodNotImplementedError(args)
    MethodSpecializeError(args)
    CompileError(args)
    ParseError(args)
    UnpackSequenceError(args)
    FiberFlowError(args)
    MatchError(args)
    FunctionArgumentsMatchError(args)
    ExceptionMatchError(args)
    ExportError(args)
    ImplementationError(args)
    ConstraintError(args)
    EmptySeqError(args)
    OverflowError(args)
    //Signal used to interrupt recursive processes
    Interrupt(result)

// Bootstrap interfaces behavior

trait TInstance(T) for Instance =
    def index_of (val, self of T) as record_index_of
    def keys(self of T) as record_keys
    def values(self of T) as record_values

    def put (k, v, self of T) as std_behavior:put
    def at (k, self of T) as std_behavior:at
    def del (el, self of T) as std_behavior:del
    def elem (el, self of T) as std_behavior:elem
    def len (self of T) as std_behavior:len
    def is_empty (self of T) as std_behavior:is_empty
    def cast(to_what, self of T) as std_behavior:cast

trait TSingleton(T)
    for [Singleton, Function, Generic, Partial,
        Datatype, Bool, Instance, Interface] =

    def == (self of T, other) as std_behavior:equal
    def != (self of T, other) as  std_behavior:not_equal

    def str (self of T) as std_behavior:str
    def repr (self of T) as std_behavior:repr

def at (k, self of Map) as std_behavior:at
def at (el, self of Tuple) as std_behavior:at
////////////////////////////////////////////////////////////
///////////////// FUNCTIONS ////////////////////////////////
////////////////////////////////////////////////////////////


fun lookup (key, default, coll) =
    try
        at(key, coll)
    catch
        | e of KeyError = default
        | e = throw e

fun not_elem(x, c) = not(elem (x, c))

fun identity(x) = x

fun & (func) = arza:lang:defpartial(func)
fun .. (f, g) = arza:lang:defpartial(f)(g)

fun |>(x, f) = f(x)
fun <|(f, x) = f(x)
fun >>(f, g) = x -> g(f(x))
fun <<(f, g) = x -> f(g(x))

fun twice(f) = f >> f
fun flip (f, x, y) = f(y, x)
fun even(x) = mod(x, 2) == 0
fun odd(x) = not(even(x))
fun inc(x) = x + 1
fun dec(x) = x - 1
//fun last coll = at ((len coll) - 1) coll
fun last(coll) = at(len(coll) - 1, coll)

let
    fst = c -> at(0, c)
    snd = c -> at(1, c)
    thrd = c -> at(2, c)
    frth = c -> at(3, c)

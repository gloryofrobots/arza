import arza:lang:_std_behavior as std_behavior

import arza:lang:_datatype
include arza:lang:_datatype(supertype)

import arza:lang:_process

include arza:lang:_types (Any, Abstract, Record, Number, Bool, Char, Int, Float, Symbol, String, List, Vector, Tuple, Map,
                              Function, Partial, Generic, FiberChannel, Coroutine, Interface, Datatype,
                              Module, Array, AssocArray, PID)


include arza:lang:_bit (bitand, bitor, bitxor, bitnot, lshift, rshift)
include arza:lang:_number (abs)


"""
super BUG
io:print(
    #b,
    match 2
        | x = #c
  )
"""


"""
SOME OF THE OPERATORS DEFINED INTERNALLY AND SOME BELOW
Precedence    Operator
    100           : .
    95           x() .{ .[ ->
    60           :: :::
    55           **
    50           *  /
    40           +  - ++
    35           ==  !=  <  <=  >  >=
    30           and
    25           or << >>
    20           |>
    15           " ." as of <| <-
    10           = :=
"""

infixr (:=, :=, 10)
// infix @ as of -> 15
infixr (<-, <-, 15)
infixr (!, __send__, 15)
infixl (<|, <|, 15)
infixl (|>, |>, 20)
// infix or -> 25
infixl (<<, <<, 25)
infixl (>>, >>, 25)
// infix and -> 30
infixl (<, <, 35)
infixl (>, >, 35)
infixl (>=, >=, 35)
infixl (<=, <=, 35)
infixl (==, ==, 35)
infixl (!=, !=, 35)
infixl (++, ++, 40)
infixl (+, +, 40)
infixl (-, -, 40)
infixl (*, *, 50)
infixl (/, /, 50)
// use qualified name to prevent infinite loops in cases of declaring local negate function using prefix -
prefix (-, arza:lang:negate, 55)
// infix :: -> 60
infixl (**, **, 60)
// prefix # -> 70
prefix (&, &, 70)
prefix (&&, &&, 70)
infixl (.., .., 90)
// infix (  .{ .[ -> 95
prefix (~, ~, 96)
// infix . : -> 100


////////////////////////////////////////////////////////////
///////////////// INTERFACES ///////////////////////////////
////////////////////////////////////////////////////////////
fun [T] =
    ==(T, y)
    !=(T, y)

    cmp(T, second)

    <=(T, second)
    <(T, second)
    >=(T, second)
    >(T, second)
    max(T, second)
    min(T, second)

    -(T, y)
    +(T, y)
    *(T, y)
    /(T, y)
    mod(T, y)
    // unary -
    negate(T)

    **(T, y)

    str(Str)

    repr(T)

    len(Len)

    is_empty(T)

    put(T, key, value)

    del(T, obj)

    at(T, key)
    has(T, key)


    keys(T)
    values(T)

    first(Seq)
    rest(Seq)

    empty(T)

    cons(value, T)

    prepend(T, value)

    append(T, value)

    ++(T, other)

    index_of(T, obj)

    to_seq(T)

    from_seq(T)

    slice (T, first, last)
    drop(T, count)
    take(T, count)


    range(T, last)
    range_by (T, last, step)
    range_from(T)
    range_from_by(T, step)

    &(T)
    :=(T, value)
    <- (T, value)
    &&(T)

    call(T, args)

fun [valueof T]lower_bound(T)
fun [valueof T]upper_bound(T)
fun [T, valueof W] cast(T, W)

extend Record with
    def index_of (self, val) as _datatype:record_index_of
    def keys(self) as _datatype:record_keys
    def values(self) as _datatype:record_values

    def put(self, k, v) as std_behavior:put
    def at (self, k) as std_behavior:at
    def del (self, el) as std_behavior:del
    def has (self, el) as std_behavior:has
    def len (self) as std_behavior:len
    def is_empty (self) as std_behavior:is_empty
    def cast(self, to_what) as std_behavior:cast


extend Any with
    def == (self, other) as std_behavior:equal
    def != (self, other) as  std_behavior:not_equal

    def str (self) as std_behavior:str
    def repr (self) as std_behavior:repr


def at[Map] (self, k) as std_behavior:at
def at[Tuple] (self, el) as std_behavior:at


////////////////////////////////////////////////////////////
///////////////// TYPES ////////////////////////////////////
////////////////////////////////////////////////////////////

type LT
type GT
type EQ
type Some (val)
type None

// Various Errors
type Error(args)
type ImportError(...Error)
type RuntimeError(...Error)
type TypeError(...Error)
type NotImplementedError(...Error)
type ZeroDivisionError(...Error)
type MathDomainError(...Error)
type ReferenceError(...Error)
type ConstructorError(...Error)
type KeyError(...Error)
type ValueError(...Error)
type SliceError(...Error)
type IndexError(...Error)
type InvokeError(...Error)
type InvalidArgCount(...Error)
type MethodInvokeError(...Error)
type MethodNotImplementedError(...Error)
type MethodSpecializeError(...Error)
type CompileError(...Error)
type ParseError(...Error)
type UnpackSequenceError(...Error)
type FiberFlowError(...Error)
type MatchError(...Error)
type FunctionArgumentsMatchError(...Error)
type ExceptionMatchError(...Error)
type ExportError(...Error)
type ImplementationError(...Error)
type ConstraintError(...Error)
type EmptySeqError(...Error)
type OverflowError(...Error)
type MessageMatchError(...Error)
type RangeError(...Error)
type CoroutineEmpty(...Error)

////////////////////////////////////////////////////////////
///////////////// FUNCTIONS ////////////////////////////////
////////////////////////////////////////////////////////////

fun put_default(coll, key, default) =
    if has(coll, key) then
        coll
    else
        put(coll, key, default)

type Lense(source, getter, setter)

fun lense(source, getter, setter) =
    let
        branch = getter(source)
    in
        if not kindof(branch, Coll) then
            throw TypeError("Branch is not a Coll")
        else
            Lense(source, getter, setter)

fun lookup (key, default, coll) =
    try
        at(coll, key)
    catch
        | e of KeyError = default
        | e = throw e

fun elem(el, coll) = has(coll, el)
fun not_elem(x, c) = not elem(x, c)

fun identity(x) = x

fun ~ (func) = curry(func)
fun .. (f, g) = curry(f)(g)

fun |>(x, f) = f(x)
fun <|(f, x) = f(x)
fun >>(f, g) = x -> g(f(x))
fun <<(f, g) = x -> f(g(x))


fun twice(f) = f >> f
fun flip(f) = (x, y) -> f(y, x)

fun even(x) = mod(x, 2) == 0
fun odd(x) = not even(x)
fun inc(x) = x + 1
fun dec(x) = x - 1

fun last(coll) = at(coll, len(coll) - 1)

fun downcast(any) = any as Record

let
    fst = at(_, 0)
    snd = at(_, 1)
    thrd = at(_, 2)
    frth = at(_, 3)

let
    self = _process:self
    spawn = _process:spawn


fun extends((supertype, fields, _init), parent) =
    let
        new_init =
            match _init
            | () = _datatype:get_init(parent)
            | fn = fn
        new_super =
            match supertype
            | type Abstract = Record
            | _ = supertype
    in
        (new_super, _datatype:get_fields(parent) ++ fields, new_init)


fun setfield((supertype, fields, _init), field, value) =
    let
        fun _wrap(...args) =
            let
                data = _init(...args)
            in
                data.{(field) = value}
    in
        (supertype, fields, _wrap)


fun super(_type, obj, ...args) =
    if _datatype:has_init(_type) then
        let _init = _datatype:get_init(_type)
        in _init(obj, ...args)
    else
        let
            l = len(args)
            fun _loop(obj, index, args) =
                if index >= l then
                    obj
                else
                    _loop(obj.{(index) = args.[index]}, index + 1, args)
        in
            _loop(obj, 0, args)


// special __at__ method which can be used for default access in case of overloading at
let __at__ = std_behavior:at

fun __send__ (p of PID, msg) = _process:send(p, msg)

def <- (p of PID, msg) as __send__

fun __override__(generic, types, func) = func(method(generic, types))


fun __receive__(fn) =
    let
        proc = self()
//        _ = PL("__RECEIVE__", proc)
        fun _loop() =
            if not _process:is_empty(proc) == False then
                _process:pause(proc)
                _loop()
            else
                let
                    msg = _process:pop(proc)
                in
//                    PL("@@POP", proc, msg, _process:mailbox(proc))
                    fn(msg)
    in
        _loop()

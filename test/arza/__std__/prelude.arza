import arza:lang:_std_behavior as std_behavior

import arza:lang:_datatype
include arza:lang:_datatype(supertype)

import arza:lang:_process

include arza:lang:_types (Any, Abstract, Record, Number, Bool, Char, Int, Float, Symbol, String, List, Vector, Tuple, Map,
                              Function, Partial, Generic, FiberChannel, Coroutine, Interface, Datatype,
                              Module, Array, AssocArray, PID)


include arza:lang:_bit (bitand, bitor, bitxor, bitnot, lshift, rshift)
include arza:lang:_number (abs)


"""
super BUG
io:print(
    #b,
    match 2
        | x = #c
  )
"""


"""
SOME OF THE OPERATORS DEFINED INTERNALLY AND SOME BELOW
Precedence    Operator
    100           : .
    95           x() .{ .[ ->
    60           :: :::
    55           **
    50           *  /
    40           +  - ++
    35           ==  !=  <  <=  >  >=
    30           and
    25           or << >>
    20           |>
    15           " ." as of <| <-
    10           = :=
"""

infixr (:=, :=, 10)
// infix @ as of -> 15
infixr (<-, <-, 15)
infixr (!, __send__, 15)
infixl (<|, <|, 15)
infixl (|>, |>, 20)
// infix or -> 25
infixl (<<, <<, 25)
infixl (>>, >>, 25)
// infix and -> 30
infixl (<, <, 35)
infixl (>, >, 35)
infixl (>=, >=, 35)
infixl (<=, <=, 35)
infixl (==, ==, 35)
infixl (!=, !=, 35)
infixl (++, ++, 40)
infixl (+, +, 40)
infixl (-, -, 40)
infixl (*, *, 50)
infixl (/, /, 50)
// use qualified name to prevent infinite loops in cases of declaring local negate function using prefix -
prefix (-, arza:lang:negate, 55)
// infix :: -> 60
infixl (**, **, 60)
// prefix # -> 70
prefix (&, &, 70)
prefix (&&, &&, 70)
infixl (.., .., 90)
// infix (  .{ .[ -> 95
prefix (~, ~, 96)
// infix . : -> 100


////////////////////////////////////////////////////////////
///////////////// INTERFACES ///////////////////////////////
////////////////////////////////////////////////////////////

interface Eq(I) =
    ==(x of I, y)
    !=(x of I, y)

interface Comparable(I) =
    cmp(first of I, second)

interface LessEq(I) is Eq =
    <=(first of I, second)

interface Ord(I) =
    use <=(first of I, second)
    use cmp(first of I, second)
    <(first of I, second)
    >=(first of I, second)
    >(first of I, second)
    max(first of I, second)
    min(first of I, second)

interface Num(I) =
    -(x of I, y)
    +(x of I, y)
    *(x of I, y)
    /(x of I, y)
    mod(x of I, y)
    // unary -
    negate(x of I)

interface Pow(I) =
    **(x of I, y)

interface Str =
    str(Str)

interface Repr(I) is Str =
    repr(I)

interface Len =
    len(Len)

interface IsEmpty(I) =
    is_empty(I)

interface Put(I) =
    put(I, key, value)

interface Del(I) =
    del(I, obj)

interface At(I) =
    at(I, key)
    has(I, key)

interface Coll is (Put, At, Del)

interface Dict(I) is Coll =
    keys(self of I)
    values(I)

interface Seq =
    first(Seq)
    rest(Seq)

interface Empty(I) =
    empty(I)

interface Cons(I) =
    cons(value, I)

interface Prepend(I) =
    prepend(I, value)

interface Append(I) =
    append(I, value)

interface Concat(I) =
    ++(I, other)

interface Indexed(I) =
    index_of(I, obj)

interface ToSeq(I) =
    to_seq(I)

interface FromSeq(I) =
    from_seq(I)

interface Slice(I) =
    slice (I, first, last)
    drop(I, count)
    take(I, count)

interface Bound(I) =
    lower_bound(I)
    upper_bound(I)

interface Range(I) =
    range(I, last)
    range_by (I, last, step)
    range_from(I)
    range_from_by(I, step)

interface Ref(I) =
    &(I)

interface MutRef(I) =
    use &(I)
    :=(I, value)

interface Replace(I) =
    <- (I, value)

interface Extract(I) =
    &&(I)

interface Call(I) =
    call(I, args)

interface Cast(I) =
    cast(I, valueof to_what)

// Bootstrap interfaces behavior


trait (T) for Record =
    def index_of (self of T, val) as _datatype:record_index_of
    def keys(self of T) as _datatype:record_keys
    def values(self of T) as _datatype:record_values

    def put (self of T, k, v) as std_behavior:put
    def at (self of T, k) as std_behavior:at
    def del (self of T, el) as std_behavior:del
    def has (self of T, el) as std_behavior:has
    def len (self of T) as std_behavior:len
    def is_empty (self of T) as std_behavior:is_empty
    def cast(self of T, to_what) as std_behavior:cast


trait (T) for Any =
//    for [Abstract, Function, Generic, Partial,
//        Datatype, Bool, Record, Interface, PID, Module] =

    def == (self of T, other) as std_behavior:equal
    def != (self of T, other) as  std_behavior:not_equal

    def str (self of T) as std_behavior:str
    def repr (self of T) as std_behavior:repr


def at (self of Map, k) as std_behavior:at
def at (self of Tuple, el) as std_behavior:at


////////////////////////////////////////////////////////////
///////////////// TYPES ////////////////////////////////////
////////////////////////////////////////////////////////////

type LT
type GT
type EQ
type Some (val)
type None

// Various Errors
type Error(args)
type ImportError(...Error)
type RuntimeError(...Error)
type TypeError(...Error)
type NotImplementedError(...Error)
type ZeroDivisionError(...Error)
type MathDomainError(...Error)
type ReferenceError(...Error)
type ConstructorError(...Error)
type KeyError(...Error)
type ValueError(...Error)
type SliceError(...Error)
type IndexError(...Error)
type InvokeError(...Error)
type InvalidArgCount(...Error)
type MethodInvokeError(...Error)
type MethodNotImplementedError(...Error)
type MethodSpecializeError(...Error)
type CompileError(...Error)
type ParseError(...Error)
type UnpackSequenceError(...Error)
type FiberFlowError(...Error)
type MatchError(...Error)
type FunctionArgumentsMatchError(...Error)
type ExceptionMatchError(...Error)
type ExportError(...Error)
type ImplementationError(...Error)
type ConstraintError(...Error)
type EmptySeqError(...Error)
type OverflowError(...Error)
//Signal(...d) to interrupt recursive processes
type Interrupt(...Error)
type MessageMatchError(...Error)
type RangeError(...Error)
type CoroutineEmpty(...Error)

////////////////////////////////////////////////////////////
///////////////// FUNCTIONS ////////////////////////////////
////////////////////////////////////////////////////////////

fun put_default(coll, key, default) =
    if has(coll, key) then
        coll
    else
        put(coll, key, default)

type Lense(source, getter, setter)

fun lense(source, getter, setter) =
    let
        branch = getter(source)
    in
        if not kindof(branch, Coll) then
            throw TypeError("Branch is not a Coll")
        else
            Lense(source, getter, setter)

fun lookup (key, default, coll) =
    try
        at(coll, key)
    catch
        | e of KeyError = default
        | e = throw e

fun elem(el, coll) = has(coll, el)
fun not_elem(x, c) = not elem(x, c)

fun identity(x) = x

fun ~ (func) = curry(func)
fun .. (f, g) = curry(f)(g)

fun |>(x, f) = f(x)
fun <|(f, x) = f(x)
fun >>(f, g) = x -> g(f(x))
fun <<(f, g) = x -> f(g(x))


fun twice(f) = f >> f
fun flip(f) = (x, y) -> f(y, x)

fun even(x) = mod(x, 2) == 0
fun odd(x) = not even(x)
fun inc(x) = x + 1
fun dec(x) = x - 1

fun last(coll) = at(coll, len(coll) - 1)

fun downcast(any) = any as Record

let
    fst = at(_, 0)
    snd = at(_, 1)
    thrd = at(_, 2)
    frth = at(_, 3)

let
    self = _process:self
    spawn = _process:spawn


fun extends((supertype, fields, _init), parent) =
    let
        new_init =
            match _init
            | () = _datatype:get_init(parent)
            | fn = fn
        new_super =
            match supertype
            | type Abstract = Record
            | _ = supertype
    in
        (new_super, _datatype:get_fields(parent) ++ fields, new_init)


fun setfield((supertype, fields, _init), field, value) =
    let
        fun _wrap(...args) =
            let
                data = _init(...args)
            in
                data.{(field) = value}
    in
        (supertype, fields, _wrap)


fun super(_type, obj, ...args) =
    if _datatype:has_init(_type) then
        let _init = _datatype:get_init(_type)
        in _init(obj, ...args)
    else
        let
            l = len(args)
            fun _loop(obj, index, args) =
                if index >= l then
                    obj
                else
                    _loop(obj.{(index) = args.[index]}, index + 1, args)
        in
            _loop(obj, 0, args)


// special __at__ method which can be used for default access in case of overloading at
let __at__ = std_behavior:at

fun __send__ (p of PID, msg) = _process:send(p, msg)

def <- (p of PID, msg) as __send__

fun __override__(generic, types, func) = func(method(generic, types))


fun __receive__(fn) =
    let
        proc = self()
//        _ = PL("__RECEIVE__", proc)
        fun _loop() =
            if not _process:is_empty(proc) == False then
                _process:pause(proc)
                _loop()
            else
                let
                    msg = _process:pop(proc)
                in
//                    PL("@@POP", proc, msg, _process:mailbox(proc))
                    fn(msg)
    in
        _loop()

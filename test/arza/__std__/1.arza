module observe
    import std
    import list
    import seq

    type
        observers = {}
        history = []

    fun Observable(observers) 
        type{observers=observers}

    interface Emitter
        fun emit_signal(Emitter, signal, data)

    interface Observable as self
        use Emitter
        fun add_observer(self, signal, observer)
        fun remove_observer(self, signal, observer)
        use std:to_str
        use list:Listable:to_list

    implement Observable for type
        fun emit_signal(self, signal, data) 
            seq:each(self.observers, (observer) => observer(signal, data))

        fun add_observer(self, signal, observer)
             self.observers[signal] = self

        fun remove_observer(self, signal, observer)
            remove(self.observers, signal)

        fun to_str(self) 
            "Observable [" + 
                (self.observers |>
                    seq:map(_, to_str)
                    str:join(_, ", "))
                + "]"

        use list:Listable:to_list(self)
            to_list(self.observers)







module observe
    type Observable
        observers = {} 
        handled_signals = []

    fun add_observer(connection, controller)
        connection.{observers = @.[observer.name] = observer}
        connection.{observers = put(observer.name, observer, connection.observers)}
        connection.{observers = put(observer.name, observer, @)}

    fun notify_mutable(connection, signal, data)
        observer = connection.observers.[signal]

        before_observe(observer, signal, data)
        result = observe(observer, signal, data)
        log_observer(observer)

        after_observe(connection, observer, result)
        append(connection.handled_signals, result)
        result

    fun notify(connection, signal, data)
        observer = connection.observers.[signal]

        observer = before_observe(observer, signal, data)
        (observer,result) = observe(observer, signal, data)
        log_observer(observer)
        (connection, observer, result) = after_observe(connection, observer, result)
        connection.observers.[signal] = observer
        new_conection = connection.{
            handled_signals=append((signal, result), connection.handled_signals)
            observers.{[signal] = observer}
        }

        (new_connection, result)

    fun notify_2(connection, signal, data)
        path connection.contollers.[signal] as observer
        observer=before_observe(observer, signal, data)

        put_in(connection, [#controllers, signal], )
        connection.{
            controllers.{
                [signal] as observer.{
                    let 
                       observer_1 = before_observe(observer, signal, data)
                       oberver_
                    in 


                }
            }
        }
        with connection.observers.[signal] as observer
        observer = before_observe(observer, signal, data)
        (observer,result) = observe(observer, signal, data)
        log_observer(observer)
        (connection, observer, result) = after_observe(connection, observer, result)
        connection.observers.[signal] = observer
        (connection, result)

    fun notify(connection, signal, data)
        swap connection.observers.[signal] as observer
            (@,result) = observe(observer, signal, data)
            connection.observers.[signal] = observer

module controller
    type Controller 
        name = nil
        db = property(get=get_db, set=set_db)
        schema = notnil
        __loops = []
    


    def dispatch(message, self of Controller)
        try 
            _dispatch(self)
        catch Error @ e
            io:print e

    def _dispatch(message, self:Controller) 

    abstract fun create_controller() 

    
module scm
    import controller
    type Controller
        use controller.Controller





module component
    abstract fun init() 
    abstract fun close()


module authentication
    import component with
        fun init() "init"
        fun close() "close"








type Robot(battery_power)

def at(#battery_power, s of Robot) =
    (s as Instance).battery_power + 1

module world
    module animal
        fun eat(animal, food)
        fun kill(animal, victim)
        fun hunt(animal, victim)
        fun run_away(animal, hunter)

        interface Animal
            """
            basic animal actions
            """

        interface Animal
            """
            basic animal actions
            """
            eat.1
            kill.1
            hunt.1
            run_away.1

        interface Hunter
            hunt.1
            kill.1

        interface Prey
            run_away.1



        fun map(f, coll)
            | (f, []) = empty(coll)
            | (f, hd::tl) = f(hd) :: map(f, tl)        

        def map(f of Fun, coll of Complex) 
            if is_empty(coll) then
                empty(coll)
            else
                f(rest(coll))




















affirm:is_equal(add(v1, v2), Vec2(Point2(10, 12), Point2(14, 16)))


affirm:is_equal(
    (fun (x, y) =
        print(x, y)
        z = x + sqrt(x)
        transpose(x, y, sum((x,y,z)))
    ),
    Vec2(
        Point2(10, 12),
        Point2(14, 16)
   )

(fun filter(predicate, coll) =
    (fun _wrap(yield) =
        (fun _filter
            | (p, []) = empty(coll)
            | (p, x::xs) =
                (if p x then
                    yield(x)
                    io.print(
                        (match x
                            | 0 = #null
                            | 1 = #one
                            | (a, b, c) = a + b + c
                        )
                    )
                    _filter(p, xs)
                else
                    io.print(x)
                    _filter(p, xs)
                )
        )
        _filter(predicate, coll)
    )
    coroutine(_wrap)
)



(fun var (v) =
    co = coroutine(
            (fun (yield, v) =
                (fun loop(v) =
                    msg = yield(v)
                    (match msg
                        | #Read = loop(v)
                        | (#Write, new_val) =
                            loop(new_val)
                    )
                )
            )
        )

    co(v)
    Var(co)
)

(fun loop(...a) =
        let (init_fn, args) = tuple:split(a)
        co = spawn(
            (fun (yield) =
                let fn = init_fn(
                    (fun (...args) =
                        apply(yield, args)
                        apply(fn,  args)
                    )
                )
                yield()
                apply(fn,  args)
            )
        )
   co()
   co
)

(fun nbn_1 () =
    (fun _loop (n, g) =
        (if g == 1 or n < g then
           1
        else
            seq:foldl(
                (fun _folder(q, res) =
                    (if q > n - g then
                        x = 0
                    else
                        x = _loop(n-g, q)
                    )

                    res + x
                ),
                1,
                list:range(2, g)
            )
         )
    )
    string:join(
        seq:map(
            n => string:join_cast(
               seq:map(
                  (g => _loop n g)
                  (list:range 1 n)
               ),
               " "
            ),
            list:range(1, 25)
        ),
        "\n"
    )
)

(fun nbn_3 () =
    string:join(
        seq:map(
            (fun(n) =
                string:join_cast(
                   seq:map(
                        (fun (g) =
                                (fun _loop (n, g) =
                                    (if g == 1 or n < g then 1
                                    else
                                        seq:foldl(
                                            (fun (q, res) =
                                                res + 0 if q > n - g else _loop(n-g, q)
                                            ),
                                            1,
                                            range(2, g)
                                        )
                                    )
                                )
                                _loop(n, g)
                        ),
                        range(1, n),
                   ),
                   " "
                )
           ),
           range(1, 25),
        )
        "\n"
    )
)

fun nbn_3 () =
    string:join(
        seq:map(
            fun(n) =
                string:join_cast(
                   seq:map(
                        fun (g) =
                                let fun _loop (n, g) =
                                        if g == 1 or n < g then 1
                                        else
                                            seq:foldl(
                                                (fun (q, res) =
                                                    res + 0 if q > n - g else _loop(n-g, q)
                                                ),
                                                1,
                                                range(2, g)
                                            )

                                in _loop(n, g)
                        ,
                        range(1, n),
                   ),
                   " "
                )
           ,
           range(1, 25),
        )
        "\n"
    )







ys =
    coro:take(10,
        coro:map(x -> (x, str(x)),
            coro:drop(3,
                 coro:filter(odd, numbers))))

    y = (coro:take 10
            (coro:map x->(x, str(x))
                (coro:drop 3
                    (coro:filter odd numbers))))


fun zipwith(fn, co1, co2) =
    spawn(
        fun (yield) =
                (let (fun _zip
                        | (co1, co2) when is_empty(co1) or is_empty(co2) =
                            []
                        | (x::co1, y::co2) =
                            (if is_empty(co1) or is_empty(co2) then
                                fn(x,y)
                            else
                                yield(fn(x,y))
                                _zip(co1, co2)
                            )
                     )
                in
                    _zip(co1, co2)
                )
    )



fun zipwith(fn, co1, co2) =
    spawn(
        fun (yield)
            let
                fun _zip
                    | (co1, co2) when is_empty(co1) or is_empty(co2) =
                        []
                    | (x::co1, y::co2) =
                        if is_empty(co1) or is_empty(co2) then
                            fn(x,y)
                        else
                            yield(fn(x,y))
                            _zip(co1, co2)
                        end
                 end
            in
                _zip(co1, co2)
            end
    )
end


fun range_by (first of Int, last of Int, step of Int) =
    let fun _range_by
        | (N, X, D, L) when N >= 4 =
            let
                Y = X - D
                Z = Y - D
                W = Z - D
            in
                _range_by(N - 4, W - D, D, W :: Z :: Y :: X :: L)
            end

        | (N, X, D, L) when N >= 2 =

            let
                Y = X - D
            in
                _range_by(N - 2, Y - D, D, Y :: X :: L)
            end

        | (1, X, _, L) = X :: L

        | (0, _, _, L) = L
        end
    in
        if step > 0 and first - step <= last or
            step < 0 and first - step >= last then

            let
                n = ((last - first + step) / step) - 1
            in
                _range_by(n, (step * (n - 1) + first), step, [])
            end

        elif step == 0 and first == last then
            _range_by(1, first, step, [])
        else
            throw (#InvalidRange, first, last, step)
        end
    end
end

(fun range_by (first of Int, last of Int, step of Int) =
    (let
        (fun _range_by
            | (N, X, D, L) when N >= 4 =
                (let
                    Y = X - D
                    Z = Y - D
                    W = Z - D
                in
                    _range_by(N - 4, W - D, D, W :: Z :: Y :: X :: L)
                )

            | (N, X, D, L) when N >= 2 =

                (let
                    Y = X - D
                in
                    _range_by(N - 2, Y - D, D, Y :: X :: L)
                )

            | (1, X, _, L) = X :: L

            | (0, _, _, L) = L
        )
    in
        (if step > 0 and first - step <= last or
            step < 0 and first - step >= last then

            (let
                n = ((last - first + step) / step) - 1
            in
                _range_by(n, (step * (n - 1) + first), step, [])
            )

        elif step == 0 and first == last then
            _range_by(1, first, step, [])
        else
            throw (#InvalidRange, first, last, step)
        )
    )
)










affirm:is_equal(add(v1, v2), Vec2(Point2(10, 12), Point2(14, 16)))


affirm:is_equal(
    (fun (x, y) =
        print(x, y)
        z = x + sqrt(x)
        transpose(x, y, sum((x,y,z)))
    ),
    Vec2(
        Point2(10, 12),
        Point2(14, 16)
   )

(fun filter(predicate, coll) =
    (fun _wrap(yield) =
        (fun _filter
            | (p, []) = empty(coll)
            | (p, x::xs) =
                (if p x then
                    yield(x)
                    io.print(
                        (match x
                            | 0 = #null
                            | 1 = #one
                            | (a, b, c) = a + b + c
                        )
                    )
                    _filter(p, xs)
                else
                    io.print(x)
                    _filter(p, xs)
                )
        )
        _filter(predicate, coll)
    )
    coroutine(_wrap)
)



(fun var (v) =
    co = coroutine(
            (fun (yield, v) =
                (fun loop(v) =
                    msg = yield(v)
                    (match msg
                        | #Read = loop(v)
                        | (#Write, new_val) =
                            loop(new_val)
                    )
                )
            )
        )

    co(v)
    Var(co)
)

(fun loop(...a) =
        let (init_fn, args) = tuple:split(a)
        co = spawn(
            (fun (yield) =
                let fn = init_fn(
                    (fun (...args) =
                        apply(yield, args)
                        apply(fn,  args)
                    )
                )
                yield()
                apply(fn,  args)
            )
        )
   co()
   co
)

(fun nbn_1 () =
    (fun _loop (n, g) =
        (if g == 1 or n < g then
           1
        else
            seq:foldl(
                (fun _folder(q, res) =
                    (if q > n - g then
                        x = 0
                    else
                        x = _loop(n-g, q)
                    )

                    res + x
                ),
                1,
                list:range(2, g)
            )
         )
    )
    string:join(
        seq:map(
            n => string:join_cast(
               seq:map(
                  (g => _loop n g)
                  (list:range 1 n)
               ),
               " "
            ),
            list:range(1, 25)
        ),
        "\n"
    )
)

(fun nbn_3 () =
    string:join(
        seq:map(
            (fun(n) =
                string:join_cast(
                   seq:map(
                        (fun (g) =
                                (fun _loop (n, g) =
                                    (if g == 1 or n < g then 1
                                    else
                                        seq:foldl(
                                            (fun (q, res) =
                                                res + 0 if q > n - g else _loop(n-g, q)
                                            ),
                                            1,
                                            range(2, g)
                                        )
                                    )
                                )
                                _loop(n, g)
                        ),
                        range(1, n),
                   ),
                   " "
                )
           ),
           range(1, 25),
        )
        "\n"
    )
)

fun nbn_3 () =
    string:join(
        seq:map(
            fun(n) =
                string:join_cast(
                   seq:map(
                        fun (g) =
                                let fun _loop (n, g) =
                                        if g == 1 or n < g then 1
                                        else
                                            seq:foldl(
                                                (fun (q, res) =
                                                    res + 0 if q > n - g else _loop(n-g, q)
                                                ),
                                                1,
                                                range(2, g)
                                            )

                                in _loop(n, g)
                        ,
                        range(1, n),
                   ),
                   " "
                )
           ,
           range(1, 25),
        )
        "\n"
    )







ys =
    coro:take(10,
        coro:map(x -> (x, str(x)),
            coro:drop(3,
                 coro:filter(odd, numbers))))

    y = (coro:take 10
            (coro:map x->(x, str(x))
                (coro:drop 3
                    (coro:filter odd numbers))))


fun zipwith(fn, co1, co2) =
    spawn(
        fun (yield) =
                (let (fun _zip
                        | (co1, co2) when is_empty(co1) or is_empty(co2) =
                            []
                        | (x::co1, y::co2) =
                            (if is_empty(co1) or is_empty(co2) then
                                fn(x,y)
                            else
                                yield(fn(x,y))
                                _zip(co1, co2)
                            )
                     )
                in
                    _zip(co1, co2)
                )
    )



fun zipwith(fn, co1, co2) =
    spawn(
        fun (yield)
            let
                fun _zip
                    | (co1, co2) when is_empty(co1) or is_empty(co2) =
                        []
                    | (x::co1, y::co2) =
                        if is_empty(co1) or is_empty(co2) then
                            fn(x,y)
                        else
                            yield(fn(x,y))
                            _zip(co1, co2)
                        end
                 end
            in
                _zip(co1, co2)
            end
    )
end


fun range_by (first of Int, last of Int, step of Int) =
    let fun _range_by
        | (N, X, D, L) when N >= 4 =
            let
                Y = X - D
                Z = Y - D
                W = Z - D
            in
                _range_by(N - 4, W - D, D, W :: Z :: Y :: X :: L)
            end

        | (N, X, D, L) when N >= 2 =

            let
                Y = X - D
            in
                _range_by(N - 2, Y - D, D, Y :: X :: L)
            end

        | (1, X, _, L) = X :: L

        | (0, _, _, L) = L
        end
    in
        if step > 0 and first - step <= last or
            step < 0 and first - step >= last then

            let
                n = ((last - first + step) / step) - 1
            in
                _range_by(n, (step * (n - 1) + first), step, [])
            end

        elif step == 0 and first == last then
            _range_by(1, first, step, [])
        else
            throw (#InvalidRange, first, last, step)
        end
    end
end

(fun range_by (first of Int, last of Int, step of Int) =
    (let
        (fun _range_by
            | (N, X, D, L) when N >= 4 =
                (let
                    Y = X - D
                    Z = Y - D
                    W = Z - D
                in
                    _range_by(N - 4, W - D, D, W :: Z :: Y :: X :: L)
                )

            | (N, X, D, L) when N >= 2 =

                (let
                    Y = X - D
                in
                    _range_by(N - 2, Y - D, D, Y :: X :: L)
                )

            | (1, X, _, L) = X :: L

            | (0, _, _, L) = L
        )
    in
        (if step > 0 and first - step <= last or
            step < 0 and first - step >= last then

            (let
                n = ((last - first + step) / step) - 1
            in
                _range_by(n, (step * (n - 1) + first), step, [])
            )

        elif step == 0 and first == last then
            _range_by(1, first, step, [])
        else
            throw (#InvalidRange, first, last, step)
        )
    )
)










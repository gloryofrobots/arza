import affirm

type V(val)

interface Add =
    fun add(@v1, v2)

interface Sub =
    fun sub(@v1, v2)

interface Value is (Add, Sub) =
    fun val(v)

def add(v1 of V, v2 of V) = v1.val +  v2.val
def sub(v1 of V, v2 of V) = v1.val - v2.val

def val(v of Sub) = v.val - 1000
def val(v of Add) = v.val + 1000
def val(v of V) = v.val

def +(v1 of Int, v2 of Value) = val(v2) + v1
def +(v1 of Int, v2 of Add) = v1

def +(v1 of Sub, v2 of Int) = val(v1) + v2 + 10
def +(v1 of Add, v2 of Int) = val(v1) + v2 + 1000

describe V as (Add, Sub, Value)

fun test() =
    let
        v1 = V(1)
        v2 = V(10)
    in
        affirm:is_true(V `is_implemented` Add)
        affirm:is_true(V `is_implemented` Sub)
        affirm:is_true(V `is_implemented` Value)
        affirm:is_equal(val(v1), 1)
        affirm:is_equal(1 + v1, 2)
        affirm:is_equal(v1 + 1, 1002)

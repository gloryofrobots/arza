import io
import affirm
import generics

generic f2(x, y)

def f2 (x of Int, y of Float) = #int_float
def f2 (x of Int, y of Int) = #int_int
def f2 (x of Float, y of Int) = #float_int
def f2 (x of Float, y of Float) = #float_float
def f2 (x of Int, y of Seq) = #int_seq
def f2 (x of Indexed, y of Seq) = #indexed_seq
def f2 (x of Any, y of Any) = #any_any
def f2 (x of Any, y of Seq) = #any_seq
def f2 (x of Int, y of Any) = #int_any

fun test_binary () =
(
    affirm:is_equal(f2(1, 0.1), #int_float)
    affirm:is_equal(f2(0.2, 0.1), #float_float)
    affirm:is_equal(f2(0.654, 1), #float_int)
    affirm:is_equal(f2(1, 1), #int_int)

    affirm:is_equal(f2((), []), #indexed_seq)
    affirm:is_equal(f2(0, []), #int_seq)

    affirm:is_equal(f2({}, {}), #any_any)
    affirm:is_equal(f2(f2, Any), #any_any)
    affirm:is_equal(f2({}, []), #any_seq)
    affirm:is_equal(f2(42, #any), #int_any)
)

/////////////////////////////////////////////

generic f1(x, y, z)

def f1 (x of Any, y, z) = #any
def f1 (x of Int, y, z) = #int
def f1 (x of Seq, y, z) = #seq

fun test_unary () =
(
    affirm:is_equal(f1(0, {}, Tuple), #int)
    affirm:is_equal(f1(1 :: 2 :: 3 :: [], 42, ()), #seq)
    affirm:is_equal(f1({}, 42, ()), #any)
)

////////////////////////////////////////////////////

generic f6 (x, y, z, a, b,  c)

def f6 (x, y of Int, z of Float, a, b, c of String) = #int_float_string
def f6 (x, y, z, a, b, c of String) = #any_any_string
def f6 (x, y of String, z, a, b, c of String) = #string_any_string


fun test_triple() =
(
    affirm:is_equal(f6([], 0, 0.1, [], [], "string"), #int_float_string)
    affirm:is_equal(f6([], "string1", 0.1, [], [], "string1"), #string_any_string)
    affirm:is_equal(f6([], [], 0.1, [], [], "string1"), #any_any_string)
)

////////////////////////////////////////////////////////

type
(
    Pig(weight, coolness)
    Elephant(weight, shyness)
    PiggyElly(weight, coolshness)
)

generic
(
    made (s1, s2)
    give_birth(mother, father)
    regret_things(person)
)

interface
(
    FirstMade(made.0)
    SecondMade(made.1)
    Mother(give_birth.0)
    Father(give_birth.1)
    WisePerson(regret_things)
)

import std
// TODO at(#weight, self as Instance)
// or previous_method(#weight, self as Instance)
def at (key, self of Pig) =
    match key
    | #weight = (#this_is_not_my_real_weight, std:Behavior.[at](#weight, self))
    | _ = std:Behavior.[at](key, self)



def made (p of Pig, e of Elephant) =
(
    if p.coolness - e.shyness > 0 then
        #Coooool
    else
        #Notcoolatall
)

def made(e of Elephant, p of Pig) = made(p, e)

def give_birth (p of Pig, e of Elephant) = PiggyElly(p.weight.1 + e.weight, p.coolness + e.shyness)

def regret_things (m of Mother) = True

derive (FirstMade, SecondMade) for (Pig, Elephant)
derive (Mother) for (Pig)
derive (WisePerson) for (Pig)
derive (Father) for (Elephant)


fun test_pigs_and_elephants() =
(
    let
        p = Pig(100, 100)
        e = Elephant(1000, 90)
        pe = give_birth(p, e)
    in
    (
        affirm:is_equal(p.weight, (#this_is_not_my_real_weight, 100))
        affirm:is_equal(made(p, e), #Coooool)
        affirm:is_equal(made(e, p), #Coooool)
        affirm:is_equal(pe.weight, 1100)
        affirm:is_equal(pe.coolshness, 190)
        affirm:is_false(p `kindof` Father)
        affirm:is_true(p `kindof` Mother)

        affirm:is_true(p `kindof` WisePerson)
    )
//    test()
)

/////////////////////////////////

fun test() =
(
    test_unary()
    test_binary()
    test_triple()
    test_pigs_and_elephants()
)

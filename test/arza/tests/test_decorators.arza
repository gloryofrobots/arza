import affirm
import io

fun add1(fn, v) =
    fun (x, ...args) =
        fn(x+v, ...args)

fun add2(fn, v1, v2) =
    fun (x, y) =
        fn(x+v1, y+v2)

interface I =
    fun add(I, y)
    fun sub(I, y)

@add1(10)
@add2(0.1, 0.2)
def add(x of Int, y of Int) = x + y

def sub(x of Int, y of Int) =  x - y

@add1(10)
def+(super) sub(x of Int, y of Int) =  super(x, y) + super(x, y)


trait Add(T) for Float =
    @add1(0.1)
    @add1(0.01)
    def add(x of T, y of T) = x + y

    @add2(0.001, 0.0001)
    def+ (super) add(x of T, y of T) = super(x, y) * -1


fun test_simple() =
    let
        @add1(10)
        @add2(0.1, 0.2)
        fun f(x, y) = x + y
    in
        affirm:is_equal_all(f(1,2), add(1,2), 13.3)
        affirm:is_equal(sub(100, 1), 218)
        affirm:is_equal(add(1.0, 2.0), -3.1111)

/////////////////////////////////////////////////////////
//TYPES ///////////////////////////////////////////////////////
/////////////////////////////////////////////////////////

fun add_y(t) = add_field(t, #y)

fun add_field ((fields, _init) as typedata, field) =
    if not elem(field, fields) then
        (append(field, fields), _init)
    else
        typedata

fun init_field_with((fields, _init), field, value, fn) =
    let
        fun _wrap(...args) =
            let
                data = _init(...args)
            in
                data.{(field) = fn(@, value)}
    in
        (fields, _wrap)


fun init_field((fields, _init), field, value) =
    let
        fun _wrap(...args) =
            let
                data = _init(...args)
            in
                data.{(field) = value}
    in
        (fields, _wrap)


@add_field(#z)
@add_y
type XYZ(x)

@add_field(#c)
@add_field(#b)
@add_field(#a)
type ABC()


@init_field(#b, #b)
@init_field_with(0, #c, (x, y) -> x ++ y)
@add_field(#b)
type AB(a)
    init (self, a) = self.{a=a}

type Sum(v)
    init (self, x, y) =
        self.{v = x + y}

@extends(Sum)
type Sum2

///////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////

fun dispatch(fn, ...indexes) =
    __dispatch(fn, indexes)

fun register(fn, method, ...types) =
    __register(method, types, fn)

@dispatch(0)
fun tostr(v) = v

@register(tostr, Int)
fun tostr_i(v) =
    "<int>"

@register(tostr, Float)
fun tostr_f(v) =
    "<float>"

@dispatch(0, 1)
fun plus(x, y) = ()

@register(plus, Int, Int)
fun plus_i_i(x, y) =
    "i + i"

@register(plus, Int, Float)
fun plus_i_f(x, y) =
    "i + f"

@register(plus, Float, Int)
fun plus_f_i(x, y) =
    "f + i"

@register(plus, Float, Float)
fun plus_f_f(x, y) =
    "f + f"

@register(plus, Int, String)
fun plus_i_s(x, y) =
    "i + s"

@register(plus, String, Int)
fun plus_s_i(x, y) =
    "s + i"

@register(plus, String, Float)
fun plus_s_f(x, y) =
    "s + f"

fun test_register() =
    io:print(tostr(1))
    io:print(tostr(1.0))
    io:println(
        plus(1, 1),
        plus(1, 1.0),
        plus(1.0, 1),
        plus(1.0, 1.0),
        plus(1, "1"),
        plus("1", 1),
        plus("1", 1.0)
    )

fun test_types() =
    let
        xyz = XYZ(1, 2, 3)
        abc = ABC(1, 2, 3)
        ab = AB(#a)
        sum1 = Sum(1,2)
        sum2 = Sum(1, 2)
    in
        affirm:is_equal_to_map(xyz, {x=1, y=2, z=3})
        affirm:is_equal_to_map(abc, {a=1, b=2, c=3})
        affirm:is_equal_to_map(ab, {a=#ac, b=#b})
        affirm:is_equal_all(sum1.v, sum2.v, 3)

fun test() =
    test_simple()
    test_types()


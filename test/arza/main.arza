import io
import affirm
import seq
import list
//
//import tests:test_operators
//
//import tests:dispatch:test_dispatch
//import tests:stdtype:test_stdtype
//import tests:usertype:test_usertype
//import tests:test_expressions
//import tests:test_match
//import tests:test_exception
//import tests:test_static_refs
//import tests:test_operator_override
//import tests:test_import
//import tests:test_fun
//import tests:test_coro
//import tests:test_partial
//
//
//fun log(...msgs) =
//    if True then
//        io:print(...msgs)
//    else
//        ()
//
//
//fun test() =
//    log("TEST EXPRESSIONS")
//    test_expressions:test()
//    //
//    log("TEST STD TYPES")
//    test_stdtype:test()
//    //
//    log("TEST TYPES")
//    test_usertype:test()
////    //
//    log("TEST DISPATCH")
//    test_dispatch:test()
////    ////
//    log("TEST MATCH")
//    test_match:test()
//    //
//    log("TEST EXCEPTION")
//    test_exception:test()
//    //
//    log("TEST STATIC REFS")
//    test_static_refs:test()
//    //
//    log("TEST IMPORT")
//    test_import:test()
//
//    log ("TEST OP OVERRIDE")
//    test_operator_override:test()
//
//    log("TEST FUN")
//    test_fun:test()
//
//    log("TEST CORO")
//    test_coro:test()
//
//    log("TEST PARTIAL")
//    test_partial:test()
////
//    log("TEST OPERATORS")
//    test_operators:test()

//import tests:dispatch:space:space
type V2(x, y)

generic
    eq(f, s)
    something(f, val)

interface Thing(something.0)

trait EQ(T of Thing) =
    def eq(f of T, s) = f.x == s.x

def something(f, val of V2) = f.x + val
breakpoint(1)
derive Thing for V2


EQ(V2)
def eq(f of V2, s of V2) = f.x == s.x and f.y == s.y


fun main() =
    let
        v1 = V2(1, 2)
        v2 = V2(1, 3)
    in
        io:print(V2 `is_implemented` Thing)
        io:print(eq(v1, v2))

//    test()
//    space:test()

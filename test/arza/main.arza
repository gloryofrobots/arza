import io
import affirm
import seq
import list
//
import tests:test_operators

//import tests:dispatch:test_dispatch
//import tests:usertype:test_usertype
import tests:stdtype:test_stdtype
import tests:test_expressions
import tests:test_match
import tests:test_exception
import tests:test_static_refs
import tests:test_operator_override
import tests:test_import
import tests:test_fun
import tests:test_coro
import tests:test_partial
//
//
fun log(...msgs) =
    if True then
        io:print(...msgs)
    else
        ()


fun test() =
    log("TEST EXPRESSIONS")
    test_expressions:test()
    //
    log("TEST STD TYPES")
    test_stdtype:test()
    //
//    log("TEST TYPES")
//    test_usertype:test()
//    //
//    log("TEST DISPATCH")
//    test_dispatch:test()
//    ////
    log("TEST MATCH")
    test_match:test()
    //
    log("TEST EXCEPTION")
    test_exception:test()
    //
    log("TEST STATIC REFS")
    test_static_refs:test()
    //
    log("TEST IMPORT")
    test_import:test()

    log ("TEST OP OVERRIDE")
    test_operator_override:test()

    log("TEST FUN")
    test_fun:test()

    log("TEST CORO")
    test_coro:test()

    log("TEST PARTIAL")
    test_partial:test()
//
    log("TEST OPERATORS")
    test_operators:test()

//type V(val)
//
//generic
//    add(v1, v2)
//    sub(v1, v2)
//    val(v)
//    neg(v)
//
//interface Neg(neg.0)
//interface Add(add.0, add.1)
//interface Sub(sub.0, sub.1)
//interface Value(neg) is (Add, Sub)
//
//
//def add(v1 of V, v2 of V) = v1.val +  v2.val
//def sub(v1 of V, v2 of V) = v1.val - v2.val
//
//def neg(v of Sub) = -v.val
//def val(v of Sub) = v.val - 1000
//def val(v of Add) = v.val + 1000
//def val(v of Value) = v.val
//
////breakpoint(2)
//
//derive (Add, Sub, Neg) for V

fun main() =
//    let
//        v1 = V(1)
//        v2 = V(10)
//    in
//        io:print(V `is_implemented` Add)
//        io:print(V `is_implemented` Sub)
//        io:print(val(v1))
//        io:print(interfaces(v1))

    test()

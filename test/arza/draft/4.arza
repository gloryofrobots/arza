
var (x, y, z) = import("x.y.z")

func add3(x, y, z) {
    return x + y + z
}

type T {
    x = 1
    y = 2
    z = 3
    var(n, z, x)
    n = nil
    z = nil
    x = nil
}

type X:
    use T (a as n, b as t, c)
    use T (a as n) hiding (a, b, c)
    provide(t)
    provide(z)

    fun f(a, b, c) = a

    init(self, other) =
        self.x = x
        self.y = y

(fun trait_x(T1)
    (def T1.add3 func (x, y, z)
        return x + y + z
    )
)

fun trait_x(T1) {
    def T1.add3 func (x, y, z){
        return x + y + z
    }
}



protocol Eq(F, S) =
    ...PartialEq
    ==(F, S)
    !=(F, S)

type X = (a,b,c,d,e,f)

trait TRecord(T) =
    def index_of (val, self of T) as _datatype:record_index_of
    def keys(self of T) as _datatype:record_keys
    def values(self of T) as _datatype:record_values

    def put (k, v, self of T) as std_behavior:put
    def at (k, self of T) as std_behavior:at
    def del (el, self of T) as std_behavior:del
    def elem (el, self of T) as std_behavior:elem
    def len (self of T) as std_behavior:len
    def is_empty (self of T) as std_behavior:is_empty
    def cast(to_what, self of T) as std_behavior:cast


trait TSingletonEq(T1, T2) =
    def == (self of T, other) as std_behavior:equal
    def != (self of T, other) as  std_behavior:not_equal

    def str (self of T) as std_behavior:str
    def repr (self of T) as std_behavior:repr

trait TRe
trait T

instance T(X)

type Y()

trait T(T1, T2)
    extend (T1, T2)
        def ==(x, y) =
        def !=(x, y) =




def ==(x of Int, y of Float) =
    type1 = type(y)
    type2 = type(y)
    sym = Symmeric(type2)
    arg2[sym] = `==`
    type1[generic] = Symetric

def == (x of Int, y of Char)
    sym = Symmeric(arg)
    arg2[sym] = `==`
    Int[generic] = Symetric

class X(Z,T) =
    include Y
    import T
    fun add(x, y) = x + y
    let X = 1
    let Z = 2

    __init__(x, y) =
        self.x = x
        self.y = y

    __call__(x, y) =
        return self.x + x + self.y + y



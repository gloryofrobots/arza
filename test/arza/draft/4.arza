
var (x, y, z) = import("x.y.z")

func add3(x, y, z) {
    return x + y + z
}

type T {
    x = 1
    y = 2
    z = 3
    var(n, z, x)
    n = nil
    z = nil
    x = nil
}

type X:
    use T (a as n, b as t, c)
    use T (a as n) hiding (a, b, c)
    provide(t)
    provide(z)

    fun f(a, b, c) = a

    init(self, other) =
        self.x = x
        self.y = y

(fun trait_x(T1)
    (def T1.add3 func (x, y, z)
        return x + y + z
    )
)

fun trait_x(T1) {
    def T1.add3 func (x, y, z){
        return x + y + z
    }
}

protocol Eq(F, S) =
    PartialEq._
    PartialEq.(eq, ne, ge)
    Num.+
    ==(F, S)
    !=(F, S) = not F == S



type X (...A, a,b,c,d,e,f)
    init(self, B, C) =
        self.b = B
        self.c = C

    instance A
    instance Eq(_, B)
    def index_of (val, self of T) as _datatype:record_index_of
    def keys(self) as _datatype:record_keys
    def values(self) as _datatype:record_values




trait TRecord(T) =
    def index_of (val, self of T) as _datatype:record_index_of
    def keys(self) as _datatype:record_keys
    def values(self) as _datatype:record_values

    def put (k, v, self) as std_behavior:put
    def at (k, self) as std_behavior:at
    def del (el, self) as std_behavior:del
    def elem (el, self) as std_behavior:elem
    def len (self) as std_behavior:len
    def is_empty (self) as std_behavior:is_empty
    def cast(to_what, self) as std_behavior:cast


trait TEq(T1, T2) =
    def == (self, other) as std_behavior:equal
    def != (self, other) as  std_behavior:not_equal

trait TStr(T) =
    def str (self of T) as std_behavior:str
    def repr (self of T) as std_behavior:repr

trait TRe
trait T


type Error(args)
    behavior Instance

instance T(X)

type Y()

trait T(T1, T2)
    extend (T1, T2)
        def ==(x, y) =
        def !=(x, y) =





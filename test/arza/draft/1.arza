interface Map[K, V] as T =
    at(T, K) = V
    put(T, K, V) = ()

interface Num[T2, T3] as T1 =
    + (T1 T2) = T3
    - (T1, T2) = T3

module map =
    expect
        type K of Hashed
        type V

    import array as ArrayPair where T = Pair
    import std
    type Pair = (k of K, v of V)

    type __Map =
        data of ArrayPair

    trait (M, K, V) for (__Map, K, V) =
        def put(m of M, k of K, v of V) -> () = ...
        def at(m of M, k of K, v of V) -> V = ...
        describe M as Map



interface I[T1, T2] =
    f(I, T1, T2) = T2

interface I2[T1, T2] =
    f(T1, I2, T2) = T2


type Option[T]
    | None
    | Some =
        Result of T



interface C =
    f1(C, Map[Int, Int]) = Option[Int]


type MapInt as Map[Int, Int]
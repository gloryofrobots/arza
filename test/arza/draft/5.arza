//if you class  has self arg it is object else it is static

import T
extends T
class X(Z):
    include T (a as n, b as t, c)
    include (T) (a as n) hiding (a, b, c)

    // simple import
    import T
    extends T

    implements (A, B, C)

    //static
    fun f(a, b, c): a

    //object
    fun f2(self, a, b, c): a

    init(self, other):
        self.x = x
        self.y = y

    fun f3(self, t):
        //error self does not in constructor
        self.t = t

    fun f4(self, t):
        //works for static funcs
        f(t)

object = (
    indexOf:n next:n = (

Bag = Set subclass:
    indexOf: anObject =
        "This method is similiar to Set>>indexOf: except that return the position only of empty entries"
        size = self basicSize
        i = 2 * (anObject hash \\ size)
        n = tally + 2
        [ (n = n - 1) == 0 ] whileFalse:
            | key |
            i >= size
                ifTrue:
                     [i = 0]

            key = self basicAt: i + 1
            key isNil ifTrue: [ ^i + 1 ]

            i = i + 1

    printOn: aStream =
        | tooMany |
        tooMany = aStream position +
                  self maxPrint

        aStream
            print: self class
            nextPutAll: ' ('

        self do:
            :ea |
            aStream position > tooMany
                ifTrue:
                    aStream nextPutAll: '...etc...)'
                    ^ self
            ea == self
                ifTrue:
                    '...' printOn: aStream
                ifFalse:
                    ea printOn: aStream
            aStream space
        aStream nextPut: '$)'
!

Bag = Set subclass: (
    indexOf: anObject = (
        "This method is similiar to Set>>indexOf: except that return the position only of empty entries"
        size = self basicSize.
        i = 2 * (anObject hash \\ size).
        n = tally + 2.
        [ (n = n - 1) == 0 ]
        whileFalse: [
            | key |
            i >= size
                ifTrue: [ i = 0 ].
            key := self basicAt: i + 1.
            key isNil
                ifTrue: [ ^i + 1 ].
            i = i + 1
        ]
    )
)

Set subclass: Bag (
    indexOf: anObject (
        "This method is similiar to Set>>indexOf: except that return the position only of empty entries"
        | i n size |
        size := self basicSize.
        i := 2 * (anObject hash \\ size).
        n := tally + 2.
        { (n := n - 1) = 0 }
        whileFalse: {
            | key |
            i >= size
                ifTrue: { i := 0 }.
            key := self basicAt: i + 1.
            key isNil
                ifTrue: { ^i + 1 }.
            i := i + 1
        }
    )

    asSet (
        ^Set withAll: self
    )

    asBag (
        ^self
    )

    add: newObject withOccurrences: anInteger (
        "Add newObject to the receiver anInteger times"
        anInteger timesRepeat: [ self add: newObject ].
        ^newObject
    )
)


Set subclass: Bag [
    indexOf: anObject [
        "This method is similiar to Set>>indexOf: except that return the position only of empty entries"
        | i n size |
        size := self basicSize.
        i := 2 * (anObject hash \\ size).
        n := tally + 2.
        [ (n := n - 1) = 0 ]
        whileFalse: [
            | key |
            i >= size
                ifTrue: [ i := 0 ].
            key := self basicAt: i + 1.
            key isNil
                ifTrue: [ ^i + 1 ].
            i := i + 1 ]
    ]


    asSet [
        ^Set withAll: self
    ]

    asBag [
        ^self
    ]


    isSet [
        ^false
    ]

    isBag [
        ^true
    ]


    add: newObject withOccurrences: anInteger [
        "Add newObject to the receiver anInteger times"
        anInteger timesRepeat: [ self add: newObject ].
        ^newObject
    ]
]

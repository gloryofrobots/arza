{Bool, Char, Int, Float, Symbol, String, List, Vector,
       Tuple, Map, Function, Partial, Method,
       Fiber, Trait, Datatype, Union, LazyVal, Env} = import "obin:lang:types"


prefix :(- negate)
prefix :(! !)
prefix :(& &)
infixr :(:= := 10)
infixl :(<| <| 15)


////////////////////////////////////////////////////////////
///////////////// GENERICS /////////////////////////////////
////////////////////////////////////////////////////////////

defn Eq interface :(== !=)
defn Num interface (
     +, -, mod, negate, obin:lang:something
)

defn == generic `(x y)

defn == generic `(x y) (doc="i define if two entities are equal")

////////////////////////////////////////////////////////////
///////////////// TRAITS ///////////////////////////////////
////////////////////////////////////////////////////////////
defn TNotEq trait () [
    #!=, \x y -> not (x == y)
]

defn TOrd trait PartialEq {
    < =
      \ x y -> cmp x y == LT
    cmp =
        \ x y ->
                if x == y then EQ
                elif x <= y then LT
                else GT
}

////////////////////////////////////////////////////////////
///////////////// TYPES ////////////////////////////////////
////////////////////////////////////////////////////////////

defn Ordering type :(LT GT EQ)
defn Option type :(
     (Some val)
     None
)

defn ImportError type #args

////////////////////////////////////////////////////////////
///////////////// FUNCTIONS ////////////////////////////////
////////////////////////////////////////////////////////////
defn lookup fun default coll ->
    try
        at key coll
    catch
        | e of KeyError -> default
        | e -> throw e


//FUNS
fun lookup key default coll ->

fun not_elem x c -> not (elem x c)

fun identity x -> x

fun & func -> (obin:lang:defpartial func)

fun |> x f -> f x
fun <| f x -> f x
fun >> f g -> lam x -> g (f x)
fun << f g -> lam x -> f (g x)

fun twice f -> f >> f
fun flip f x y -> f y x
fun even x -> mod x 2 == 0
fun odd x -> not (even x)
fun inc x -> x + 1
fun dec x -> x - 1

fst = partial at 0
snd = partial at 1
thrd = partial at 2
frth = partial at 3
fun last coll -> at ((len coll) - 1) coll




fun t1() ->
    (affirm:is_equal (if x == 13 then 1 + 1
                      elif x == 14 then
                   2 + 2
                      elif x == 15 then
                           3 + 3
                      else -> 4 + 4) 8)

    (affirm:is_equal (if x == 13 then 1 + 1; 2 + 2
                      elif x == 14 then
                   2 + 2
                       3 + 4
                      elif x == 15 then
                           3 + 5
                      else => 4 + 4
                           13 + 343 -
                         345
                         end) 8)
    affirm:is_equal (
        (fun _  x y z
            | [hd::tl] (1,2,3) {x=2, y=3} -> 24
            | [hd::tl] (1,2,3) {x=2, y=3} =>
                       sqrt 24
                       sin 23
                       -2 + 4
            | _ y z -> 23)
         [[1,2]] (1,2,3) {x=2, y=3}) 24

    affirm:is_equal (
       fun _  x y z
            | [hd::tl] (1,2,3) {x=2, y=3} -> 24
            | [hd::tl] (1,2,3) {x=2, y=3} =>
                       sqrt 24
                       sin 23
                       -2 + 4
         end [[1,2]] (1,2,3) {x=2, y=3}) 24

    fun sum_list_3 list
        | [x,y,z] -> x + y + z

    (affirm:is_equal
        match (1, 2, 2) with
            | (A, x, A)  -> (#first, A)
            | (A, x, B)  -> (#second, A, B)
        end (#second, 1, 2))

    affirm:is_throw_expected(
        fun _ arg1 arg2 ->
            try
                1/0
            catch e ->
                throw (arg1, arg2)
            finally ->
                throw e
        end) (33, 22) (33, 22)


    (affirm:is_equal try
                        throw (1,2,"ERROR")
                     catch
                        | err @ (1, y, 3) -> #first
                        | (1,2, "ERROR@") -> #second
                        | err @ (1, 2, x) -> #third
                     finally ->
                        (#fourth, err, x)
                     end
                     (#fourth, (1, 2, "ERROR"), "ERROR"))

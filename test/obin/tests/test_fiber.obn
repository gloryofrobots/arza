from fiber import (coroutine, var)
import affirm
import io
import seq

fun test_simple () =
    let co =
        coroutine(
             (yield, x) ->
                let _co1 =
                    coroutine(
                         (yield2, y) ->
                            let
                                fun send() = yield2(42 + y)
                            in  send()
                    )
                in
                (
                   affirm:is_equal(x, 23)

                   let
                        x1 = yield(_co1(x))
                        x2 = yield(x1)
                   in
                   (
                       affirm:is_equal(x1, 34)
                       affirm:is_equal(x2, 44)
                       x2
                   )
                )
        )
    in
    (
        affirm:is_equal(co(23), 65)
        affirm:is_equal(co(34), 34)
        affirm:is_equal(co(44), 44)
    )

fun enum_from(num) =
    let co = coroutine(
        fun(yield, _from) =
            let
                fun _looper(num) =
                (
                   yield(num)
                   _looper(num + 1)
                )
            in
            (
                yield(_from)
                _looper(_from)
            )
        )
    in
    (
        co(num)
        co
    )

fun filter(predicate, coll) =
    coroutine(
        fun (yield) =
            let
                fun _filter
                    | (p, []) = empty(coll)
                    | (p, x::xs) =
                        if p(x) then
                        (
                            yield(x)
                            _filter(p, xs)
                        )
                        else _filter(p, xs)

             in _filter(predicate, coll)
    )

fun map2(fn, sq) =
    let
        fun _wrap_map (yield) =
            let fun _map
                | f, [] = empty(sq)
                | f, x::xs =
                (
                    yield(f(x))
                    _map(f, xs)
                )
            in _map(fn, sq)
    in coroutine(_wrap_map)

fun map(fn, sq) =
    coroutine(
        fun (yield) =
            seq:foreach(
                fun (x) = yield(fn(x)),
                sq
            )
    )

fun drop(count, sq) =
    coroutine(
        fun (yield) =
            let fun _drop
                    | _, [] =
                        empty(sq)
                    | 0, s =
                        seq:traverse(map(yield, s))
                    | n, x::xs =
                        _drop(n-1, xs)

            in _drop(count, sq)
    )

fun each(sq) =
    coroutine(
        fun (yield) =
            (fun | [] = empty(sq)
                 | s = seq:traverse(
                         map(yield, s)
                       )
            )(sq)

    )

fun test_seq () =
    let
        numbers = enum_from(10)
        ys =
            seq:take(10,
                map(x -> (x, str(x)),
                    drop(3,
                         filter(odd, numbers))))

         x1::x2::xs = numbers
    in
    (
        affirm:is_equal(
            ys,
            [(17, "17"), (19, "19"), (21, "21"), (23, "23"), (25, "25"), (27, "27"), (29, "29"), (31, "31"), (33, "33"), (35, "35")]
        )
        affirm:is_equal(x1, 36)
        affirm:is_equal(x2, 37)
    )

fun test_var() =
    let
        v = var(2)
    in
    (
        affirm:is_equal(!v, 2)
        affirm:is_equal(!v, 2)
        affirm:is_equal(!v, 2)
        v := 3
        affirm:is_equal(!v, 3)
        affirm:is_equal(!v, 3)
        affirm:is_equal(!v, 3)
    )

fun test () =
(
    test_simple()
    test_seq()
    test_var()
)
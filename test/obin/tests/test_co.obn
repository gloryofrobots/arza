from fiber import (coroutine)
import affirm
import io
import seq

fun test_simple () =
    let co =
        coroutine(
             (yield, x) ->
                let _co1 =
                    coroutine(
                         (yield2, y) ->
                            let
                                fun send() = yield2(42 + y)
                            in  send()
                    )
                in
                (
                   affirm:is_equal(x, 23)

                   let x1 = yield(_co1(x))
                   in affirm:is_equal(x1, 34)

                   let x2 = yield(x1)
                   in affirm:is_equal(x2, 44)

                   x2
                )
        )
    in
    (
        affirm:is_equal(co(23), 65)
        affirm:is_equal(co(34), 34)
        affirm:is_equal(co(44), 44)
    )

fun enum_from(num) =
    let co = coroutine(
        fun(yield, _from) =
            let
                fun _looper(num) =
                (
                   yield(num)
                   _looper(num + 1)
                )
            in
            (
                yield(_from)
                _looper(_from)
            )
        )
    in
    (
        co(num)
        co
    )

fun filter(predicate, coll) =
    coroutine(
        fun (yield) =
            let
                fun _filter
                    | (p, []) = empty(coll)
                    | (p, x::xs) =
                        if p(x) then
                        (
                            yield(x)
                            _filter(p, xs)
                        )
                        else _filter(p, xs)

             in _filter(predicate, coll)
    )

fun map2 fn sq =
    fun _wrap_map yield () =
        fun _map
            | f [] = empty sq
            | f x::xs =
                yield (f x)
                _map f xs
        _map fn sq
    coroutine _wrap_map

fun map(fn, sq) =
    coroutine(
        fun (yield) =
            seq:foreach(
                fun (x) = yield(fn(x)),
                sq
            )
    )

fun drop(count, sq) =
    coroutine(
        fun (yield) =
            let fun _drop
                    | _, [] =
                        empty(sq)
                    | 0, s =
                        seq:traverse(map(yield, s))
                    | n, x::xs =
                        _drop(n-1, xs)

            in _drop(count, sq)
    )

fun each(sq) =
    coroutine(
        fun (yield) =
            (fun | [] = empty sq
                 | s = seq:traverse (map yield s))(sq)

    )

fun test () =
    test_simple()
    // numbers = enum_from 10
    // ys =
    //    (seq:take 10
    //     (map (x => (x, str x))
    //          (drop 3
    //                (filter odd numbers))))
    // // ys = (seq:take 10
    // //       (each numbers))

    // io:print ys
    // x1::x2::xs = numbers
    // io:print x1 x2 ys
prefix (-, negate)
prefix (!, !)
prefix (&, &)
infixr (:=, :=, 10)
infixl (<|, <|, 15)
infixl (|>, |>, 20)
infixl (<<, <<, 25)
infixl (>>, >>, 25)
infixl (<, <, 35)
infixl (>, >, 35)
infixl (>=, >=, 35)
infixl (<=, <=, 35)
infixl (==, ==, 35)
infixl (!=, !=, 35)
infixl (++, ++, 40)
infixl (+, +, 40)
infixl (-, -, 40)
infixl (*, *, 50)
infixl (/, /, 50)
infixl (**, **, 55)

export (f_ab, f_ab_2, CONST)

import affirm

import tests:lib_az:abc:module_ab as ab
//
////unqualified names f_ab,f_ab_2,const
from tests:lib_az:abc:module_ab  import (f_ab, f_ab_2, CONST as const)
//
////ab2:f_ab
import tests:lib_az:abc:module_ab as ab2 (f_ab, f_ab_2)
//
////module_ab:f_ab, module_ab:f_ab_2
import tests:lib_az:abc:module_ab (f_ab, f_ab_2)
//
////all exported names imported
from tests:lib_az:efg:module_e import _

//ab_3_f_ab
from tests:lib_az:abc:module_ab import (f_ab as ab_3_f_ab)
//importing same names dont cause errors because names are equal
from tests:lib_az:abc:module_ab hide (CONST)
//ab5:f_ab_2 only
import tests:lib_az:abc:module_ab as ab5 hiding (f_ab, CONST)

fun add(x, y) =
    let
        z = sqrt(x)
        (n,b) = pow(z)
        x::xs = tail(n)
        [x, y, ...r] = n
        fun tail
            | [] = []
            | x::xs = xs
        y = map(fun (x) = (x, str(x)), [])
    in sin(z, n, x)

let y = map(fun x = (x, str(x)), [])

let {R @ x=1, y = z of Int, _ = 3} = {x = 1, y = 3, "2" = 5}

let (
    x = 1
    z = 2
    {R @ x=1, y = z of Int, _ = 3} = {x = 1, y = 3, "2" = 5}
    [1,2,3, ...rest] = [1,2,3,4,5,6,7]
    m = () -> 42
    m = (x) -> 42
    m = (x,y,z) -> 42
    m = x -> 42
    m = x,y,z -> 42
)
let m = () -> 42
let m = (x) -> 42
let m = (x,y,z) -> 42
let m = x -> 42
let m = x,y,z -> 42

let x = 1
let Z = (1,2,3,4)

let V = fun (x) = 1
type (
    Zero
    Vec2 (p1, p2)
    Car (speed, price, model, weight)
)

type Zero
type Vec2 (p1, p2)
type Car (speed, price, model, weight)

fun f () = (

    try
        error()
    catch e1 =
        e1
    finally
        error2(#Finally)

    try
        try
            error(#Catch)
        catch
            | err @ (1, y, 3) = #first
            | (1,2, "ERROR@") = #second
            | err @ (1, 2, x) = #third
        finally
            //uncatched
            throw (e2, e3)
    catch E = E
)
fun f () =
    match [1,2,3]
        | B1 @ [a, b, B2 @ c] when x == 1 = (B1, B2, a, b, c)
        | _ = 42

fun max_min x, y =
    if x > y then (
        (x, y)
        x > 1
    )
    elif x == y then (x, x)
    else (y, x)

fun all(p, l) =
    conjunction(map(p, l))

fun uncons ([x, ...xs]) = (x, xs)

fun map f, coll
    | f, [] = empty(coll)
    | (f, hd::tl) = f(hd) :: map(f, tl)

fun element(x, l) =
    any (fun (v) = v == x, l)



fun false () = False

fun tail
    | [] = []
    | x::xs = xs


fun main () =
    let
        fun tail
            | [] = []
            | x::xs = xs

        numbers = enum_from(10)
        ys = seq:take(10,
                    map(fun (x) = (x, str(x)),
                        drop(3,
                            filter(odd, numbers))))
    in (
        io:print(ys)
        io:print(x1, x2, ys)
    )
--------------------------------------------------

fun split (s)
    | [] = ([], [])
    | s@[x] = (s, [])
    | x::y::xs =
        let
            (l, r) = split(xs)
        in (x::l, y::r)
--------------------------------------------------
//
//
generic == (`x, y)
generic (
    == (`x, y)
    - (`x, y)
    + (`x, y)
    ! (self)
    len (self)
    put (key, value, `self)
)

interface Ord(<, <=, >, >=, cmp, max, min)
interface (
    PartialEq (==)
    Eq (!=, ==)
    Ord(<, <=, >, >=, cmp, max, min)
    Num (-, +, *, /, mod, negate)
    Pow(**)
    Str (str)
    Displayed (str, repr)
    Len (len)
)

trait TNotEq
    def != (x, y) = not (x == y)

trait TOrd of (PartialEq, TSeq) (
    def < (x, y) = cmp(x, y) == LT
    def >= (x, y) = cmp(x, y) != LT
)

trait TOrd of PartialEq (
    def < (x, y) = cmp(x, y) == LT
    def >= (x, y) = cmp(x, y) != LT
    def > (x, y) = cmp(x, y) == GT

    def cmp(x, y) =
                if x == y then EQ
                elif x <= y then LT
                else GT

)

extend List def first(self) = _list:head(self)

extend List
    use TXXX

extend List (
    use TListable (drop, take)
    use TNotEq
    use derive:TCollection

    def == (self, other) = seq:equal(self, other)

    def first(self) = _list:head(self)

    def slice(first, last, self) = _list:slice(first, last, self)
)


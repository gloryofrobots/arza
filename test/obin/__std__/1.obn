affirm:is_equal(add(v1, v2), Vec2(Point2(10, 12), Point2(14, 16)))

affirm:is_equal (add v1 v2) (Vec2 (Point2 10 12)  (Point2 14 16))

affirm:is_equal ~ add(v1, v2) ~ Vec2(Point2 ~ 10 ~ 12, Point2 ~ 14 ~ 16))

affirm:is_equal(
    add(v1, v2),
    Vec2(
        Point2(10, 12),
        Point2(14, 16)
   )
)

(affirm:is_equal
    (add v1 v2)
    (Vec2
        (Point2 10 12)
        (Point2 14 16)))


fun map(f, coll)
    | f, [] = empty(coll)
    | f, hd::tl = f(hd) :: map(f, tl)

fun map
    | f, [] = empty(coll)
    | f, hd::tl = f(hd) :: map(f, tl)

fun map
    case (f, []) = empty(coll)
    case (f, hd::tl) = f(hd) :: map(f, tl)

fun map
    | (f, []) = empty(coll)
    | (f, hd::tl) = f(hd) :: map(f, tl)

fun map (f, []) = empty(coll)
    map (f, hd::tl) = f(hd) :: map(f, tl)

map f [] = []
map f hd::tl = f hd :: map f tl


map f coll =
    let map =
        fun
            | f [] = empty coll
            | f hd::tl = f hd  :: map f tl) f coll


fun filter <predicate coll> =
    let fun _wrap <yield> =
        let fun _filter
            | p [] = empty coll
            | p x::xs =
            (:
                if p x then
                (:
                    yield x
                    (io.print
                        match x
                            | 0 = #null
                            | 1 = #one
                            | (a, b, c) = a + b + c)
                    _filter p xs
                :)
                else
                (:
                    io.print x
                    _filter p xs
                :)
            :)
        in _filter predicate coll
    in coroutine _wrap

fun filter(predicate, coll) =
    let _wrap(yield) =
        let _filter
            | p, [] = empty(coll)
            | p, x::xs =
                if p x then (
                    yield(x)
                    io.print(
                        match x
                            | 0 = #null
                            | 1 = #one
                            | (a, b, c) = a + b + c
                    )
                    _filter(p, xs)
                ) else (
                    io.print(x)
                    _filter(p, xs)
                )
        in _filter(predicate, coll)
    in coroutine(_wrap)

fun test_partial() =
(
    affirm:is_equal( &`-`(1)(2), (-1) )
    affirm:is_equal(`-`.(1)(2), (-1) )

    affirm:is_equal(
                &flip(`-`, 1)(2),
                1
    )

    affirm:is_equal(
                flip.(`-`, 1)(2),
                1
    )

    affirm:is_equal(
                (flip .. `-` .. 1)(2),
                1
    )

    let add1 = &add(1)
    in
    (
        affirm:is_equal(add1(2), 3)
        affirm:is_equal(add.(1)(2), 3)
    )
)

fun test_composition() =
    let
        add1_mul2 =  add(1) >>  mul(2)
        mul2_add1 = add(1) << mul(2)
        add_1_twice = twice(add .. 1)
    in
    (
        affirm:is_equal(add1_mul2(4), 10)
        affirm:is_equal(mul2_add1(4), 9)
        affirm:is_equal(add_1_twice(9), 11)
    )

fun test () =
(
    test_partial()
    test_composition()
//    test_pipe()
)

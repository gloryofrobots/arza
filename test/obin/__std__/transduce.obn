import io
from var import var

generic
    init `self
    result `self res
    step `self res input

interface Transformer (init, result, step)

type WrapTransformer fn

extend WrapTransformer
    def init self -> throw NotImplementedError #init
    def result self acc -> acc
    def step self input acc ->
//        io:print "WRAP" self.fn
        self.fn input acc

fun wrap f
    | f of Transformer -> f
    | f -> WrapTransformer f

type Reduced value

fun reduced x -> Reduced x

fun is_reduced val
    | val of Reduced -> True
    | _ -> False

fun ensure_reduced x
    | val of Reduced -> val
    | val -> Reduced val

fun deref r of Reduced -> r.value

fun unreduced x
    | r of Reduced -> deref r
    | r -> r

fun reduce_seq xf acc coll ->
    fun _reduce xf acc coll
        | xf acc [] ->
//            io:print "_REDUCE END"
            acc
        | xf acc hd::tl ->
//            io:print "_REDUCE STEP" xf
            acc1 = step xf hd acc
//            io:print "ACC1" acc1
            if is_reduced acc1 then
                deref acc1
            else
                _reduce xf acc1 tl
    res = _reduce xf acc coll
    result xf res

//
//Given a transducer, a builder function, an initial value
// and a iterable collection - returns the reduction.

fun transduce xf f init_val coll ->
    reduce reduce_seq xf f init_val coll

fun reduce reduce_fun xf f init_val coll ->
    fn = wrap f
    xf1 = xf fn
    reduce_fun xf1 init_val coll

fun into init_val xf coll ->
    f = match init_val with
            | x of Appendable -> append
            | x of Seq -> cons
            | x of Dict ->
                fun _ entry coll
                    | (key, val) coll -> put key val coll

    transduce xf f init_val coll


//  Convert a transducer transformer object into a function so
//  that it can be used with existing reduce implementation i.e. native,
//  xf = ts:map inc >> ts:filter even
//  xf_fn = ts:to_fun xf cons
//  affirm:is_equal (seq:foldl xf_fn [] [1,2,3,4]) [5, 3]

fun to_fun xf builder
   | xf builder of Transformer ->
      rxf = xf(builder)
      fun _ val acc -> step rxf val acc
   | xf builder -> to_fun xf (wrap builder)

fun first () ->
    wrap (val acc => reduced val)

type MapTransformer f xf

extend MapTransformer
    def init self -> init self.xf
    def result self acc -> result self.xf acc
    def step self val acc ->
        res = step self.xf (self.f val) acc
//        io:print "MAP STEP" res self.xf
        res

fun map f xf -> MapTransformer f xf

-------------------------------------------

type FilterTransformer predicate xf
extend FilterTransformer
    def init self -> init self.xf
    def result self acc -> result self.xf acc
    def step self val acc ->
//        io:print "FILTER STEP"
        if self.predicate val then
            step self.xf val acc
        else
            acc

fun filter predicate xf -> FilterTransformer predicate xf

// Similar to filter except the predicate is used to
// eliminate values.
fun remove predicate xf -> filter (not << predicate) xf

type CompletingTransformer (cf, xf)
extend CompletingTransformer
    def init self -> init self.xf
    def result self acc -> self.cf acc
    def step self val acc -> step self.xf val acc
//
///
// A completing transducer constructor. Useful to provide cleanup
// logic at the end of a reduction/transduction.
fun completing cf xf -> CompletingTransformer cf xf


type TakeTransformer n xf
extend TakeTransformer
    def init self -> init self.xf
    def result self acc -> result self.xf acc
    def step self val acc ->
        n = !self.n
        self.n := n - 1
        if n > 0 then
           step self.xf val acc
        else
           ensure_reduced acc

// A take transducer constructor. Will take n values before
// returning a reduced result.
fun take n xf -> TakeTransformer (var n) xf

type TakeWhileTransformer predicate xf
extend TakeWhileTransformer
    def init self -> init self.xf
    def result self acc -> result self.xf acc
    def step self val acc ->
        if self.predicate val then
           step self.xf val acc
        else
            //TAKE WHILE REDUCED acc
            ensure_reduced acc

// Like the take transducer except takes as long as the pred
// return true for inputs.
fun take_while p xf -> TakeWhileTransformer p xf

type TakeNthTransformer i n xf
extend TakeNthTransformer
    def init self -> init self.xf
    def result self acc -> result self.xf acc
    def step self val acc ->
        self.i := !self.i + 1
        if mod (!self.i) self.n == 0  then
           step self.xf val acc
        else
            acc

// A transducer that takes every Nth input
fun take_nth n xf -> TakeNthTransformer (var (-1)) n xf

type DropTransformer n xf
extend DropTransformer
    def init self -> init self.xf
    def result self acc -> result self.xf acc
    def step self val acc ->
        n = !self.n
        if n > 0 then
            self.n := n - 1
            acc
        else
           step self.xf val acc

// A dropping transducer constructor
fun drop n xf -> DropTransformer (var n) xf

type DropWhileTransformer continue_dropping predicate xf
extend DropWhileTransformer
    def init self -> init self.xf
    def result self acc -> result self.xf acc
    def step self val acc ->
        if !self.continue_dropping and self.predicate val then
            acc
        else
            self.continue_dropping := False
            step self.xf val acc

// A dropping transducer that drop inputs as long as
// pred is true.
fun drop_while predicate xf -> DropWhileTransformer (var True) predicate xf


//// Given a transformer returns a transformer which preserves
//// reduced by wrapping one more time. See cat.
//type PreserveReduced xf
//implement Transformer for PreserveReduced
//    def init self -> init self.xf
//    def result self acc -> acc
//    def step self val acc ->
//        ret = step self.xf val acc
//        if is_reduced ret then
//            reduced ret
//        else
//            ret
//
//fun preserve_reduced xf -> PreserveReduced xf
//
//type CatTransformer xf rxf
//implement Transformer for CatTransformer
//    def init self -> init self.xf
//    def result self acc -> result self.xf acc
//    def step self val acc ->
//        res = reduce_seq self.rxf val acc
//        res
//
//// Given a transformer return a concatenating transformer
//fun cat xf -> CatTransformer xf (preserve_reduced xf)
//
//// A mapping concatenating transformer
//fun mapcat f -> (map f) << cat

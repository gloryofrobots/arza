obj = {
    a = 1,
    b = 2,
    fun set_a_b self a b -> self.{a=a, b=b}
}


object Point
    fun New(self, a, b) ->
        delegate(self, {a=a, b=b})

    fun + (self, other)
        case(_, i of Int) -> Point:New(self.x+i, self.y+i)
        case(_, p of Point) -> Point:New(self.x + p.x, self.y + p.y)




p1 = Point.New(1, 2)
p2 = Point.New(2, 3)
p3 = p1 + p2

object Point
    fun New self a b ->
        delegate self {a=a, b=b}

    fun + self other ->
        | _ i of Int -> Point.New (self.x+i) (self.y+i)
        | _ p of Point -> Point.New (self.x + p.x) (self.y + p.y)



p1 = Point.New 1 2
p2 = Point.New 2 3
p3 = p1 + p2


type Point {a, b}

extend Point
    use Num
    def + self other
        | _ i of Int -> Point (self.x + i) (self.y + i)
        | _ p of Point -> Point (self.c + p.x) (self.y + p.y)

fun add_points p:Point p:Point



p1 = Point 2 3
p2 = Point 3 4
p1 + p2 + 42


import urllib2
import random
import json
import db

URL = "https://hola.org/challenges/word_classifier/testcase/%d"

random.seed()

fun get_random () -> random:randint 1 1984437529

conn = db.open_db ()

def fetch_db_bads conn ->
    c = conn.cursor()
    r = c.execute("SELECT word from bad_words")
    seq:map (record => str record) r



def fetch():
    code = get_random()
    response = urllib2.urlopen(URL % code)
    html = response.read()
    return json.loads(html)

fun process count ->
    conn = db:open_db ()
    c = conn.cursor ()
    fun recuder count bads
        | 0 BADS -> BADS
        | count BADS when count > 0 ->
            test = fetch()
            [skip, bads] = 
                seq:foldl.(
                    fun _ pair acc
                        | (word, result) [skip, bads] ->
                            if result or word `elem` bads then
                                acc
                            else 
                                c.execute('INSERT into bad_words (word) VALUES  ("%s")' % word)
                                [skip + 1, pair :: bads]

                    end, [0, BADS], test)

            conn.commit ()
            io:print "COUNT" count skip
            bads

    seq:foldl reducer (fetch conn) (range_by count 0 (-1)) 


    
fun process(count) ->
    conn = db.open_db ()
    c = conn.cursor()
    seq:foldl(
        fun (count, BADS) 
            case(0, BADS) -> BADS
            case(count, BADS) when count > 0 ->
                test = fetch()
                [skip, bads] = 
                    seq.foldl(
                        fun (pair, acc)
                            as ((word, result), [skip, bads]) ->
                                if result or word in bads then
                                    acc
                                else 
                                    c.execute('INSERT into bad_words (word) VALUES  ("%s")' % word)
                                    [skip + 1, pair :: bads]

                        end, [0, BADS], test)

                conn.commit()
                io:print("COUNT", count, skip)
                bads
        end,
        range_by(count, 0, -1)
    )


qlef process(count, input_data):
    
    while count > 0:
        skip = 0
        test = fetch()
        for word, result in test.items():
            if result:
                continue

            if word in BADS:
                skip += 1
                continue

            c.execute('INSERT into bad_words (word) VALUES ("%s")' % word)
            BADS[word] = word

        conn.commit()
        count -= 1
        print "COUNT", count, skip


type Point2 {x, y}
type Point3 {Point2, z}

Point2 = Any.{x, y}
Point3 = Point2.{ z }
Point4Draws = Point3.{w, ...Draws}

interface PointInterface 
    def draw p canvas
    use +
    use Numerical.-

def Point2.add(self, other) 
    case (_, i of Int) ->
        Point2.{x + i, y + i}
    case (_, p of Point2) ->
        Point2.{x + p.x, y + p.y}


def Point2.add self other 
    | _ i of Int ->
        Point2.{x + i, y + i}
    | _ p of Point2 ->
        Point2.{x + p.x, y + p.y}

object Point2(Base, )
    


extend LazyList
    with Collection = TypeDerived
    with Seq
        def first self -> self.head
        def rest self -> !self.tail
    with Str
        def str self
            | [] -> "[]"
            | self ->
                fun folder l
                    | [] -> ""
                    | l ->
                        //can't do pattern matching because rest method force lazy value to evaluate
                        x = l.head
                        xs = l.tail

                        if kindof xs LazyVal then
                            if  not (is_forced xs) then
                                ", ..."
                            else
                                ", " ++ str x ++ folder (!xs)
                        else
                            ", " ++ str x ++ folder (xs)


                "[" ++ (str self.head) ++ folder !self.tail ++ "]"
    with Seqable
        def to_seq self -> self
    with Sized
        def len self -> throw NotImplementedError ("len not defined for LazyList",)
        def is_empty self
            | self of LazyNil -> True
            | _ -> False

    with Emptiable
        def empty self -> LazyNil
    with Consable
        def cons value self -> LazyCons value self
    with Ref
        def ! self -> self
    with Eq
        def == self other -> seq:equal self other

--------------------------------------------------------------------------

extend LazyList
    use TypeDerived as Collection
    satisfy Seq
        def first self -> self.head
        def res self -> !self.tail
    with Str
        def str self
            | [] -> "[]"
            | self ->
                fun folder l
                    | [] -> ""
                    | l ->
                        //can't do pattern matching because rest method force lazy value to evaluate
                        x = l.head
                        xs = l.tail

                        if kindof xs LazyVal then
                            if  not (is_forced xs) then
                                ", ..."
                            else
                                ", " ++ str x ++ folder (!xs)
                        else
                            ", " ++ str x ++ folder (xs)


                "[" ++ (str self.head) ++ folder !self.tail ++ "]"
    with Seqable
        def to_seq self -> self
    with Sized
        def len self -> throw NotImplementedError ("len not defined for LazyList",)
        def is_empty self
            | self of LazyNil -> True
            | _ -> False

    with Emptiable
        def empty self -> LazyNil
    with Consable
        def cons value self -> LazyCons value self
    with Ref
        def ! self -> self
    with Eq
        def == self other -> seq:equal self other

--------------------------------------------------------------------------
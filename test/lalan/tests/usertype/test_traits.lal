import affirm
import io

type
(
    EQ
    GT
    LT
    Val(v)
    Val2(v)
)

protocol Ordered (
    eq(`x, y)
    ne(`x, y)
    le(`x, y)
    lt(`x, y)
    ge(`x, y)
    gt(`x, y)
    cmp(`x, y)
    max(`x, y)
    min(`x, y)
)

trait Equal
(
    def eq(x, y) = not ne(x, y)
    def ne(x, y) = not eq(x, y)
)
trait Order
(
    def le(x, y) = cmp(x, y) != GT
    def lt(x, y) = cmp(x, y) == LT
    def ge(x, y) = cmp(x, y) != LT
    def gt(x, y) = cmp(x, y) == GT


    def cmp(x, y) =
        if eq(x, x) then EQ
        elif le(x, y) then LT
        else GT

    def max(x, y) =
        if x `le` y then y
        else  y

    def min(x, y) =
        if x `le` y then x
        else  y
)


extend Val
(
    use Equal
    def eq(v1, v2) = v1.v == v2.v
)

extend Val2
(
    use Equal
    def ne(v1, v2) = v1.v != v2.v
)

extend Val
(
   use Order
   def cmp(self, other) =
        if self.v == other.v then EQ
        elif self.v <= other.v then LT
        else GT
)
extend Val2
(
    use Order
    def le(self, other) = self.v <= other.v
)

fun test () =
    let
        v1_1 = Val(1)
        v1_2 = Val(1)
        v1_3 = Val(2)

        v2_1 = Val2(1)
        v2_2 = Val2(1)
        v2_3 = Val2(2)
    in
    (
        affirm:is_true(eq(v1_1, v1_2))
        affirm:is_false(ne(v1_1, v1_2))
        affirm:is_false(eq(v1_3, v1_2))
        affirm:is_false(eq(v1_2, v1_3))

        affirm:is_true(eq(v2_1, v2_2))
        affirm:is_false(ne(v2_1, v2_2))
        affirm:is_false(eq(v2_3, v2_2))
        affirm:is_false(eq(v2_2, v2_3))

        affirm:is_true(eq(v1_1, v2_2))
        affirm:is_false(ne(v2_1, v1_2))
        affirm:is_false(eq(v1_3, v2_2))
        affirm:is_false(eq(v1_2, v2_3))

        affirm:is_false(lt(v1_3, v1_3))
        affirm:is_true(le(v1_3, v1_3))
        affirm:is_false(gt(v1_3, v1_3))
        affirm:is_true(ge(v1_3, v1_3))

        affirm:is_false(lt(v2_3, v2_3))
        affirm:is_true(le(v2_3, v2_3))
        affirm:is_false(gt(v2_3, v2_3))
        affirm:is_true(ge(v2_3, v2_3))
    )
import io
import affirm
import string

protocol PairProtocol (
    all(pair)
)

protocol PairIntProtocol (
    sum(`p1, p2)
)

type Pair (
    first
    second
)

trait PairRepr of PairProtocol (
    def repr(p) = all(p)
)

extend Pair (
    def ==
        | (self, other of Pair) = self.first  == other.first and self.second == other.second
        | (self, (first, second)) = self.first  == first and self.second == second

    def str(p) = string:join(["<Pair ", str(p.first), ", ", str(p.second), ">"], "")
    def all(p) = p.first ++ p.second
    def repr(p) = str(p)
)

type PairInt (
    use Pair
)

extend PairInt (
    use Pair
    use PairRepr
    def all(p) = p.first + p.second
    def sum(p1, p2) = PairInt(p1.first + p2.first, p1.second + p2.second)
)


extend PairInt (
    // manual override
    let sum = override(
        sum,
        PairInt,
        fun (super) =
             fun | (p1, val of Int) = PairInt(p1.first + val, p1.second + val)
                 | (p1, p2) = super(p1, p2)
    )
)

extend Int (
    // override syntax
    def+ +
         | (val of Int, p of PairInt) = PairInt(p.first + val, p.second + val)
         | (val1, val2) = super(val1, val2)
)

fun test() =
(
    let
        p1 = Pair("__first__", "__second__")
        p2 = PairInt(1, 2)
        p3 = PairInt(10, 20)
    in (
        p1 |> str |> affirm:is_equal(_, "<Pair __first__, __second__>")
        p2 |> str |> affirm:is_equal(_, "<Pair 1, 2>")
        p1 |> repr |> affirm:is_equal(_, "<Pair __first__, __second__>")
        p2 |> repr |> affirm:is_equal(_, 3)
        p1 |> all |> affirm:is_equal(_, "__first____second__")
        p2 |> all |> affirm:is_equal(_, 3)

        p2 |> sum(_, p3) |> affirm:is_equal(_, Pair(11, 22))
        p2 |> sum(_, 30) |> affirm:is_equal(_, Pair(31, 32))

        p2 |> `+`(40, _) |> affirm:is_equal(_, Pair(41, 42))
        // Check if Int working after subtype
        affirm:is_equal(1 + 3, 4)
    )
)

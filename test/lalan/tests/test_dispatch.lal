import io
import affirm
import generics

generic f2(`x, `y)

def f2 [Int, Float] (x, y) = #int_float
def f2 [Int, Int] (x, y) = #int_int
def f2 [Float, Int] (x, y) = #float_int
def f2 [Float, Float] (x, y) = #float_float
def f2 [Int, Seq](x, y) = #int_seq
def f2 [Indexed, Seq](x, y) = #indexed_seq
def f2 [Any, Any](x, y) = #any_any
def f2 [Any, Seq](x, y) = #any_seq
def f2 [Int, Any](x, y) = #int_any

fun test_binary () =
(
        affirm:is_equal(f2(1, 0.1), #int_float)
        affirm:is_equal(f2(0.2, 0.1), #float_float)
        affirm:is_equal(f2(0.654, 1), #float_int)
        affirm:is_equal(f2(1, 1), #int_int)

        affirm:is_equal(f2((), []), #indexed_seq)
        affirm:is_equal(f2(0, []), #int_seq)

        affirm:is_equal(f2({}, {}), #any_any)
        affirm:is_equal(f2(f2, Any), #any_any)
        affirm:is_equal(f2({}, []), #any_seq)
        affirm:is_equal(f2(42, #any), #int_any)
)

/////////////////////////////////////////////

generic f1(`x, y, z)

def f1 [Any] (x, y, z) = #any
def f1 [Int] (x, y, z) = #int
def f1 [Seq] (x, y, z) = #seq

fun test_unary () =
(
    affirm:is_equal(f1(0, {}, Tuple), #int)
    affirm:is_equal(f1(1 :: 2 :: 3 :: [], 42, ()), #seq)
    affirm:is_equal(f1({}, 42, ()), #any)
)

////////////////////////////////////////////////////

generic f6 (x,`y, `z, a, b, `c)

def f6 [Int, Float, String] (x, y, z, a, b, c) = #int_float_string
def f6 [Any, Any, String] (x, y, z, a, b, c) = #any_any_string
def f6 [String, Any, String] (x, y, z, a, b, c) = #string_any_string


fun test_triple() =
(
    affirm:is_equal(f6([], 0, 0.1, [], [], "string"), #int_float_string)
    affirm:is_equal(f6([], "string1", 0.1, [], [], "string1"), #string_any_string)
    affirm:is_equal(f6([], [], 0.1, [], [], "string1"), #any_any_string)
)

////////////////////////////////////////////////////////

type
(
    Pig(weight, coolness)
    Elephant(weight, shyness)
    PiggyElly(weight, coolshness)
)

generic
(
    made (`s1, `s2)
    give_birth(`mother, `father)
    regret_things(person)
)

interface
(
    FirstMade(made.0)
    SecondMade(made.1)
    Mother(give_birth.0)
    Father(give_birth.1)
    WisePerson(regret_things)
)

import std
// TODO at(#weight, self as Instance)
// or previous_method(#weight, self as Instance)
def at [Pig]
    | (#weight, self) = (#this_is_not_my_real_weight, std:Behavior.[at](#weight, self))
    | (key, self) = std:Behavior.[at](key, self)



def made [Pig, Elephant] (p, e) =
(
    if p.coolness - e.shyness > 0 then
        #Coooool
    else
        #Notcoolatall
)

def made [Elephant, Pig] as generics:reverse(made, Elephant, Pig)

def give_birth [Pig, Elephant] (p, e) = PiggyElly(p.weight.1 + e.weight, p.coolness + e.shyness)

def regret_things [Mother] (m) = True

fun test_pigs_and_elephants() =
(
    let
        p = Pig(100, 100)
        e = Elephant(1000, 90)
        pe = give_birth(p, e)
    in
    (
        affirm:is_equal(p.weight, (#this_is_not_my_real_weight, 100))
        affirm:is_equal(made(p, e), #Coooool)
        affirm:is_equal(made(e, p), #Coooool)
        affirm:is_equal(pe.weight, 1100)
        affirm:is_equal(pe.coolshness, 190)
        affirm:is_false(p `kindof` Father)
        affirm:is_true(p `kindof` Mother)

        //Checking interface late binding
        affirm:is_true(p `kindof` WisePerson)
    )
//    test()
)

/////////////////////////////////

fun test() =
(
    test_unary()
    test_binary()
    test_triple()
    test_pigs_and_elephants()
)

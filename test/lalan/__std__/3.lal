def
(
    at(key, self)
    at(key, self)
    put(key, value, self)
    del(obj, self)
    elem(key, self)

    cons(value, self)
    prepend(value, self)
    ++(self, other)
    append(value, self)
)

interface
(
    Collection(put.2, at.2, del.2, elem.2)
    ReadOnlyCollection(at.2, elem.2)

    Consable(cons.2)
    Consed(cons.1)
    ConsedAndConsable(cons.1, cons.2)

    Prependable(prepend.2)
    Appendable(append.2)
    Concatable(++.2)
)

extend
(
    cons(x:Int, l:List) =
    (
        io:print("int consed to list")
        cons(x:Any, l)
    )
    cons(x:Int, l:Prependable) =
    (
        io:print("int consed to Prependable")
        cons(x:Any, l)
    )
    append(x:Int, l:List) = append(x:Any, l)
)
type
(
    EQ
    GT
    LT
    Val(v)
    Val2(v)
)

def
(
    eq(`x, y)
    ne(x, y) = not eq(x, y)
    ne(True, False) = True
    ne(False, False) = False
    ne(x:Int, y:Bool) = if x == 0 then True else False
    ne(x:Bool, y:Int) is flip .. ne

    le(`x, y)
    lt(`x, y)
    ge(`x, y)
    gt(`x, y)
    cmp(`x, y)
    max(`x, y)
    min(`x, y)
)

trait Equal(X, Y)
(
    def eq(x:X, y:Y) = not ne(x, y)
    // types auto inserted
    def ne(x, y) = not eq(x, y)
)

trait Order(x, y) with
(
    def le(x, y) = cmp(x, y) != GT
    def lt(x, y) = cmp(x, y) == LT
    def ge(x, y) = cmp(x, y) != LT
    def gt(x, y) = cmp(x, y) == GT


    def cmp(x, y) =
        if eq(x, x) then EQ
        elif le(x, y) then LT
        else GT

    def max(x, y) =
        if x `le` y then y
        else  y

    def min(x, y) =
        if x `le` y then x
        else  y
)

extend (Val, Val)
(
    use Equal
    def eq(v1, v2) = v1.v == v2.v
)

extend (Val2, Val2)
(
    use Equal
    def eq(v1, v2) = v1.v == v2.v
)

use Equal for (Val2, Val2) with
    def ne(v1, v2) = v1.v != v2.v

use (le, ne) from Order for (Val, Val) with
(
    def max(x, y) =
        if x.v <= y.v then y
        else  y

   def cmp(x, y) =
        if self.v == other.v then EQ
        elif self.v <= other.v then LT
        else GT
)

use Order for (Val2, Val2) with
    def le(self, other) = self.v <= other.v


type X(Seq, Seqable)

type Y(Seqable, Seq)

def f(x:X, y:Y)
def f(x:Seq, y:Seq)
def f(x:Seqable, y:Seq)

import derive
import lalan:lang:_number
import io

trait TNum (
    let - = _number:sub
    let + = _number:add
    let * = _number:mul
    let / = _number:div
    let mod = _number:mod
    let negate = _number:negate
    let ** =  _number:pow
)

extend Int (
    use derive:TStr
    use derive:TRepr
    use derive:TEq
    use TNum
    use TOrd

    let <= = _number:le

//    def range(first, last of Int) ->
//        range_by(first, last, 1)
//
//    def range_by(first, last of Int, step of Int) ->
//        cmp =
//            if step > 0 then `>=`
//            elif step < 0 then `<=`
//            else throw ValueError ("Step can not be zero")
//
//        fun _progression _compare x last step  ->
//            if _compare x last then
//                []
//            else
//                x ::: _progression _compare (x + step) last step
//
//
//        _progression cmp first last step
//
//    def range_from first  -> range_from_by first 1
//
//    def range_from_by first (step of Int) ->
//        fun _progression x step ->
//            x ::: _progression (x + step) step
//
//        _progression first step
)
---------------------------------------------

extend Float (
    use derive:TStr
    use derive:TRepr
    use derive:TEq
    use TNum
    use TOrd
    let <= =  _number:le
)


////////////////////////////////////////
extend
    Int
    Float
with
(
    def {!=, ==} = StdBehavior
//    def != = TEq.[!=]
//    def == = TEq.[==]
    def - = _number:sub
    def + = _number:add
    def * = _number:mul
    def / = _number:div
    def mod = _number:mod
    def negate = _number:negate
    def ** =  _number:pow
    def <= =  _number:le
    def == = ==.[Rational]
    def + = +.[Rational, Double]
)

use TEq TStr TRepr for Int
use TEq TStr TRepr for Float

StdBehavior =
{
    [!=] = (x of T, y) -> not (x == y),
    [==] = (self of T, other) -> _api:equal(other, self),
    [str] = (self) -> _api:to_string(self)
}

defmap StdBehavior =
(
    def != (x of T, y) = not (x == y)
    def ==  (self of T, other) = _api:equal(other, self)
    def str (self) = _api:to_string(self)
)


trait TEq [T]
(
    def != (x of T, y) = not (x == y)
    def == (self of T, other) = _api:equal(other, self)
    def str [T] (self) = _api:to_string(self)
)

trait TStr [T]
(
    def str [T] (self) = _api:to_string(self)
)

trait TRepr
(
    def repr [T] (self) = _api:to_repr(self)
)



def <= [Int] =

trait TNum (
)

extend Int (
    use derive:TStr
    use derive:TRepr
    use derive:TEq
    use TNum
    use TOrd

    let <= = _number:le
)
---------------------------------------------

extend Float (
    use derive:TStr
    use derive:TRepr
    use derive:TEq
    use TNum
    use TOrd
)

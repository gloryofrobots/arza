affirm:is_equal(add(v1, v2), Vec2(Point2(10, 12), Point2(14, 16)))

affirm:is_equal (add v1 v2) (Vec2 (Point2 10 12)  (Point2 14 16))

affirm:is_equal ~ add(v1, v2) ~ Vec2(Point2 ~ 10 ~ 12, Point2 ~ 14 ~ 16))

affirm:is_equal(
    add(v1, v2),
    Vec2(
        Point2(10, 12),
        Point2(14, 16)
   )
)

(affirm:is_equal
    (add v1 v2)
    (Vec2
        (Point2 10 12)
        (Point2 14 16)))


fun map(f, coll)
    | f, [] = empty(coll)
    | f, hd::tl = f(hd) :: map(f, tl)

fun map
    | f, [] = empty(coll)
    | f, hd::tl = f(hd) :: map(f, tl)

fun map
    case (f, []) = empty(coll)
    case (f, hd::tl) = f(hd) :: map(f, tl)

fun map
    | (f, []) = empty(coll)
    | (f, hd::tl) = f(hd) :: map(f, tl)

fun map (f, []) = empty(coll)
    map (f, hd::tl) = f(hd) :: map(f, tl)

map f [] = []
map f hd::tl = f hd :: map f tl


map f coll =
    let map =
        fun
            | f [] = empty coll
            | f hd::tl = f hd  :: map f tl) f coll


fun filter <predicate coll> =
    let fun _wrap <yield> =
        let fun _filter
            | p [] = empty coll
            | p x::xs =
            (:
                if p x then
                (:
                    yield x
                    (io.print
                        match x
                            | 0 = #null
                            | 1 = #one
                            | (a, b, c) = a + b + c)
                    _filter p xs
                :)
                else
                (:
                    io.print x
                    _filter p xs
                :)
            :)
        in _filter predicate coll
    in coroutine _wrap

fun filter(predicate, coll) =
    let _wrap(yield) =
        let _filter
            | p, [] = empty(coll)
            | p, x::xs =
                if p x then (
                    yield(x)
                    io.print(
                        match x
                            | 0 = #null
                            | 1 = #one
                            | (a, b, c) = a + b + c
                    )
                    _filter(p, xs)
                ) else (
                    io.print(x)
                    _filter(p, xs)
                )
        in _filter(predicate, coll)
    in coroutine(_wrap)


fun var (v) =
    let co =
        coroutine(
            fun (yield, v) =
                let fun loop(v) =
                    let
                        msg = yield(v)
                    in
                        match msg
                            | #Read = loop(v)
                            | (#Write, new_val) =
                                loop(new_val)

                in loop(v)
        )

    in
    (
        co(v)
        Var(co)
    )

(fun var (v) =
    co = coroutine(
            (fun (yield, v) =
                (fun loop(v) =
                    msg = yield(v)
                    (match msg
                        | #Read = loop(v)
                        | (#Write, new_val) =
                            loop(new_val)
                    )
                )
            )
        )

    co(v)
    Var(co)
)

(fun loop(...a) =
        let (init_fn, args) = tuple:split(a)
        co = spawn(
            (fun (yield) =
                let fn = init_fn(
                    (fun (...args) =
                        apply(yield, args)
                        apply(fn,  args)
                    )
                )
                yield()
                apply(fn,  args)
            )
        )
   co()
   co
)

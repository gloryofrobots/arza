affirm:is_equal(add(v1, v2), Vec2(Point2(10, 12), Point2(14, 16)))


affirm:is_equal(
    (fun (x, y) =
        print(x, y)
        z = x + sqrt(x)
        transpose(x, y, sum((x,y,z)))
    ),
    Vec2(
        Point2(10, 12),
        Point2(14, 16)
   )
)

(fun filter(predicate, coll) =
    (fun _wrap(yield) =
        (fun _filter
            | (p, []) = empty(coll)
            | (p, x::xs) =
                (if p x then
                    yield(x)
                    io.print(
                        (match x
                            | 0 = #null
                            | 1 = #one
                            | (a, b, c) = a + b + c
                        )
                    )
                    _filter(p, xs)
                else
                    io.print(x)
                    _filter(p, xs)
                )
        )
        _filter(predicate, coll)
    )
    coroutine(_wrap)
)

//Nil
fun foldl
    | (f, acc, []) = acc
    | (f, acc, hd::tl) = foldl(f, f(hd, acc), tl)

(fun f() =
    fun t () = 1
    3
)

//Nil
(fun f () =
        //RP
        [
            //RS
            fun () = print(2) 42
        ]
        //RP
)

(fun var (v) =
    co = coroutine(
            (fun (yield, v) =
                (fun loop(v) =
                    msg = yield(v)
                    match msg
                        | #Read = loop(v)
                        | (#Write, new_val) =
                            loop(new_val)

                )
            )
        )

    co(v)
    Var(co)
)

(fun loop(...a) =
    let (init_fn, args) = tuple:split(a)
    let co = spawn(
        (fun (yield) =
            let fn = init_fn(
                (fun (...args) =
                    apply(yield, args)
                    apply(fn,  args)
                )
            )
            yield()
            apply(fn,  args)
        )
   )
   co()
   co
)

fun loop(...a) {
    (init_fn, args) = tuple:split(a)
    co = spawn(
        fun (yield) {
            fn = init_fn(
                fun (...args) {
                    apply(yield, args)
                    apply(fn,  args)
                }
            )
            yield()
            apply(fn,  args)
        }
   )
   co()
   co
}

(fun nbn_3 () =
    string:join(
        seq:map(
            (fun(n) =
                string:join_cast(
                   seq:map(
                        (fun (g) =
                                (fun _loop (n, g) =
                                    (if g == 1 or n < g then 1
                                    else
                                        seq:foldl(
                                            (fun (q, res) =
                                                res + 0 if q > n - g else _loop(n-g, q)
                                            ),
                                            1,
                                            range(2, g)
                                        )
                                    )
                                )
                                _loop(n, g)
                        ),
                        range(1, n),
                   ),
                   " "
                )
           ),
           range(1, 25),
        )
        "\n"
    )
)


(fun nbn_1 () =
    (fun _loop (n, g) =
        (if g == 1 or n < g then
           1
        else
            seq:foldl(
                (fun _folder(q, res) =
                    (if q > n - g then
                        x = 0
                    else
                        x = _loop(n-g, q)
                    )

                    res + x
                ),
                1,
                list:range(2, g)
            )
         )
    )
    string:join(
        seq:map(
            (fun(n) =
              string:join_cast(
                seq:map(
                    g -> _loop(n, g),
                    list:range(1, n)
                ),
                " "
              )
            ),
            list:range(1, 25)
        ),
        "\n"
    )
)

(fun test_pipe() =
    l = list:range(0, 10)
    affirm:is_equal (
        l |> seq:filter.(even),
        [0, 2, 4, 6, 8]
    )

    affirm:is_equal(
        l |> seq:filter .. even
          |> seq:map .. (`+` .. 1),
         [1, 3, 5, 7, 9]
    )

    affirm:is_equal (
        l |> seq:filter(even, _)
          |> seq:map.(`+` .. 1)
          |> seq:map.(flip .. `-` .. 2),
        [-1, 1, 3, 5, 7]
    )

    affirm:is_equal(
        l |> seq:filter .. (even)
          |> seq:map .. (`+` .. 1)
          |> seq:map .. (flip .. `-` .. 2),
        [-1, 1, 3, 5, 7]
    )

    affirm:is_equal(
        l |> seq:filter.(even)
          |> seq:map.(`+`.(1))
          |> seq:map.(flip.(`-`, 2)),
        [-1, 1, 3, 5, 7]
    )

    square = (x -> x * x)
    triple = `*` .. 3
    affirm:is_equal (
        l |> seq:filter.(even)
          |> seq:map.(`+` .. 1)
          |> seq:map.(flip .. `-` .. 2)
          |> seq:map.(triple >> square),
        [9, 9, 81, 225, 441]
    )

    affirm:is_equal (
         (seq:filter.(even)
             >> seq:map.(`+`.(1))
             >> seq:map.(flip.(`-`,2))
             >> seq:map.(triple >> square))(l),
         [9, 9, 81, 225, 441]
    )

    affirm:is_equal (
        l |> seq:filter.(even)
          >> &seq:map(`+` .. 1)
          >> seq:map.(flip.(`-`, 2))
          >> &seq:map(triple >> square),
        [9, 9, 81, 225, 441]
    )
)

Seq =
(object
    fun foldl
        | ([], acc, f) = acc
        | (hd::tl, acc, f) = foldl(tl, f(hd, acc), f)

    fun map(self, f)
        | ([], f) = empty(self)
        | (hd::tl, f) = f(hd) :: map(tl, f)

    (fun foreach(self, f)
        | ([], f) = empty(self)
        | (hd::tl, f) =

          f(hd)
          foreach(f, tl)
    )

    fun drop
        | (l, 0) = l
        | (hd::tl, count) = drop(tl, count - 1)

    fun take
        | (self @ _, 0) = empty(self)
        | (self @ [], _) = empty(self)
        | ([x, ...xs], n) = x :: take(n - 1, xs)

    fun filter
        | (self @ [], p) = empty(coll)
        | (x::xs, p) =
            if p(x) then
                x :: filter(p, xs)
            else
                filter(p, xs)
)
List.specify({
    rest =
})

List = {}

List . mutator ()
     .(became Seq)


List.mutator().became(Seq)


l . filter even . map (`+` .. 1) . map (flip .. `-` .. 2) . map (triple >> square)
l.filter(even).map(`+` .. 1).map(flip .. `-` .. 2).map(triple >> square)

m . f m . f1 m () . f1 (24 + 12) ()
m.f(m).f1(m, ()).f1(24 + 12, ())


l |> seq:filter.(even)
  |> seq:map.(`+` .. 1)
  |> seq:map.(flip .. `-` .. 2)
  |> seq:map.(triple >> square),










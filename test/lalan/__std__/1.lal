///////// IMPORTS ////////////////
//export (f_ab, f_ab_2, CONST)
//
//import affirm
//
//import tests:lib_az:abc:module_ab as ab
////
//////unqualified names f_ab,f_ab_2,const
//from tests:lib_az:abc:module_ab  import (f_ab, f_ab_2, CONST as const)
////
//////ab2:f_ab
//import tests:lib_az:abc:module_ab as ab2 (f_ab, f_ab_2)
////
//////module_ab:f_ab, module_ab:f_ab_2
//import tests:lib_az:abc:module_ab (f_ab, f_ab_2)
////
//////all exported names imported
//from tests:lib_az:efg:module_e import _
//
////ab_3_f_ab
//from tests:lib_az:abc:module_ab import (f_ab as ab_3_f_ab)
////importing same names dont cause errors because names are equal
//from tests:lib_az:abc:module_ab hide (CONST)
////ab5:f_ab_2 only
//import tests:lib_az:abc:module_ab as ab5 hiding (f_ab, CONST)
//////////////////////////////////////////////////////////
/////////////////////////////
//////////////////////////////////////////

infixr (:=, :=, 10)
infixl (<|, <|, 15)
infixl (|>, |>, 20)
infixl (<<, <<, 25)
infixl (>>, >>, 25)
infixl (<, <, 35)
infixl (>, >, 35)
infixl (>=, >=, 35)
infixl (<=, <=, 35)
infixl (==, ==, 35)
infixl (!=, !=, 35)
infixl (++, ++, 40)
infixl (+, +, 40)
infixl (-, -, 40)
infixl (*, *, 50)
infixl (/, /, 50)
prefix (-, negate, 55)
infixl (**, **, 60)
prefix (!, !, 70)
infixl (.., .., 95)
prefix (&, &, 96)


fun f () = 0
fun f (()) = ((()))
fun f4 ((),) = ((()))

fun f ((x,y) :: 4, 45) = 42
fun f (x::xs) = 42
fun f
    | x::xs = 42
    | [] = 24


fun f () =
(
let
    {a=[x,y,...z], B @ b="I am B", c of Float, D@d={e=(x,y,...zz)}} =
        {a=[1,2,3,4,5], b="I am B", c=3.14, d={e=(1,2,3,4,5)}}
in
    affirm:is_equal(
        (a, B, D, e, x, y, z, zz),
        ([1,2,3,4,5], "I am B", {e=(1,2,3,4,5)}, (1,2,3,4,5), 1, 2, [3,4,5], (3,4,5))
    )
)

let x = f4(())
let m = (fun
             | x = 2)(3)
let x =
    affirm:is_equal (
        (fun | ([hd::tl], (1,2,3), {x=2, y=3}) = 24
             | (_, y, z) = 23)(
                [[1,2]], (1,2,3), {x=2, y=3}),
        24
    )
fun f
    | ((x,y) :: 4, 45) = 42
    | (x,y) = 42

let f = seq:map(x -> x * x, l)
let g = seq:map((1,2,3), l)


extend Coroutine (
    use derive:TSized (is_empty, is_not_empty)
    def len(self) = throw NotImplementedError ("Coroutine can't define len")
)


extend String (
    def ++
        | (_str1 of String, sym of Symbol) = _string:concat(_str1, str(sym))
        | (_str1, _str2) = _string:concat(_str1, _str2)
)

fun reverse(coll) =
    let fun _reverse
            | ([], result) = result
            | (hd::tl, result) = _reverse(tl, hd :: result)

    in  _reverse(coll, empty(coll))


fun f () = (
        (x,y,z)
        (a,b,c)
    )

fun f () = (
        (x,y,z) (a,b,c)
    )

trait TNum (
    let - = _number:sub
    let + = _number:add
    let * = _number:mul
    let / = _number:div
    let mod = _number:mod
    let negate = _number:negate
    let ** =  _number:pow
)


fun f () =
    let
        v = m.x
        x = m.{x}
        y = m.{y=1, x=2}
        x = m.name.x()
        x = m.{name}.{x}
    in x + y


fun add(x, y) =
    let
        z = sqrt(x)
        (n,b) = pow(z)
        x::xs = tail(n)
        [x, y, ...r] = n
        fun tail
            | [] = []
            | x::xs = xs
        y = map(fun (x) = (x, str(x)), [])
    in sin(z, n, x)

let y = map(fun x = (x, str(x)), [])

let {R @ x=1, y = z of Int, _ = 3} = {x = 1, y = 3, "2" = 5}

let (
    x = 1
    z = 2
    {R @ x=1, y = z of Int, _ = 3} = {x = 1, y = 3, "2" = 5}
    [1,2,3, ...rest] = [1,2,3,4,5,6,7]
    m = () -> 42
    m = (x) -> 42
    m = (x,y,z) -> 42
    m = x -> 42
)

let m = () -> 42
let m = (x) -> 42
let m = (x,y,z) -> 42
let m = x -> 42

let x = 1
let Z = (1,2,3,4)

let V = fun (x) = 1
type (
    Zero
    Vec2 (p1, p2)
    Car (speed, price, model, weight)
)

type Zero
type Vec2 (p1, p2)
type Car (speed, price, model, weight)

fun f () = (

    try
        error()
    catch e1 =
        e1
    finally
        error2(#Finally)

    try
        try
            error(#Catch)
        catch
            | err @ (1, y, 3) = #first
            | (1,2, "ERROR@") = #second
            | err @ (1, 2, x) = #third
        finally
            //uncatched
            throw (e2, e3)
    catch E = E
)
fun f () =
    match [1,2,3]
        | B1 @ [a, b, B2 @ c] when x == 1 = (B1, B2, a, b, c)
        | _ = 42

fun max_min (x, y) =
    if x > y then (
        (x, y)
        x > 1
    )
    elif x == y then (x, x)
    else (y, x)

fun all(p, l) =
    conjunction(map(p, l))

fun uncons ([x, ...xs]) = (x, xs)

fun map (f, coll)
    | (f, []) = empty(coll)
    | (f, hd::tl) = f(hd) :: map(f, tl)

fun element(x, l) =
    any (fun (v) = v == x, l)



fun false () = False

fun tail
    | [] = []
    | x::xs = xs


fun main () =
    let
        fun tail
            | [] = []
            | x::xs = xs

        numbers = enum_from(10)
        ys = seq:take(10,
                    map(fun (x) = (x, str(x)),
                        drop(3,
                            filter(odd, numbers))))
    in (
        io:print(ys)
        io:print(x1, x2, ys)
    )
--------------------------------------------------

fun split (s)
    | [] = ([], [])
    | s@[x] = (s, [])
    | x::y::xs =
        let
            (l, r) = split(xs)
        in (x::l, y::r)
--------------------------------------------------
//
//
generic == (`x, y)
generic (
    // ERROR
    put k v s
    == (x, y)
    - (`x, y)
    + (`x, y)
    ! (self)
    len (self)
    put (key, value, `self)
)

interface Ord(<, <=, >, >=, cmp, max, min)
interface (
    PartialEq (==)
    Eq (!=, ==)
    Ord(<, <=, >, >=, cmp, max, min)
    Num (-, +, *, /, mod, negate)
    Pow(**)
    Str (str)
    Displayed (str, repr)
    Len (len)
)

trait TNotEq (
    def != (x, y) = not (x == y)
)

trait TOrd of (PartialEq, TSeq) (
    def < (x, y) = cmp(x, y) == LT
    def >= (x, y) = cmp(x, y) != LT
)

trait TOrd of PartialEq (
    def < (x, y) = cmp(x, y) == LT
    def >= (x, y) = cmp(x, y) != LT
    def > (x, y) = cmp(x, y) == GT

    def cmp(x, y) =
                if x == y then EQ
                elif x <= y then LT
                else GT

)


extend List (
    def first(self) = _list:head(self)
)

extend List (
    use TXXX
)

extend List (
    use TListable (drop, take)
    use TNotEq
    use derive:TCollection

    def == (self, other) = seq:equal(self, other)

    def first(self) = _list:head(self)

    def slice(first, last, self) = _list:slice(first, last, self)
)


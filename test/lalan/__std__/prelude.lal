from lalan:lang:_types import (Bool, Char, Int, Float, Symbol, String, List, Vector, Tuple, Map,
                             Function, Partial, Interface,
                             Generic, FiberChannel, Coroutine, Trait, Datatype, LazyVal, Env)

"""
SOME OF THE OPERATORS DEFINED INTERNALLY AND SOME BELOW
Precedence    Operator
    100           : . .{ .[
    95           x()
    60           :: :::
    55           **
    50           *  /
    40           +  - ++
    35           ==  !=  <  <=  >  >=
    30           and
    25           or << >>
    20           |>
    15           " ." @ as of <|
    10           = :=
"""

infixr (:=, :=, 10)
// infix @ as of -> 15
infixl (<|, <|, 15)
infixl (|>, |>, 20)
// infix or -> 25
infixl (<<, <<, 25)
infixl (>>, >>, 25)
// infix and -> 30
infixl (<, <, 35)
infixl (>, >, 35)
infixl (>=, >=, 35)
infixl (<=, <=, 35)
infixl (==, ==, 35)
infixl (!=, !=, 35)
infixl (++, ++, 40)
infixl (+, +, 40)
infixl (-, -, 40)
infixl (*, *, 50)
infixl (/, /, 50)
// use qualified name to prevent infinite loops in cases of declaring local negate function using prefix -
prefix (-, lalan:lang:negate, 55)
// infix :: -> 60
infixl (**, **, 60)
// prefix # -> 70
prefix (!, !, 70)
infixl (.., .., 90)
// infix (  .{ .[ -> 95
prefix (&, &, 96)
// infix . : -> 100
////////////////////////////////////////////////////////////
///////////////// TYPES ////////////////////////////////////
////////////////////////////////////////////////////////////
type LT
type GT
type EQ
type Some(val)
type None

// Various Errors
type ImportError(args)
type RuntimeError(args)
type TypeError(args)
type NotImplementedError(args)
type ZeroDivisionError(args)
type MathDomainError(args)
type ReferenceError(args)
type ConstructorError(args)
type KeyError(args)
type ValueError(args)
type SliceError(args)
type IndexError(args)
type InvokeError(args)
type InvalidArgCount(args)
type MethodInvokeError(args)
type MethodNotImplementedError(args)
type MethodSpecializeError(args)
type CompileError(args)
type ParseError(args)
type UnpackSequenceError(args)
type FiberFlowError(args)
type MatchError(args)
type FunctionArgumentsMatchError(args)
type ExceptionMatchError(args)
type ExportError(args)
type ImplementationError(args)
type ConstraintError(args)
type EmptySeqError(args)
type OverflowError(args)
//Signal used to interrupt recursive processes
type Interrupt(result)


////////////////////////////////////////////////////////////
///////////////// INTERFACES ///////////////////////////////
////////////////////////////////////////////////////////////

protocol PartialEq (
    ==(`x, y)
)
protocol Eq (
    use PartialEq
    !=(`x, y)
)

protocol Comparable (
    cmp(`first, second)
)

protocol LessEq (
    use PartialEq
    <=(`x, y)
)

protocol MaxMin (
    max(`first, second)
    min(`first, second)
)

protocol Ord (
    use LessEq(<=)
    use Comparable
    use MaxMin
    <(`x, y)
    >=(`x, y)
    >(`x, y)
)

protocol Num (
    -(`x, y)
    +(`x, y)
    *(`x, y)
    /(`x, y)
    mod(`x, y)
    // unary -
    negate(`x)
)

protocol Pow (
    **(`x, y)
)

protocol Str (
    str(`self)
)

protocol Displayed (
    use Str
    repr(`self)
)

protocol Len (
    len(`self)
)

protocol Sized (
    use Len
    is_empty(`self)
)

protocol Collection (
    at(key, `self)
    put(key, value, `self)
    del(obj, `self)
    elem(key, `self)
)

protocol ReadOnlyCollection (
    use Collection(at, elem)
)

protocol Dict (
    use Collection
    keys(self)
    values(self)
)

protocol Seq(
    first(`self)
    rest(`self)
)

protocol Emptiable (
    empty(`self)
)

protocol Consable (
    cons(value, `self)
)

protocol Prependable (
    prepend(value, `self)
)

protocol Appendable (
    append(value, `self)
)

protocol Concatable (
    ++(`self, other)
)

protocol Indexed (
    index_of(obj, `self)
)

protocol Seqable(
    to_seq(self)
)

protocol Sliceable (
    slice (first, last, `self)
    drop(count, `self)
    take(count, `self)
)

protocol Bounded (
    lower_bound(`self)
    upper_bound(`self)
)

protocol Ranged (
    range(`self, last)
    range_by (`self, last, step)
    range_from(`self)
    range_from_by(`self, step)
)

protocol Ref (
    !(self)
)

protocol MutRef (
    :=(`self, value)
)

////////////////////////////////////////////////////////////
///////////////// TRAITS ///////////////////////////////////
////////////////////////////////////////////////////////////


trait TNotEq (
    def !=(x, y) = not (x == y)
)


trait TOrd of PartialEq (
    def <(x, y) = cmp(x, y) == LT
    def >=(x, y) = cmp(x, y) != LT
    def >(x, y) = cmp(x, y) == GT

    def cmp(x, y) =
                if x == y then EQ
                elif x <= y then LT
                else GT

    def max(x, y) = if x <= y then y else x
    def min(x, y) = if x <= y then x else y
)

trait TIsEmpty of Len (
    def is_empty(self) = len(self) == 0
)

trait TRepr of Str (
    def repr(self) = str(self)
)

////////////////////////////////////////////////////////////
///////////////// FUNCTIONS ////////////////////////////////
////////////////////////////////////////////////////////////


fun lookup (key, default, coll) =
    try
        at(key, coll)
    catch
        | e of KeyError = default
        | e = throw e

fun not_elem(x, c) = not(elem (x, c))

fun identity(x) = x

fun & (func) = lalan:lang:defpartial(func)
fun .. (f, g) = lalan:lang:defpartial(f)(g)

fun |>(x, f) = f(x)
fun <|(f, x) = f(x)
fun >>(f, g) = x -> g(f(x))
fun <<(f, g) = x -> f(g(x))

fun twice(f) = f >> f
fun flip (f, x, y) = f(y, x)
fun even(x) = mod(x, 2) == 0
fun odd(x) = not(even(x))
fun inc(x) = x + 1
fun dec(x) = x - 1
//fun last coll = at ((len coll) - 1) coll
fun last(coll) = at(len(coll) - 1, coll)

let
(
    fst = c -> at(0, c)
    snd = c -> at(1, c)
    thrd = c -> at(2, c)
    frth = c -> at(3, c)
)

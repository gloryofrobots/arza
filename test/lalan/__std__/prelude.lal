from lalan:lang:_types import (Bool, Char, Int, Float, Symbol, String, List, Vector, Tuple, Map,
                             Function, Partial, Generic, FiberChannel, Coroutine, Trait, Interface, Datatype, Env)

from lalan:lang:_bit import (bitand, bitor, bitxor, bitnot, lshift, rshift)


"""
SOME OF THE OPERATORS DEFINED INTERNALLY AND SOME BELOW
Precedence    Operator
    100           : . .{ .[
    95           x()
    60           :: :::
    55           **
    50           *  /
    40           +  - ++
    35           ==  !=  <  <=  >  >=
    30           and
    25           or << >>
    20           |>
    15           " ." @ as of <|
    10           = :=
"""

infixr (:=, :=, 10)
// infix @ as of -> 15
infixl (<|, <|, 15)
infixl (|>, |>, 20)
// infix or -> 25
infixl (<<, <<, 25)
infixl (>>, >>, 25)
// infix and -> 30
infixl (<, <, 35)
infixl (>, >, 35)
infixl (>=, >=, 35)
infixl (<=, <=, 35)
infixl (==, ==, 35)
infixl (!=, !=, 35)
infixl (++, ++, 40)
infixl (+, +, 40)
infixl (-, -, 40)
infixl (*, *, 50)
infixl (/, /, 50)
// use qualified name to prevent infinite loops in cases of declaring local negate function using prefix -
prefix (-, lalan:lang:negate, 55)
// infix :: -> 60
infixl (**, **, 60)
// prefix # -> 70
prefix (!, !, 70)
infixl (.., .., 90)
// infix (  .{ .[ -> 95
prefix (&, &, 96)
// infix . : -> 100

////////////////////////////////////////////////////////////
///////////////// GENERICS /////////////////////////////////
////////////////////////////////////////////////////////////


generic
(
    ==(x, y)
    !=(x, y)
    <=(x, y)
    <(x, y)
    >=(x, y)
    >(x, y)

    cmp(first, second)

    max(first, second)
    min(first, second)

    -(x, y)
    +(x, y)
    *(x, y)
    /(x, y)
    mod(x, y)
    // unary -
    negate(x)
    **(x, y)

    str(self)
    repr(self)

    len(self)
    is_empty(self)

    at(key, self)
    put(key, value, self)
    del(obj, self)
    elem(key, self)

    first(self)
    rest(self)

    empty(self)
    cons(value, self)
    prepend(value, self)
    ++(self, other)
    append(value, self)
    keys(self)
    values(self)
    index_of(obj, self)
    to_seq(self)

    slice (first, last, self)
    drop(count, self)
    take(count, self)
    lower_bound(self)
    upper_bound(self)

    range(self, last)
    range_by (self, last, step)
    range_from(self)
    range_from_by(self, step)
    !(self)
    :=(self, value)
)

////////////////////////////////////////////////////////////
///////////////// INTERFACES ///////////////////////////////
////////////////////////////////////////////////////////////


interface
(
    PartialEq (==)
    Eq (!=, ==)
    Comparable(cmp)
    LessEq(<=, ==)
    Ord(<, <=, >, >=, cmp, max, min)

    Num (-, +, *, /, mod, negate)
    Pow(**)

    Str (str)
    Displayed (str, repr)

    Len (len)
    Sized (len, is_empty)
    Collection(put.2, at.1, del.1, elem.1)
    ReadOnlyCollection(at.1, elem.1)
    Seq(first, rest)
    Emptiable(empty)
    Consable(cons.1)
    Prependable(prepend.1)
    Appendable(append.1)
    Concatable(++.1)
    Dict(keys, values, put.2, at.1, del.1, elem.1)
    Indexed(index_of.1)
    Seqable(to_seq)
    Sliceable(slice.2, drop.1, take.1)
    Bounded(lower_bound, upper_bound)
    Ranged(range, range_by, range_from, range_from_by)
    Ref(!)
    MutRef(!, :=)
)

////////////////////////////////////////////////////////////
///////////////// TYPES ////////////////////////////////////
////////////////////////////////////////////////////////////
type
(
    LT
    GT
    EQ
    Some (val)
    None
)

// Various Errors
type
(
    ImportError(args)
    RuntimeError(args)
    TypeError(args)
    NotImplementedError(args)
    ZeroDivisionError(args)
    MathDomainError(args)
    ReferenceError(args)
    ConstructorError(args)
    KeyError(args)
    ValueError(args)
    SliceError(args)
    IndexError(args)
    InvokeError(args)
    InvalidArgCount(args)
    MethodInvokeError(args)
    MethodNotImplementedError(args)
    MethodSpecializeError(args)
    CompileError(args)
    ParseError(args)
    UnpackSequenceError(args)
    FiberFlowError(args)
    MatchError(args)
    FunctionArgumentsMatchError(args)
    ExceptionMatchError(args)
    ExportError(args)
    ImplementationError(args)
    ConstraintError(args)
    EmptySeqError(args)
    OverflowError(args)
    //Signal used to interrupt recursive processes
    Interrupt(result)
)


////////////////////////////////////////////////////////////
///////////////// FUNCTIONS ////////////////////////////////
////////////////////////////////////////////////////////////


fun lookup (key, default, coll) =
    try
        at(key, coll)
    catch
        | e of KeyError = default
        | e = throw e

fun not_elem(x, c) = not(elem (x, c))

fun identity(x) = x

fun & (func) = lalan:lang:defpartial(func)
fun .. (f, g) = lalan:lang:defpartial(f)(g)

fun |>(x, f) = f(x)
fun <|(f, x) = f(x)
fun >>(f, g) = x -> g(f(x))
fun <<(f, g) = x -> f(g(x))

fun twice(f) = f >> f
fun flip (f, x, y) = f(y, x)
fun even(x) = mod(x, 2) == 0
fun odd(x) = not(even(x))
fun inc(x) = x + 1
fun dec(x) = x - 1
//fun last coll = at ((len coll) - 1) coll
fun last(coll) = at(len(coll) - 1, coll)

let
(
    fst = c -> at(0, c)
    snd = c -> at(1, c)
    thrd = c -> at(2, c)
    frth = c -> at(3, c)
)

from lalan:lang:_coro import (spawn, is_complete, is_initialised,
                            is_terminated, is_active, is_passive,
                            is_finished)
import derive
import tuple
import io
import seq

//////////////////////////////////////


extend Coroutine
(
    use derive:TSized (is_empty)
    def len(self) = throw NotImplementedError ("Coroutine can't define len")

    def first(self) =
    (
        if not is_empty(self) then
        (
            let v = self()
            in
            (
                io:print(#first, self, v)
                v
            )
        )
        else
        (
            throw "Coroutine is closed on first"
        )

    )
    def rest(self) =
    (
        if not is_empty(self) then
            self
        else
            []
    )
    def to_seq(self) = self
    def empty(self) = []
)

// REFS
type Ref(val)

fun ref(v) =
    let co =
       spawn(
            fun (yield, v) =
                let fun loop(v) =
                    let
                        msg = yield(v)
                    in
                        match msg
                            | #Read = loop(v)
                            | (#Write, new_val) =
                                loop(new_val)

                in loop(v)
        )
    in
    (
        co(v)
        Ref(co)
    )

extend Ref
(
    use TRepr

    def !(self) = self.val(#Read)

    def :=(self, value) = self.val((#Write, value))

    def ==(self, other) = self.val == other.val

    def str(self) = "Var"
)

///////////////////////////////////////////////////////

// helper for creating looping generators
// example
// Infinite increment
//fun enum_from(num) =
//    coro:loop(
//        //first function remembers looper
//        (looper) ->
//             //second function sends data to looper each iteration
//             num -> looper(num + 1)
//        ,
//        num - 1
//    )
// instead of yield it gets looper function which do actual yielding back to receiver
// WARNING expects function as first argument which returns actual worker
// TASK of first function is to remember looper in its scope, so worker can access it

// common code
fun _loop(yield_argument, init_fn, args) =
    let
        co = spawn(
            fun (yield) =
                let
                    fn = init_fn(
                        fun (...args) =
                        (
                            io:print(#_loop1, args)
                            apply(yield, yield_argument(args))
                            apply(fn,  args)
                        )
                    )
                in
                (
                    yield()
                    io:print(#_loop, args)
                    apply(fn, args)
                )
        )
    in
    (
       co()
       co
    )

fun loop(...a) =
    let
        (init_fn, args) = tuple:split(a)
    in _loop(identity, init_fn, args)

// the same but with reduce interface
// useful when there are no need to yielding all looper arguments

fun loop_reduce(init_fn, x, acc) =
    _loop(fst >> tuple:ensure_tuple, init_fn, (x, acc))

////////////////////////////////////////////////////
// SEQUENCES
////////////////////////////////////////////////////

let
(
    take = seq:take
    take_while = seq:take_while
    nth = seq:nth
)

fun filter(predicate, coll) =
    spawn(
        fun (yield) =
            let
                fun _filter
                    | (p, []) = empty(coll)
                    | (p, x::xs) =
                        if p(x) then
                        (
                            yield(x)
                            _filter(p, xs)
                        )
                        else _filter(p, xs)

             in _filter(predicate, coll)
    )


fun map(fn, co) =
    spawn(
        fun (yield) =
            seq:foreach(
                fun (x) = yield(fn(x)),
                co
            )
    )


fun drop(count, co) =
    spawn(
        fun (yield) =
            let fun _drop
                    | (_, []) =
                        empty(co)
                    | (0, s) =
                        seq:traverse(map(yield, s))
                    | (n, x::xs) =
                        _drop(n-1, xs)

            in _drop(count, co)
    )

fun drop_while(fn, co) =
    spawn(
        fun (yield) =
            let fun _drop_while
                    | (p, []) =
                        empty(co)
                    | (p, xs @ [x, ...xs1]) =
                        if p(x) then
                            _drop_while(p, xs1)
                        else
                            seq:traverse(map(yield, xs))

            in _drop_while(fn, co)
    )


fun each(co) =
    spawn(
        fun (yield) =
            (fun | [] = empty(co)
                 | s = seq:traverse(
                         map(yield, s)
                       )
            )(co)
    )


fun to_list(co) =
    seq:map(identity, co)


fun scanl(fn, acc, co) =
    spawn(
        fun (yield) =
            let fun _scanl
                | (f, acc, []) = empty(co)
                | (f, acc, x::xs) =
                (
                    let v = f(x, acc)
                    in (
                        yield(v)
                        _scanl(f, v, xs)
                    )
                )
            in _scanl(fn, acc, co)
    )


fun intersperse(val, co) =
    spawn(
        fun (yield) =
            seq:foreach(
                fun (x) =
                (
                    yield(x)
                    yield(val)
                ),
                co
            )
    )


fun zip(co1, co2) =
    spawn(
        let fun __zip (yield) =
            let fun _zip(co1, co2) =
            (
                io:print(#zip, co1, co2)
                if is_empty(co1) or is_empty(co2) then
                (
                    io:print(#S1, is_empty(co1), is_empty(co2))
                    []
                )
                else
                (
                    let
                        _ = io:print(#zip1)
                        x = co1 (42)
                        _ = io:print(#zip2)
                        y = co2()
                    in
                    (
                        if is_empty(co1) or is_empty(co2) then
                        (
                            io:print(#S2, is_empty(co1), is_empty(co2))
                            (x,y)
                        )
                        else
                        (
                            io:print(#S3, x, y, is_empty(co1), is_empty(co2))
                            yield((x,y))
                            _zip(co1, co2)
                        )
                    )
                )
//                match (co1, co2)
//                    | (x::xs, y::ys) =
//                    (
//                        io:print(#bb, x, y, is_empty(xs), is_empty(ys))
//                        yield((x,y))
//                        _zip(xs, ys)
//                    )
//                    | (xs, ys) =
//                    (
//                        io:print(#cc, xs, ys)
//                        []
//                    )

            )
////                | (x::xs, y::ys) when is_empty(xs) or is_empty(ys) =
////                (
////                    io:print(#aa, x, y)
////                    (x,y)
////                )
//
            in _zip(co1, co2)
        in __zip
    )


//fun init(coll)
//    | [x] = empty(coll)
//    | [x, ...xs] = x :: init(xs)
//    | [] = throw ValueError ("empty seq in init")
//
//
//fun zip(seq1, seq2)
//
//fun zipwith(f, seq1, seq2)
//    | (f, x::xs, y::ys) = f(x, y) :: zipwith(f, xs, ys)
//    | (_, _, _) = []
//

///////////////////////////////////////////////////////



affirm:is_equal (add v1 v2) (Vec2 (Point2 10 12)  (Point2 14 16))

(affirm:is_equal
    (fun (x y) =
        print x y
        z = x + sqrt x
        transpose x y (sum (x,y,z))
    )
    (Vec2
        (Point2 10 12)
        (Point2 14 16)))

(fun filter(predicate coll) =
    (fun _wrap(yield) =
        (fun _filter
            | (p []) = empty(coll)
            | (p x::xs) =
                (if p x then
                    yield x
                    (io.print
                        (match x
                            | 0 = #null
                            | 1 = #one
                            | (a, b, c) = a + b + c
                        )
                    )
                    _filter p xs
                else
                    io.print x
                    _filter p xs
                )
        )
        _filter predicate coll
    )
    coroutine _wrap
)
[fun (s)
    | [] = []
    | x :: xs =
        (x,xs)
    yield w

 , 1, 2]
(fun loop (...a) =
        (init_fn, args) = tuple:split a
        (co =
            spawn
                fun (yield) =
                    (fn = init_fn
                        fun (...args) =
                            apply yield args
                            apply fn args
                    )
                    yield ()
                    apply fn args

        )
   co ()
   co
)


(fun var (v) =
    co = (coroutine
            (fun (yield v) =
                (fun loop(v) =
                    msg = yield v
                    match msg
                        | #Read = loop(v)
                        | (#Write, new_val) = loop new_val
                )
            )
        )
    co v
    Var co
)


(fun nbn_3 () =
    (string:join
        (seq:map
            (fun(n) => string:join_cast
               (seq:map (fun (g) =
                            (fun _loop (n g) =
                                (if g == 1 or n < g then 1
                                else
                                    (seq:foldl
                                        (fun (q res) =
                                            res + 0 if q > n - g else (_loop (n-g) q)
                                        )
                                        1
                                        (range 2 g)
                                    )
                                )
                            ) n g)
                        (range 1 n)
               )
            " "
            )
           (range 1 25)
        )
        "\n"
    )
)








(fun nbn_1() =
    (fun _loop(n g) =
        if g == 1 or n < g then
           1
        else
            (seq:foldl
                (fun(q res) =
                    if q > n - g then
                         x = 0
                    else
                        x = _loop (n-g) q

                    res + x
                )
                1
                (list:range 2 g)
            )
    )

    (string:join
        (seq:map
            (fun (n) =
                (string:join_cast
                   (seq:map
                        (g -> _loop n g)
                        (list:range 1 n)
                   )
                   " "
                )
             )
             (list:range 1 25)
         )
         "\n"
    )
)

(fun test_partial() =
    affirm:is_equal ((&`-` 1) 2) -1

    affirm:is_equal (partial flip `-` 1)(2) 1

    add1 = &add 1
    affirm:is_equal (add1 2) 3

)

(fun test_composition() =
        add1_mul2 =  &add 1 >> &mul 2
        mul2_add1 = partial add 1 << partial mul 2
        add_1_twice = twice (&add 1)
)

(fun test_pipe() =
    l = list:range 0 10

    (affirm:is_equal
        l |> seq:filter even
          |> seq:map .. (&`+` 1)
          |> seq:map .. (&flip `-` 2)
          |> seq:map .. (&triple >> square)
     )  [9, 9, 81, 225, 441]

    affirm:is_equal (
        l |> seq:filter even _
          |> seq:map (`+` 1 _)
          |> seq:map (flip `-` 2 _) _
          |> seq:map (triple >> square) _
     )  [9, 9, 81, 225, 441]

    affirm:is_equal (
        l |> seq:filter(even, _)
          |> seq:map(`+`(1, _), _)
          |> seq:map(flip(`-`, 2, _), _)
          |> seq:map(triple >> square, _)
     )  [9, 9, 81, 225, 441]


    (affirm:is_equal
       (l |> seq:filter .. even)
        [0, 2, 4, 6, 8]
    )

    affirm:is_equal (
        l |> seq:filter .. even
          |> seq:map .. (`+` .. 1)
     ) [1, 3, 5, 7, 9]

    affirm:is_equal (
        l |> seq:filter .. even
          |> seq:map .. (`+` .. 1)
          |> seq:map .. (flip .. `-` .. 2)
     ) [-1, 1, 3, 5, 7]

    square = (x => x * x)
    triple = `*` .. 3
    affirm:is_equal (
        l |> seq:filter even
          |> seq:map .. (&`+` 1)
          |> seq:map .. (&flip `-` 2)
          |> seq:map .. (&triple >> square)
     )  [9, 9, 81, 225, 441]


    affirm:is_equal (
         (seq:filter even
          >> &seq:map (&`+` 1)
          >> &seq:map (&flip `-` 2)
          >> &seq:map (&triple >> &square)) l
     )  [9, 9, 81, 225, 441]

    affirm:is_equal (
        l |> &seq:filter even
          >> &seq:map (`+` 1)
          >> &seq:map (&flip `-` 2)
          >> &seq:map (&triple >> square)
     )  [9, 9, 81, 225, 441]


from arza.types import api, space, plist
from arza.runtime import error


class Types:
    def __init__(self, symbols, interfaces):
        from arza.types.space import newnativedatatype as newtype
        _s = symbols.symbol

        # ---------------AUTOGENERATED---------------------

        self.Bool = newtype(_s(u"Bool"))
        self.Bool.register_interface(interfaces.Any)

        self.Char = newtype(_s(u"Char"))
        self.Char.register_interface(interfaces.Any)

        self.Int = newtype(_s(u"Int"))
        self.Int.register_interface(interfaces.Any)

        self.Float = newtype(_s(u"Float"))
        self.Float.register_interface(interfaces.Any)

        self.Symbol = newtype(_s(u"Symbol"))
        self.Symbol.register_interface(interfaces.Any)

        self.String = newtype(_s(u"String"))
        self.String.register_interface(interfaces.Any)

        self.List = newtype(_s(u"List"))
        self.List.register_interface(interfaces.Any)

        self.Vector = newtype(_s(u"Vector"))
        self.Vector.register_interface(interfaces.Any)

        self.Tuple = newtype(_s(u"Tuple"))
        self.Tuple.register_interface(interfaces.Any)

        self.Map = newtype(_s(u"Map"))
        self.Map.register_interface(interfaces.Any)

        self.Function = newtype(_s(u"Function"))
        self.Function.register_interface(interfaces.Any)

        self.Partial = newtype(_s(u"Partial"))
        self.Partial.register_interface(interfaces.Any)

        self.Generic = newtype(_s(u"Generic"))
        self.Generic.register_interface(interfaces.Any)

        self.FiberChannel = newtype(_s(u"FiberChannel"))
        self.FiberChannel.register_interface(interfaces.Any)

        self.Coroutine = newtype(_s(u"Coroutine"))
        self.Coroutine.register_interface(interfaces.Any)

        self.Interface = newtype(_s(u"Interface"))
        self.Interface.register_interface(interfaces.Any)

        self.Datatype = newtype(_s(u"Datatype"))
        self.Datatype.register_interface(interfaces.Any)

        self.Env = newtype(_s(u"Env"))
        self.Env.register_interface(interfaces.Any)


class Interfaces:
    def __init__(self, symbols):
        _s = symbols.symbol
        self.Any = space.newinterface(_s(u"Any"), plist.empty(), plist.empty())
        self.Instance = space.newinterface(_s(u"Instance"), plist.empty(), plist.empty())
        self.Singleton = space.newinterface(_s(u"Singleton"), plist.empty(), plist.empty())

        self.Seq = None
        self.Dict = None
        self.Indexed = None
        self.Sized = None
        self.Len = None
        self.Indexed = None
        self.Eq = None
        self.PartialEq = None
        self.Str = None
        self.Displayed = None
        self.Collection = None
        self.instance_derived = None
        self.singleton_derived = None

    def setup(self, process):
        prelude = process.modules.prelude
        self.Seq = self.find_interface(process, prelude, u"Seq")
        self.Collection = self.find_interface(process, prelude, u"Collection")
        self.Dict = self.find_interface(process, prelude, u"Dict")
        self.Indexed = self.find_interface(process, prelude, u"Indexed")
        self.Sized = self.find_interface(process, prelude, u"Sized")
        self.Len = self.find_interface(process, prelude, u"Len")
        self.Indexed = self.find_interface(process, prelude, u"Indexed")
        self.Eq = self.find_interface(process, prelude, u"Eq")
        self.PartialEq = self.find_interface(process, prelude, u"PartialEq")
        self.Str = self.find_interface(process, prelude, u"Str")
        self.Displayed = self.find_interface(process, prelude, u"Displayed")

        # // derive (Dict, Sized, Len, Indexed) for Instance
        # derive (Eq, PartialEq, Str, Displayed) for (

        self.instance_derived = space.newlist([
            self.Dict, self.Sized, self.Len, self.Indexed,
            self.Eq, self.PartialEq, self.Str, self.Displayed
        ])

        self.singleton_derived = space.newlist([
            self.Eq, self.PartialEq, self.Str, self.Displayed
        ])

        api.put(prelude, self.Any.name, self.Any)
        api.put(prelude, self.Instance.name, self.Instance)
        api.put(prelude, self.Singleton.name, self.Singleton)

        self._derive_prelude(process)

    def _derive_prelude(self, process):
        module = process.modules.prelude
        from arza.types import api, datatype
        symbols = module.symbols()
        for sym in symbols:
            obj = api.at(module, sym)
            if space.isuserdatatype(obj):
                derived = self.get_derived(obj)
                datatype.derive(process, obj, derived)

    def get_derived(self, _type):
        if space.isuserdatatype(_type):
            if _type.is_singleton:
                return self.singleton_derived
            else:
                return self.instance_derived
        else:
            return error.throw_2(error.Errors.TYPE_ERROR, space.newstring(u"Type Expected"), _type)

    def is_default_derivable_interface(self, iface):
        return api.contains_b(self.instance_derived, iface) or api.contains_b(self.singleton_derived, iface)

    def _find_in(self, process, prelude, name):
        sym = space.newsymbol(process, name)
        if not api.contains(prelude, sym):
            error.throw_1(error.Errors.KEY_ERROR, space.newstring(u"Missing internal trait %s in prelude" % name))
        return api.at(prelude, sym)

    def find_interface(self, process, module, name):
        _interface = self._find_in(process, module, name)
        error.affirm_type(_interface, space.isinterface)
        return _interface


class Std:
    def __init__(self, symbols):
        self.interfaces = Interfaces(symbols)
        self.types = Types(symbols, self.interfaces)
        self.initialized = False

    def postsetup(self, process):
        self.interfaces.setup(process)
        self.initialized = True

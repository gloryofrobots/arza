from arza.types import api, space, plist
from arza.runtime import error


#
# self.derived_for_singleton = [
#     self.TEq, self.TStr, self.TRepr
# ]
#
# self.derived_for_type = [
#     self.TEq, self.TStr, self.TRepr,
#     self.TCollection, self.TSized, self.TIndexed, self.TDict
# ]

class Types:
    def __init__(self, symbols, interfaces):
        from arza.types.space import newnativedatatype as newtype
        _s = symbols.symbol

        # ---------------AUTOGENERATED---------------------

        self.Bool = newtype(_s(u"Bool"))
        self.Bool.register_interface(interfaces.Any)

        self.Char = newtype(_s(u"Char"))
        self.Char.register_interface(interfaces.Any)

        self.Int = newtype(_s(u"Int"))
        self.Int.register_interface(interfaces.Any)

        self.Float = newtype(_s(u"Float"))
        self.Float.register_interface(interfaces.Any)

        self.Symbol = newtype(_s(u"Symbol"))
        self.Symbol.register_interface(interfaces.Any)

        self.String = newtype(_s(u"String"))
        self.String.register_interface(interfaces.Any)

        self.List = newtype(_s(u"List"))
        self.List.register_interface(interfaces.Any)

        self.Vector = newtype(_s(u"Vector"))
        self.Vector.register_interface(interfaces.Any)

        self.Tuple = newtype(_s(u"Tuple"))
        self.Tuple.register_interface(interfaces.Any)

        self.Map = newtype(_s(u"Map"))
        self.Map.register_interface(interfaces.Any)

        self.Function = newtype(_s(u"Function"))
        self.Function.register_interface(interfaces.Any)

        self.Partial = newtype(_s(u"Partial"))
        self.Partial.register_interface(interfaces.Any)

        self.Generic = newtype(_s(u"Generic"))
        self.Generic.register_interface(interfaces.Any)

        self.FiberChannel = newtype(_s(u"FiberChannel"))
        self.FiberChannel.register_interface(interfaces.Any)

        self.Coroutine = newtype(_s(u"Coroutine"))
        self.Coroutine.register_interface(interfaces.Any)

        self.Trait = newtype(_s(u"Trait"))
        self.Trait.register_interface(interfaces.Any)

        self.Interface = newtype(_s(u"Interface"))
        self.Interface.register_interface(interfaces.Any)

        self.Datatype = newtype(_s(u"Datatype"))
        self.Datatype.register_interface(interfaces.Any)

        self.Env = newtype(_s(u"Env"))
        self.Env.register_interface(interfaces.Any)


class Interfaces:
    def __init__(self, symbols):
        _s = symbols.symbol
        self.Any = space.newinterface(_s(u"Any"), plist.empty())
        self.Instance = space.newinterface(_s(u"Instance"), plist.empty())
        self.Singleton = space.newinterface(_s(u"Singleton"), plist.empty())

        self.Seq = None
        self.Dict = None
        self.Indexed = None

    def setup(self, process):
        prelude = process.modules.prelude
        self.Seq = self.find_interface(process, prelude, u"Seq")
        self.Dict = self.find_interface(process, prelude, u"Dict")
        self.Indexed = self.find_interface(process, prelude, u"Indexed")
        api.put(prelude, self.Any.name, self.Any)
        api.put(prelude, self.Instance.name, self.Instance)
        api.put(prelude, self.Singleton.name, self.Singleton)

    def _find_in(self, process, prelude, name):
        sym = space.newsymbol(process, name)
        if not api.contains(prelude, sym):
            error.throw_1(error.Errors.KEY_ERROR, space.newstring(u"Missing internal trait %s in prelude" % name))
        return api.at(prelude, sym)

    def find_interface(self, process, module, name):
        _interface = self._find_in(process, module, name)
        error.affirm_type(_interface, space.isinterface)
        return _interface


class Std:
    def __init__(self, symbols):
        self.interfaces = Interfaces(symbols)
        self.types = Types(symbols, self.interfaces)
        # self.initialized = False

    def postsetup(self, process):
        self.interfaces.setup(process)
        # self.initialized = True
